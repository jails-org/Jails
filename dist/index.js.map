{"version":3,"file":"index.js","sources":["../src/utils/index.ts","../node_modules/idiomorph/dist/idiomorph.esm.js","../src/utils/pubsub.ts","../src/component.ts","../src/element.ts","../src/template-system.ts","../src/index.ts"],"sourcesContent":["let textarea\n\nexport const g = {\n\tscope: {}\n}\n\nexport const decodeHTML = (text) => {\n\ttextarea = textarea || document.createElement('textarea')\n\ttextarea.innerHTML = text\n\treturn textarea.value\n}\n\nexport const rAF = (fn) => {\n\tif (requestAnimationFrame)\n\t\treturn requestAnimationFrame(fn)\n\telse\n\t\treturn setTimeout(fn, 1000 / 60)\n}\n\nexport const uuid = () => {\n\treturn Math.random().toString(36).substring(2, 9)\n}\n\nexport const dup = (o) => {\n\treturn JSON.parse(JSON.stringify(o))\n}\n\nexport const safe = (execute, val) => {\n\ttry{\n\t\tconst value = execute()\n\t\treturn value !== undefined && value !== null ? value : val || ''\n\t}catch(err){\n\t\treturn val || ''\n\t}\n}\n","/**\n * @typedef {object} ConfigHead\n *\n * @property {'merge' | 'append' | 'morph' | 'none'} [style]\n * @property {boolean} [block]\n * @property {boolean} [ignore]\n * @property {function(Element): boolean} [shouldPreserve]\n * @property {function(Element): boolean} [shouldReAppend]\n * @property {function(Element): boolean} [shouldRemove]\n * @property {function(Element, {added: Node[], kept: Element[], removed: Element[]}): void} [afterHeadMorphed]\n */\n\n/**\n * @typedef {object} ConfigCallbacks\n *\n * @property {function(Node): boolean} [beforeNodeAdded]\n * @property {function(Node): void} [afterNodeAdded]\n * @property {function(Element, Node): boolean} [beforeNodeMorphed]\n * @property {function(Element, Node): void} [afterNodeMorphed]\n * @property {function(Element): boolean} [beforeNodeRemoved]\n * @property {function(Element): void} [afterNodeRemoved]\n * @property {function(string, Element, \"update\" | \"remove\"): boolean} [beforeAttributeUpdated]\n */\n\n/**\n * @typedef {object} Config\n *\n * @property {'outerHTML' | 'innerHTML'} [morphStyle]\n * @property {boolean} [ignoreActive]\n * @property {boolean} [ignoreActiveValue]\n * @property {boolean} [restoreFocus]\n * @property {ConfigCallbacks} [callbacks]\n * @property {ConfigHead} [head]\n */\n\n/**\n * @typedef {function} NoOp\n *\n * @returns {void}\n */\n\n/**\n * @typedef {object} ConfigHeadInternal\n *\n * @property {'merge' | 'append' | 'morph' | 'none'} style\n * @property {boolean} [block]\n * @property {boolean} [ignore]\n * @property {(function(Element): boolean) | NoOp} shouldPreserve\n * @property {(function(Element): boolean) | NoOp} shouldReAppend\n * @property {(function(Element): boolean) | NoOp} shouldRemove\n * @property {(function(Element, {added: Node[], kept: Element[], removed: Element[]}): void) | NoOp} afterHeadMorphed\n */\n\n/**\n * @typedef {object} ConfigCallbacksInternal\n *\n * @property {(function(Node): boolean) | NoOp} beforeNodeAdded\n * @property {(function(Node): void) | NoOp} afterNodeAdded\n * @property {(function(Node, Node): boolean) | NoOp} beforeNodeMorphed\n * @property {(function(Node, Node): void) | NoOp} afterNodeMorphed\n * @property {(function(Node): boolean) | NoOp} beforeNodeRemoved\n * @property {(function(Node): void) | NoOp} afterNodeRemoved\n * @property {(function(string, Element, \"update\" | \"remove\"): boolean) | NoOp} beforeAttributeUpdated\n */\n\n/**\n * @typedef {object} ConfigInternal\n *\n * @property {'outerHTML' | 'innerHTML'} morphStyle\n * @property {boolean} [ignoreActive]\n * @property {boolean} [ignoreActiveValue]\n * @property {boolean} [restoreFocus]\n * @property {ConfigCallbacksInternal} callbacks\n * @property {ConfigHeadInternal} head\n */\n\n/**\n * @typedef {Object} IdSets\n * @property {Set<string>} persistentIds\n * @property {Map<Node, Set<string>>} idMap\n */\n\n/**\n * @typedef {Function} Morph\n *\n * @param {Element | Document} oldNode\n * @param {Element | Node | HTMLCollection | Node[] | string | null} newContent\n * @param {Config} [config]\n * @returns {undefined | Node[]}\n */\n\n// base IIFE to define idiomorph\n/**\n *\n * @type {{defaults: ConfigInternal, morph: Morph}}\n */\nvar Idiomorph = (function () {\n  \"use strict\";\n\n  /**\n   * @typedef {object} MorphContext\n   *\n   * @property {Element} target\n   * @property {Element} newContent\n   * @property {ConfigInternal} config\n   * @property {ConfigInternal['morphStyle']} morphStyle\n   * @property {ConfigInternal['ignoreActive']} ignoreActive\n   * @property {ConfigInternal['ignoreActiveValue']} ignoreActiveValue\n   * @property {ConfigInternal['restoreFocus']} restoreFocus\n   * @property {Map<Node, Set<string>>} idMap\n   * @property {Set<string>} persistentIds\n   * @property {ConfigInternal['callbacks']} callbacks\n   * @property {ConfigInternal['head']} head\n   * @property {HTMLDivElement} pantry\n   */\n\n  //=============================================================================\n  // AND NOW IT BEGINS...\n  //=============================================================================\n\n  const noOp = () => {};\n  /**\n   * Default configuration values, updatable by users now\n   * @type {ConfigInternal}\n   */\n  const defaults = {\n    morphStyle: \"outerHTML\",\n    callbacks: {\n      beforeNodeAdded: noOp,\n      afterNodeAdded: noOp,\n      beforeNodeMorphed: noOp,\n      afterNodeMorphed: noOp,\n      beforeNodeRemoved: noOp,\n      afterNodeRemoved: noOp,\n      beforeAttributeUpdated: noOp,\n    },\n    head: {\n      style: \"merge\",\n      shouldPreserve: (elt) => elt.getAttribute(\"im-preserve\") === \"true\",\n      shouldReAppend: (elt) => elt.getAttribute(\"im-re-append\") === \"true\",\n      shouldRemove: noOp,\n      afterHeadMorphed: noOp,\n    },\n    restoreFocus: true,\n  };\n\n  /**\n   * Core idiomorph function for morphing one DOM tree to another\n   *\n   * @param {Element | Document} oldNode\n   * @param {Element | Node | HTMLCollection | Node[] | string | null} newContent\n   * @param {Config} [config]\n   * @returns {Promise<Node[]> | Node[]}\n   */\n  function morph(oldNode, newContent, config = {}) {\n    oldNode = normalizeElement(oldNode);\n    const newNode = normalizeParent(newContent);\n    const ctx = createMorphContext(oldNode, newNode, config);\n\n    const morphedNodes = saveAndRestoreFocus(ctx, () => {\n      return withHeadBlocking(\n        ctx,\n        oldNode,\n        newNode,\n        /** @param {MorphContext} ctx */ (ctx) => {\n          if (ctx.morphStyle === \"innerHTML\") {\n            morphChildren(ctx, oldNode, newNode);\n            return Array.from(oldNode.childNodes);\n          } else {\n            return morphOuterHTML(ctx, oldNode, newNode);\n          }\n        },\n      );\n    });\n\n    ctx.pantry.remove();\n    return morphedNodes;\n  }\n\n  /**\n   * Morph just the outerHTML of the oldNode to the newContent\n   * We have to be careful because the oldNode could have siblings which need to be untouched\n   * @param {MorphContext} ctx\n   * @param {Element} oldNode\n   * @param {Element} newNode\n   * @returns {Node[]}\n   */\n  function morphOuterHTML(ctx, oldNode, newNode) {\n    const oldParent = normalizeParent(oldNode);\n    morphChildren(\n      ctx,\n      oldParent,\n      newNode,\n      // these two optional params are the secret sauce\n      oldNode, // start point for iteration\n      oldNode.nextSibling, // end point for iteration\n    );\n    // this is safe even with siblings, because normalizeParent returns a SlicedParentNode if needed.\n    return Array.from(oldParent.childNodes);\n  }\n\n  /**\n   * @param {MorphContext} ctx\n   * @param {Function} fn\n   * @returns {Promise<Node[]> | Node[]}\n   */\n  function saveAndRestoreFocus(ctx, fn) {\n    if (!ctx.config.restoreFocus) return fn();\n    let activeElement =\n      /** @type {HTMLInputElement|HTMLTextAreaElement|null} */ (\n        document.activeElement\n      );\n\n    // don't bother if the active element is not an input or textarea\n    if (\n      !(\n        activeElement instanceof HTMLInputElement ||\n        activeElement instanceof HTMLTextAreaElement\n      )\n    ) {\n      return fn();\n    }\n\n    const { id: activeElementId, selectionStart, selectionEnd } = activeElement;\n\n    const results = fn();\n\n    if (activeElementId && activeElementId !== document.activeElement?.id) {\n      activeElement = ctx.target.querySelector(`[id=\"${activeElementId}\"]`);\n      activeElement?.focus();\n    }\n    if (activeElement && !activeElement.selectionEnd && selectionEnd) {\n      activeElement.setSelectionRange(selectionStart, selectionEnd);\n    }\n\n    return results;\n  }\n\n  const morphChildren = (function () {\n    /**\n     * This is the core algorithm for matching up children.  The idea is to use id sets to try to match up\n     * nodes as faithfully as possible.  We greedily match, which allows us to keep the algorithm fast, but\n     * by using id sets, we are able to better match up with content deeper in the DOM.\n     *\n     * Basic algorithm:\n     * - for each node in the new content:\n     *   - search self and siblings for an id set match, falling back to a soft match\n     *   - if match found\n     *     - remove any nodes up to the match:\n     *       - pantry persistent nodes\n     *       - delete the rest\n     *     - morph the match\n     *   - elsif no match found, and node is persistent\n     *     - find its match by querying the old root (future) and pantry (past)\n     *     - move it and its children here\n     *     - morph it\n     *   - else\n     *     - create a new node from scratch as a last result\n     *\n     * @param {MorphContext} ctx the merge context\n     * @param {Element} oldParent the old content that we are merging the new content into\n     * @param {Element} newParent the parent element of the new content\n     * @param {Node|null} [insertionPoint] the point in the DOM we start morphing at (defaults to first child)\n     * @param {Node|null} [endPoint] the point in the DOM we stop morphing at (defaults to after last child)\n     */\n    function morphChildren(\n      ctx,\n      oldParent,\n      newParent,\n      insertionPoint = null,\n      endPoint = null,\n    ) {\n      // normalize\n      if (\n        oldParent instanceof HTMLTemplateElement &&\n        newParent instanceof HTMLTemplateElement\n      ) {\n        // @ts-ignore we can pretend the DocumentFragment is an Element\n        oldParent = oldParent.content;\n        // @ts-ignore ditto\n        newParent = newParent.content;\n      }\n      insertionPoint ||= oldParent.firstChild;\n\n      // run through all the new content\n      for (const newChild of newParent.childNodes) {\n        // once we reach the end of the old parent content skip to the end and insert the rest\n        if (insertionPoint && insertionPoint != endPoint) {\n          const bestMatch = findBestMatch(\n            ctx,\n            newChild,\n            insertionPoint,\n            endPoint,\n          );\n          if (bestMatch) {\n            // if the node to morph is not at the insertion point then remove/move up to it\n            if (bestMatch !== insertionPoint) {\n              removeNodesBetween(ctx, insertionPoint, bestMatch);\n            }\n            morphNode(bestMatch, newChild, ctx);\n            insertionPoint = bestMatch.nextSibling;\n            continue;\n          }\n        }\n\n        // if the matching node is elsewhere in the original content\n        if (newChild instanceof Element && ctx.persistentIds.has(newChild.id)) {\n          // move it and all its children here and morph\n          const movedChild = moveBeforeById(\n            oldParent,\n            newChild.id,\n            insertionPoint,\n            ctx,\n          );\n          morphNode(movedChild, newChild, ctx);\n          insertionPoint = movedChild.nextSibling;\n          continue;\n        }\n\n        // last resort: insert the new node from scratch\n        const insertedNode = createNode(\n          oldParent,\n          newChild,\n          insertionPoint,\n          ctx,\n        );\n        // could be null if beforeNodeAdded prevented insertion\n        if (insertedNode) {\n          insertionPoint = insertedNode.nextSibling;\n        }\n      }\n\n      // remove any remaining old nodes that didn't match up with new content\n      while (insertionPoint && insertionPoint != endPoint) {\n        const tempNode = insertionPoint;\n        insertionPoint = insertionPoint.nextSibling;\n        removeNode(ctx, tempNode);\n      }\n    }\n\n    /**\n     * This performs the action of inserting a new node while handling situations where the node contains\n     * elements with persistent ids and possible state info we can still preserve by moving in and then morphing\n     *\n     * @param {Element} oldParent\n     * @param {Node} newChild\n     * @param {Node|null} insertionPoint\n     * @param {MorphContext} ctx\n     * @returns {Node|null}\n     */\n    function createNode(oldParent, newChild, insertionPoint, ctx) {\n      if (ctx.callbacks.beforeNodeAdded(newChild) === false) return null;\n      if (ctx.idMap.has(newChild)) {\n        // node has children with ids with possible state so create a dummy elt of same type and apply full morph algorithm\n        const newEmptyChild = document.createElement(\n          /** @type {Element} */ (newChild).tagName,\n        );\n        oldParent.insertBefore(newEmptyChild, insertionPoint);\n        morphNode(newEmptyChild, newChild, ctx);\n        ctx.callbacks.afterNodeAdded(newEmptyChild);\n        return newEmptyChild;\n      } else {\n        // optimisation: no id state to preserve so we can just insert a clone of the newChild and its descendants\n        const newClonedChild = document.importNode(newChild, true); // importNode to not mutate newParent\n        oldParent.insertBefore(newClonedChild, insertionPoint);\n        ctx.callbacks.afterNodeAdded(newClonedChild);\n        return newClonedChild;\n      }\n    }\n\n    //=============================================================================\n    // Matching Functions\n    //=============================================================================\n    const findBestMatch = (function () {\n      /**\n       * Scans forward from the startPoint to the endPoint looking for a match\n       * for the node. It looks for an id set match first, then a soft match.\n       * We abort softmatching if we find two future soft matches, to reduce churn.\n       * @param {Node} node\n       * @param {MorphContext} ctx\n       * @param {Node | null} startPoint\n       * @param {Node | null} endPoint\n       * @returns {Node | null}\n       */\n      function findBestMatch(ctx, node, startPoint, endPoint) {\n        let softMatch = null;\n        let nextSibling = node.nextSibling;\n        let siblingSoftMatchCount = 0;\n\n        let cursor = startPoint;\n        while (cursor && cursor != endPoint) {\n          // soft matching is a prerequisite for id set matching\n          if (isSoftMatch(cursor, node)) {\n            if (isIdSetMatch(ctx, cursor, node)) {\n              return cursor; // found an id set match, we're done!\n            }\n\n            // we haven't yet saved a soft match fallback\n            if (softMatch === null) {\n              // the current soft match will hard match something else in the future, leave it\n              if (!ctx.idMap.has(cursor)) {\n                // save this as the fallback if we get through the loop without finding a hard match\n                softMatch = cursor;\n              }\n            }\n          }\n          if (\n            softMatch === null &&\n            nextSibling &&\n            isSoftMatch(cursor, nextSibling)\n          ) {\n            // The next new node has a soft match with this node, so\n            // increment the count of future soft matches\n            siblingSoftMatchCount++;\n            nextSibling = nextSibling.nextSibling;\n\n            // If there are two future soft matches, block soft matching for this node to allow\n            // future siblings to soft match. This is to reduce churn in the DOM when an element\n            // is prepended.\n            if (siblingSoftMatchCount >= 2) {\n              softMatch = undefined;\n            }\n          }\n\n          // if the current node contains active element, stop looking for better future matches,\n          // because if one is found, this node will be moved to the pantry, reparenting it and thus losing focus\n          if (cursor.contains(document.activeElement)) break;\n\n          cursor = cursor.nextSibling;\n        }\n\n        return softMatch || null;\n      }\n\n      /**\n       *\n       * @param {MorphContext} ctx\n       * @param {Node} oldNode\n       * @param {Node} newNode\n       * @returns {boolean}\n       */\n      function isIdSetMatch(ctx, oldNode, newNode) {\n        let oldSet = ctx.idMap.get(oldNode);\n        let newSet = ctx.idMap.get(newNode);\n\n        if (!newSet || !oldSet) return false;\n\n        for (const id of oldSet) {\n          // a potential match is an id in the new and old nodes that\n          // has not already been merged into the DOM\n          // But the newNode content we call this on has not been\n          // merged yet and we don't allow duplicate IDs so it is simple\n          if (newSet.has(id)) {\n            return true;\n          }\n        }\n        return false;\n      }\n\n      /**\n       *\n       * @param {Node} oldNode\n       * @param {Node} newNode\n       * @returns {boolean}\n       */\n      function isSoftMatch(oldNode, newNode) {\n        // ok to cast: if one is not element, `id` and `tagName` will be undefined and we'll just compare that.\n        const oldElt = /** @type {Element} */ (oldNode);\n        const newElt = /** @type {Element} */ (newNode);\n\n        return (\n          oldElt.nodeType === newElt.nodeType &&\n          oldElt.tagName === newElt.tagName &&\n          // If oldElt has an `id` with possible state and it doesn't match newElt.id then avoid morphing.\n          // We'll still match an anonymous node with an IDed newElt, though, because if it got this far,\n          // its not persistent, and new nodes can't have any hidden state.\n          (!oldElt.id || oldElt.id === newElt.id)\n        );\n      }\n\n      return findBestMatch;\n    })();\n\n    //=============================================================================\n    // DOM Manipulation Functions\n    //=============================================================================\n\n    /**\n     * Gets rid of an unwanted DOM node; strategy depends on nature of its reuse:\n     * - Persistent nodes will be moved to the pantry for later reuse\n     * - Other nodes will have their hooks called, and then are removed\n     * @param {MorphContext} ctx\n     * @param {Node} node\n     */\n    function removeNode(ctx, node) {\n      // are we going to id set match this later?\n      if (ctx.idMap.has(node)) {\n        // skip callbacks and move to pantry\n        moveBefore(ctx.pantry, node, null);\n      } else {\n        // remove for realsies\n        if (ctx.callbacks.beforeNodeRemoved(node) === false) return;\n        node.parentNode?.removeChild(node);\n        ctx.callbacks.afterNodeRemoved(node);\n      }\n    }\n\n    /**\n     * Remove nodes between the start and end nodes\n     * @param {MorphContext} ctx\n     * @param {Node} startInclusive\n     * @param {Node} endExclusive\n     * @returns {Node|null}\n     */\n    function removeNodesBetween(ctx, startInclusive, endExclusive) {\n      /** @type {Node | null} */\n      let cursor = startInclusive;\n      // remove nodes until the endExclusive node\n      while (cursor && cursor !== endExclusive) {\n        let tempNode = /** @type {Node} */ (cursor);\n        cursor = cursor.nextSibling;\n        removeNode(ctx, tempNode);\n      }\n      return cursor;\n    }\n\n    /**\n     * Search for an element by id within the document and pantry, and move it using moveBefore.\n     *\n     * @param {Element} parentNode - The parent node to which the element will be moved.\n     * @param {string} id - The ID of the element to be moved.\n     * @param {Node | null} after - The reference node to insert the element before.\n     *                              If `null`, the element is appended as the last child.\n     * @param {MorphContext} ctx\n     * @returns {Element} The found element\n     */\n    function moveBeforeById(parentNode, id, after, ctx) {\n      const target =\n        /** @type {Element} - will always be found */\n        (\n          (ctx.target.id === id && ctx.target) ||\n            ctx.target.querySelector(`[id=\"${id}\"]`) ||\n            ctx.pantry.querySelector(`[id=\"${id}\"]`)\n        );\n      removeElementFromAncestorsIdMaps(target, ctx);\n      moveBefore(parentNode, target, after);\n      return target;\n    }\n\n    /**\n     * Removes an element from its ancestors' id maps. This is needed when an element is moved from the\n     * \"future\" via `moveBeforeId`. Otherwise, its erstwhile ancestors could be mistakenly moved to the\n     * pantry rather than being deleted, preventing their removal hooks from being called.\n     *\n     * @param {Element} element - element to remove from its ancestors' id maps\n     * @param {MorphContext} ctx\n     */\n    function removeElementFromAncestorsIdMaps(element, ctx) {\n      const id = element.id;\n      /** @ts-ignore - safe to loop in this way **/\n      while ((element = element.parentNode)) {\n        let idSet = ctx.idMap.get(element);\n        if (idSet) {\n          idSet.delete(id);\n          if (!idSet.size) {\n            ctx.idMap.delete(element);\n          }\n        }\n      }\n    }\n\n    /**\n     * Moves an element before another element within the same parent.\n     * Uses the proposed `moveBefore` API if available (and working), otherwise falls back to `insertBefore`.\n     * This is essentialy a forward-compat wrapper.\n     *\n     * @param {Element} parentNode - The parent node containing the after element.\n     * @param {Node} element - The element to be moved.\n     * @param {Node | null} after - The reference node to insert `element` before.\n     *                              If `null`, `element` is appended as the last child.\n     */\n    function moveBefore(parentNode, element, after) {\n      // @ts-ignore - use proposed moveBefore feature\n      if (parentNode.moveBefore) {\n        try {\n          // @ts-ignore - use proposed moveBefore feature\n          parentNode.moveBefore(element, after);\n        } catch (e) {\n          // fall back to insertBefore as some browsers may fail on moveBefore when trying to move Dom disconnected nodes to pantry\n          parentNode.insertBefore(element, after);\n        }\n      } else {\n        parentNode.insertBefore(element, after);\n      }\n    }\n\n    return morphChildren;\n  })();\n\n  //=============================================================================\n  // Single Node Morphing Code\n  //=============================================================================\n  const morphNode = (function () {\n    /**\n     * @param {Node} oldNode root node to merge content into\n     * @param {Node} newContent new content to merge\n     * @param {MorphContext} ctx the merge context\n     * @returns {Node | null} the element that ended up in the DOM\n     */\n    function morphNode(oldNode, newContent, ctx) {\n      if (ctx.ignoreActive && oldNode === document.activeElement) {\n        // don't morph focused element\n        return null;\n      }\n\n      if (ctx.callbacks.beforeNodeMorphed(oldNode, newContent) === false) {\n        return oldNode;\n      }\n\n      if (oldNode instanceof HTMLHeadElement && ctx.head.ignore) {\n        // ignore the head element\n      } else if (\n        oldNode instanceof HTMLHeadElement &&\n        ctx.head.style !== \"morph\"\n      ) {\n        // ok to cast: if newContent wasn't also a <head>, it would've got caught in the `!isSoftMatch` branch above\n        handleHeadElement(\n          oldNode,\n          /** @type {HTMLHeadElement} */ (newContent),\n          ctx,\n        );\n      } else {\n        morphAttributes(oldNode, newContent, ctx);\n        if (!ignoreValueOfActiveElement(oldNode, ctx)) {\n          // @ts-ignore newContent can be a node here because .firstChild will be null\n          morphChildren(ctx, oldNode, newContent);\n        }\n      }\n      ctx.callbacks.afterNodeMorphed(oldNode, newContent);\n      return oldNode;\n    }\n\n    /**\n     * syncs the oldNode to the newNode, copying over all attributes and\n     * inner element state from the newNode to the oldNode\n     *\n     * @param {Node} oldNode the node to copy attributes & state to\n     * @param {Node} newNode the node to copy attributes & state from\n     * @param {MorphContext} ctx the merge context\n     */\n    function morphAttributes(oldNode, newNode, ctx) {\n      let type = newNode.nodeType;\n\n      // if is an element type, sync the attributes from the\n      // new node into the new node\n      if (type === 1 /* element type */) {\n        const oldElt = /** @type {Element} */ (oldNode);\n        const newElt = /** @type {Element} */ (newNode);\n\n        const oldAttributes = oldElt.attributes;\n        const newAttributes = newElt.attributes;\n        for (const newAttribute of newAttributes) {\n          if (ignoreAttribute(newAttribute.name, oldElt, \"update\", ctx)) {\n            continue;\n          }\n          if (oldElt.getAttribute(newAttribute.name) !== newAttribute.value) {\n            oldElt.setAttribute(newAttribute.name, newAttribute.value);\n          }\n        }\n        // iterate backwards to avoid skipping over items when a delete occurs\n        for (let i = oldAttributes.length - 1; 0 <= i; i--) {\n          const oldAttribute = oldAttributes[i];\n\n          // toAttributes is a live NamedNodeMap, so iteration+mutation is unsafe\n          // e.g. custom element attribute callbacks can remove other attributes\n          if (!oldAttribute) continue;\n\n          if (!newElt.hasAttribute(oldAttribute.name)) {\n            if (ignoreAttribute(oldAttribute.name, oldElt, \"remove\", ctx)) {\n              continue;\n            }\n            oldElt.removeAttribute(oldAttribute.name);\n          }\n        }\n\n        if (!ignoreValueOfActiveElement(oldElt, ctx)) {\n          syncInputValue(oldElt, newElt, ctx);\n        }\n      }\n\n      // sync text nodes\n      if (type === 8 /* comment */ || type === 3 /* text */) {\n        if (oldNode.nodeValue !== newNode.nodeValue) {\n          oldNode.nodeValue = newNode.nodeValue;\n        }\n      }\n    }\n\n    /**\n     * NB: many bothans died to bring us information:\n     *\n     *  https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n     *  https://github.com/choojs/nanomorph/blob/master/lib/morph.jsL113\n     *\n     * @param {Element} oldElement the element to sync the input value to\n     * @param {Element} newElement the element to sync the input value from\n     * @param {MorphContext} ctx the merge context\n     */\n    function syncInputValue(oldElement, newElement, ctx) {\n      if (\n        oldElement instanceof HTMLInputElement &&\n        newElement instanceof HTMLInputElement &&\n        newElement.type !== \"file\"\n      ) {\n        let newValue = newElement.value;\n        let oldValue = oldElement.value;\n\n        // sync boolean attributes\n        syncBooleanAttribute(oldElement, newElement, \"checked\", ctx);\n        syncBooleanAttribute(oldElement, newElement, \"disabled\", ctx);\n\n        if (!newElement.hasAttribute(\"value\")) {\n          if (!ignoreAttribute(\"value\", oldElement, \"remove\", ctx)) {\n            oldElement.value = \"\";\n            oldElement.removeAttribute(\"value\");\n          }\n        } else if (oldValue !== newValue) {\n          if (!ignoreAttribute(\"value\", oldElement, \"update\", ctx)) {\n            oldElement.setAttribute(\"value\", newValue);\n            oldElement.value = newValue;\n          }\n        }\n        // TODO: QUESTION(1cg): this used to only check `newElement` unlike the other branches -- why?\n        // did I break something?\n      } else if (\n        oldElement instanceof HTMLOptionElement &&\n        newElement instanceof HTMLOptionElement\n      ) {\n        syncBooleanAttribute(oldElement, newElement, \"selected\", ctx);\n      } else if (\n        oldElement instanceof HTMLTextAreaElement &&\n        newElement instanceof HTMLTextAreaElement\n      ) {\n        let newValue = newElement.value;\n        let oldValue = oldElement.value;\n        if (ignoreAttribute(\"value\", oldElement, \"update\", ctx)) {\n          return;\n        }\n        if (newValue !== oldValue) {\n          oldElement.value = newValue;\n        }\n        if (\n          oldElement.firstChild &&\n          oldElement.firstChild.nodeValue !== newValue\n        ) {\n          oldElement.firstChild.nodeValue = newValue;\n        }\n      }\n    }\n\n    /**\n     * @param {Element} oldElement element to write the value to\n     * @param {Element} newElement element to read the value from\n     * @param {string} attributeName the attribute name\n     * @param {MorphContext} ctx the merge context\n     */\n    function syncBooleanAttribute(oldElement, newElement, attributeName, ctx) {\n      // @ts-ignore this function is only used on boolean attrs that are reflected as dom properties\n      const newLiveValue = newElement[attributeName],\n        // @ts-ignore ditto\n        oldLiveValue = oldElement[attributeName];\n      if (newLiveValue !== oldLiveValue) {\n        const ignoreUpdate = ignoreAttribute(\n          attributeName,\n          oldElement,\n          \"update\",\n          ctx,\n        );\n        if (!ignoreUpdate) {\n          // update attribute's associated DOM property\n          // @ts-ignore this function is only used on boolean attrs that are reflected as dom properties\n          oldElement[attributeName] = newElement[attributeName];\n        }\n        if (newLiveValue) {\n          if (!ignoreUpdate) {\n            // https://developer.mozilla.org/en-US/docs/Glossary/Boolean/HTML\n            // this is the correct way to set a boolean attribute to \"true\"\n            oldElement.setAttribute(attributeName, \"\");\n          }\n        } else {\n          if (!ignoreAttribute(attributeName, oldElement, \"remove\", ctx)) {\n            oldElement.removeAttribute(attributeName);\n          }\n        }\n      }\n    }\n\n    /**\n     * @param {string} attr the attribute to be mutated\n     * @param {Element} element the element that is going to be updated\n     * @param {\"update\" | \"remove\"} updateType\n     * @param {MorphContext} ctx the merge context\n     * @returns {boolean} true if the attribute should be ignored, false otherwise\n     */\n    function ignoreAttribute(attr, element, updateType, ctx) {\n      if (\n        attr === \"value\" &&\n        ctx.ignoreActiveValue &&\n        element === document.activeElement\n      ) {\n        return true;\n      }\n      return (\n        ctx.callbacks.beforeAttributeUpdated(attr, element, updateType) ===\n        false\n      );\n    }\n\n    /**\n     * @param {Node} possibleActiveElement\n     * @param {MorphContext} ctx\n     * @returns {boolean}\n     */\n    function ignoreValueOfActiveElement(possibleActiveElement, ctx) {\n      return (\n        !!ctx.ignoreActiveValue &&\n        possibleActiveElement === document.activeElement &&\n        possibleActiveElement !== document.body\n      );\n    }\n\n    return morphNode;\n  })();\n\n  //=============================================================================\n  // Head Management Functions\n  //=============================================================================\n  /**\n   * @param {MorphContext} ctx\n   * @param {Element} oldNode\n   * @param {Element} newNode\n   * @param {function} callback\n   * @returns {Node[] | Promise<Node[]>}\n   */\n  function withHeadBlocking(ctx, oldNode, newNode, callback) {\n    if (ctx.head.block) {\n      const oldHead = oldNode.querySelector(\"head\");\n      const newHead = newNode.querySelector(\"head\");\n      if (oldHead && newHead) {\n        const promises = handleHeadElement(oldHead, newHead, ctx);\n        // when head promises resolve, proceed ignoring the head tag\n        return Promise.all(promises).then(() => {\n          const newCtx = Object.assign(ctx, {\n            head: {\n              block: false,\n              ignore: true,\n            },\n          });\n          return callback(newCtx);\n        });\n      }\n    }\n    // just proceed if we not head blocking\n    return callback(ctx);\n  }\n\n  /**\n   *  The HEAD tag can be handled specially, either w/ a 'merge' or 'append' style\n   *\n   * @param {Element} oldHead\n   * @param {Element} newHead\n   * @param {MorphContext} ctx\n   * @returns {Promise<void>[]}\n   */\n  function handleHeadElement(oldHead, newHead, ctx) {\n    let added = [];\n    let removed = [];\n    let preserved = [];\n    let nodesToAppend = [];\n\n    // put all new head elements into a Map, by their outerHTML\n    let srcToNewHeadNodes = new Map();\n    for (const newHeadChild of newHead.children) {\n      srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild);\n    }\n\n    // for each elt in the current head\n    for (const currentHeadElt of oldHead.children) {\n      // If the current head element is in the map\n      let inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML);\n      let isReAppended = ctx.head.shouldReAppend(currentHeadElt);\n      let isPreserved = ctx.head.shouldPreserve(currentHeadElt);\n      if (inNewContent || isPreserved) {\n        if (isReAppended) {\n          // remove the current version and let the new version replace it and re-execute\n          removed.push(currentHeadElt);\n        } else {\n          // this element already exists and should not be re-appended, so remove it from\n          // the new content map, preserving it in the DOM\n          srcToNewHeadNodes.delete(currentHeadElt.outerHTML);\n          preserved.push(currentHeadElt);\n        }\n      } else {\n        if (ctx.head.style === \"append\") {\n          // we are appending and this existing element is not new content\n          // so if and only if it is marked for re-append do we do anything\n          if (isReAppended) {\n            removed.push(currentHeadElt);\n            nodesToAppend.push(currentHeadElt);\n          }\n        } else {\n          // if this is a merge, we remove this content since it is not in the new head\n          if (ctx.head.shouldRemove(currentHeadElt) !== false) {\n            removed.push(currentHeadElt);\n          }\n        }\n      }\n    }\n\n    // Push the remaining new head elements in the Map into the\n    // nodes to append to the head tag\n    nodesToAppend.push(...srcToNewHeadNodes.values());\n\n    let promises = [];\n    for (const newNode of nodesToAppend) {\n      // TODO: This could theoretically be null, based on type\n      let newElt = /** @type {ChildNode} */ (\n        document.createRange().createContextualFragment(newNode.outerHTML)\n          .firstChild\n      );\n      if (ctx.callbacks.beforeNodeAdded(newElt) !== false) {\n        if (\n          (\"href\" in newElt && newElt.href) ||\n          (\"src\" in newElt && newElt.src)\n        ) {\n          /** @type {(result?: any) => void} */ let resolve;\n          let promise = new Promise(function (_resolve) {\n            resolve = _resolve;\n          });\n          newElt.addEventListener(\"load\", function () {\n            resolve();\n          });\n          promises.push(promise);\n        }\n        oldHead.appendChild(newElt);\n        ctx.callbacks.afterNodeAdded(newElt);\n        added.push(newElt);\n      }\n    }\n\n    // remove all removed elements, after we have appended the new elements to avoid\n    // additional network requests for things like style sheets\n    for (const removedElement of removed) {\n      if (ctx.callbacks.beforeNodeRemoved(removedElement) !== false) {\n        oldHead.removeChild(removedElement);\n        ctx.callbacks.afterNodeRemoved(removedElement);\n      }\n    }\n\n    ctx.head.afterHeadMorphed(oldHead, {\n      added: added,\n      kept: preserved,\n      removed: removed,\n    });\n    return promises;\n  }\n\n  //=============================================================================\n  // Create Morph Context Functions\n  //=============================================================================\n  const createMorphContext = (function () {\n    /**\n     *\n     * @param {Element} oldNode\n     * @param {Element} newContent\n     * @param {Config} config\n     * @returns {MorphContext}\n     */\n    function createMorphContext(oldNode, newContent, config) {\n      const { persistentIds, idMap } = createIdMaps(oldNode, newContent);\n\n      const mergedConfig = mergeDefaults(config);\n      const morphStyle = mergedConfig.morphStyle || \"outerHTML\";\n      if (![\"innerHTML\", \"outerHTML\"].includes(morphStyle)) {\n        throw `Do not understand how to morph style ${morphStyle}`;\n      }\n\n      return {\n        target: oldNode,\n        newContent: newContent,\n        config: mergedConfig,\n        morphStyle: morphStyle,\n        ignoreActive: mergedConfig.ignoreActive,\n        ignoreActiveValue: mergedConfig.ignoreActiveValue,\n        restoreFocus: mergedConfig.restoreFocus,\n        idMap: idMap,\n        persistentIds: persistentIds,\n        pantry: createPantry(),\n        callbacks: mergedConfig.callbacks,\n        head: mergedConfig.head,\n      };\n    }\n\n    /**\n     * Deep merges the config object and the Idiomorph.defaults object to\n     * produce a final configuration object\n     * @param {Config} config\n     * @returns {ConfigInternal}\n     */\n    function mergeDefaults(config) {\n      let finalConfig = Object.assign({}, defaults);\n\n      // copy top level stuff into final config\n      Object.assign(finalConfig, config);\n\n      // copy callbacks into final config (do this to deep merge the callbacks)\n      finalConfig.callbacks = Object.assign(\n        {},\n        defaults.callbacks,\n        config.callbacks,\n      );\n\n      // copy head config into final config  (do this to deep merge the head)\n      finalConfig.head = Object.assign({}, defaults.head, config.head);\n\n      return finalConfig;\n    }\n\n    /**\n     * @returns {HTMLDivElement}\n     */\n    function createPantry() {\n      const pantry = document.createElement(\"div\");\n      pantry.hidden = true;\n      document.body.insertAdjacentElement(\"afterend\", pantry);\n      return pantry;\n    }\n\n    /**\n     * Returns all elements with an ID contained within the root element and its descendants\n     *\n     * @param {Element} root\n     * @returns {Element[]}\n     */\n    function findIdElements(root) {\n      let elements = Array.from(root.querySelectorAll(\"[id]\"));\n      if (root.id) {\n        elements.push(root);\n      }\n      return elements;\n    }\n\n    /**\n     * A bottom-up algorithm that populates a map of Element -> IdSet.\n     * The idSet for a given element is the set of all IDs contained within its subtree.\n     * As an optimzation, we filter these IDs through the given list of persistent IDs,\n     * because we don't need to bother considering IDed elements that won't be in the new content.\n     *\n     * @param {Map<Node, Set<string>>} idMap\n     * @param {Set<string>} persistentIds\n     * @param {Element} root\n     * @param {Element[]} elements\n     */\n    function populateIdMapWithTree(idMap, persistentIds, root, elements) {\n      for (const elt of elements) {\n        if (persistentIds.has(elt.id)) {\n          /** @type {Element|null} */\n          let current = elt;\n          // walk up the parent hierarchy of that element, adding the id\n          // of element to the parent's id set\n          while (current) {\n            let idSet = idMap.get(current);\n            // if the id set doesn't exist, create it and insert it in the map\n            if (idSet == null) {\n              idSet = new Set();\n              idMap.set(current, idSet);\n            }\n            idSet.add(elt.id);\n\n            if (current === root) break;\n            current = current.parentElement;\n          }\n        }\n      }\n    }\n\n    /**\n     * This function computes a map of nodes to all ids contained within that node (inclusive of the\n     * node).  This map can be used to ask if two nodes have intersecting sets of ids, which allows\n     * for a looser definition of \"matching\" than tradition id matching, and allows child nodes\n     * to contribute to a parent nodes matching.\n     *\n     * @param {Element} oldContent  the old content that will be morphed\n     * @param {Element} newContent  the new content to morph to\n     * @returns {IdSets}\n     */\n    function createIdMaps(oldContent, newContent) {\n      const oldIdElements = findIdElements(oldContent);\n      const newIdElements = findIdElements(newContent);\n\n      const persistentIds = createPersistentIds(oldIdElements, newIdElements);\n\n      /** @type {Map<Node, Set<string>>} */\n      let idMap = new Map();\n      populateIdMapWithTree(idMap, persistentIds, oldContent, oldIdElements);\n\n      /** @ts-ignore - if newContent is a duck-typed parent, pass its single child node as the root to halt upwards iteration */\n      const newRoot = newContent.__idiomorphRoot || newContent;\n      populateIdMapWithTree(idMap, persistentIds, newRoot, newIdElements);\n\n      return { persistentIds, idMap };\n    }\n\n    /**\n     * This function computes the set of ids that persist between the two contents excluding duplicates\n     *\n     * @param {Element[]} oldIdElements\n     * @param {Element[]} newIdElements\n     * @returns {Set<string>}\n     */\n    function createPersistentIds(oldIdElements, newIdElements) {\n      let duplicateIds = new Set();\n\n      /** @type {Map<string, string>} */\n      let oldIdTagNameMap = new Map();\n      for (const { id, tagName } of oldIdElements) {\n        if (oldIdTagNameMap.has(id)) {\n          duplicateIds.add(id);\n        } else {\n          oldIdTagNameMap.set(id, tagName);\n        }\n      }\n\n      let persistentIds = new Set();\n      for (const { id, tagName } of newIdElements) {\n        if (persistentIds.has(id)) {\n          duplicateIds.add(id);\n        } else if (oldIdTagNameMap.get(id) === tagName) {\n          persistentIds.add(id);\n        }\n        // skip if tag types mismatch because its not possible to morph one tag into another\n      }\n\n      for (const id of duplicateIds) {\n        persistentIds.delete(id);\n      }\n      return persistentIds;\n    }\n\n    return createMorphContext;\n  })();\n\n  //=============================================================================\n  // HTML Normalization Functions\n  //=============================================================================\n  const { normalizeElement, normalizeParent } = (function () {\n    /** @type {WeakSet<Node>} */\n    const generatedByIdiomorph = new WeakSet();\n\n    /**\n     *\n     * @param {Element | Document} content\n     * @returns {Element}\n     */\n    function normalizeElement(content) {\n      if (content instanceof Document) {\n        return content.documentElement;\n      } else {\n        return content;\n      }\n    }\n\n    /**\n     *\n     * @param {null | string | Node | HTMLCollection | Node[] | Document & {generatedByIdiomorph:boolean}} newContent\n     * @returns {Element}\n     */\n    function normalizeParent(newContent) {\n      if (newContent == null) {\n        return document.createElement(\"div\"); // dummy parent element\n      } else if (typeof newContent === \"string\") {\n        return normalizeParent(parseContent(newContent));\n      } else if (\n        generatedByIdiomorph.has(/** @type {Element} */ (newContent))\n      ) {\n        // the template tag created by idiomorph parsing can serve as a dummy parent\n        return /** @type {Element} */ (newContent);\n      } else if (newContent instanceof Node) {\n        if (newContent.parentNode) {\n          // we can't use the parent directly because newContent may have siblings\n          // that we don't want in the morph, and reparenting might be expensive (TODO is it?),\n          // so instead we create a fake parent node that only sees a slice of its children.\n          /** @type {Element} */\n          return /** @type {any} */ (new SlicedParentNode(newContent));\n        } else {\n          // a single node is added as a child to a dummy parent\n          const dummyParent = document.createElement(\"div\");\n          dummyParent.append(newContent);\n          return dummyParent;\n        }\n      } else {\n        // all nodes in the array or HTMLElement collection are consolidated under\n        // a single dummy parent element\n        const dummyParent = document.createElement(\"div\");\n        for (const elt of [...newContent]) {\n          dummyParent.append(elt);\n        }\n        return dummyParent;\n      }\n    }\n\n    /**\n     * A fake duck-typed parent element to wrap a single node, without actually reparenting it.\n     * This is useful because the node may have siblings that we don't want in the morph, and it may also be moved\n     * or replaced with one or more elements during the morph. This class effectively allows us a window into\n     * a slice of a node's children.\n     * \"If it walks like a duck, and quacks like a duck, then it must be a duck!\" -- James Whitcomb Riley (1849–1916)\n     */\n    class SlicedParentNode {\n      /** @param {Node} node */\n      constructor(node) {\n        this.originalNode = node;\n        this.realParentNode = /** @type {Element} */ (node.parentNode);\n        this.previousSibling = node.previousSibling;\n        this.nextSibling = node.nextSibling;\n      }\n\n      /** @returns {Node[]} */\n      get childNodes() {\n        // return slice of realParent's current childNodes, based on previousSibling and nextSibling\n        const nodes = [];\n        let cursor = this.previousSibling\n          ? this.previousSibling.nextSibling\n          : this.realParentNode.firstChild;\n        while (cursor && cursor != this.nextSibling) {\n          nodes.push(cursor);\n          cursor = cursor.nextSibling;\n        }\n        return nodes;\n      }\n\n      /**\n       * @param {string} selector\n       * @returns {Element[]}\n       */\n      querySelectorAll(selector) {\n        return this.childNodes.reduce((results, node) => {\n          if (node instanceof Element) {\n            if (node.matches(selector)) results.push(node);\n            const nodeList = node.querySelectorAll(selector);\n            for (let i = 0; i < nodeList.length; i++) {\n              results.push(nodeList[i]);\n            }\n          }\n          return results;\n        }, /** @type {Element[]} */ ([]));\n      }\n\n      /**\n       * @param {Node} node\n       * @param {Node} referenceNode\n       * @returns {Node}\n       */\n      insertBefore(node, referenceNode) {\n        return this.realParentNode.insertBefore(node, referenceNode);\n      }\n\n      /**\n       * @param {Node} node\n       * @param {Node} referenceNode\n       * @returns {Node}\n       */\n      moveBefore(node, referenceNode) {\n        // @ts-ignore - use new moveBefore feature\n        return this.realParentNode.moveBefore(node, referenceNode);\n      }\n\n      /**\n       * for later use with populateIdMapWithTree to halt upwards iteration\n       * @returns {Node}\n       */\n      get __idiomorphRoot() {\n        return this.originalNode;\n      }\n    }\n\n    /**\n     *\n     * @param {string} newContent\n     * @returns {Node | null | DocumentFragment}\n     */\n    function parseContent(newContent) {\n      let parser = new DOMParser();\n\n      // remove svgs to avoid false-positive matches on head, etc.\n      let contentWithSvgsRemoved = newContent.replace(\n        /<svg(\\s[^>]*>|>)([\\s\\S]*?)<\\/svg>/gim,\n        \"\",\n      );\n\n      // if the newContent contains a html, head or body tag, we can simply parse it w/o wrapping\n      if (\n        contentWithSvgsRemoved.match(/<\\/html>/) ||\n        contentWithSvgsRemoved.match(/<\\/head>/) ||\n        contentWithSvgsRemoved.match(/<\\/body>/)\n      ) {\n        let content = parser.parseFromString(newContent, \"text/html\");\n        // if it is a full HTML document, return the document itself as the parent container\n        if (contentWithSvgsRemoved.match(/<\\/html>/)) {\n          generatedByIdiomorph.add(content);\n          return content;\n        } else {\n          // otherwise return the html element as the parent container\n          let htmlElement = content.firstChild;\n          if (htmlElement) {\n            generatedByIdiomorph.add(htmlElement);\n          }\n          return htmlElement;\n        }\n      } else {\n        // if it is partial HTML, wrap it in a template tag to provide a parent element and also to help\n        // deal with touchy tags like tr, tbody, etc.\n        let responseDoc = parser.parseFromString(\n          \"<body><template>\" + newContent + \"</template></body>\",\n          \"text/html\",\n        );\n        let content = /** @type {HTMLTemplateElement} */ (\n          responseDoc.body.querySelector(\"template\")\n        ).content;\n        generatedByIdiomorph.add(content);\n        return content;\n      }\n    }\n\n    return { normalizeElement, normalizeParent };\n  })();\n\n  //=============================================================================\n  // This is what ends up becoming the Idiomorph global object\n  //=============================================================================\n  return {\n    morph,\n    defaults,\n  };\n})();\n\nexport {Idiomorph};\n","\nconst topics: any = {}\nconst _async: any = {}\n\nexport const publish = (name, params) => {\n\n\t_async[name] = isObject(params)? Object.assign({}, _async[name], params): params\n\n\tif (topics[name]) {\n\t\ttopics[name].forEach(topic => topic(params))\n\t}\n}\n\nexport const subscribe = (name, method) => {\n\ttopics[name] = topics[name] || []\n\ttopics[name].push(method)\n\tif (name in _async) {\n\t\tmethod(_async[name])\n\t}\n\treturn () => {\n\t\ttopics[name] = topics[name].filter( fn => fn != method )\n\t}\n}\n\nconst isObject = (value) => {\n\treturn (typeof value === 'object' && value !== null && !Array.isArray(value))\n}\n","import { safe, g, dup } from './utils'\nimport { Idiomorph } from 'idiomorph/dist/idiomorph.esm'\nimport { publish, subscribe } from './utils/pubsub'\n\nexport const Component = ({ name, module, dependencies, node, templates, signal, register }) => {\n\n\tlet tick\n\tlet preserve\t\t= []\n\tlet observer \t\t= null\n\tlet observables \t= []\n\tlet effect \t\t\t= null\n\n\tconst _model \t\t= module.model || {}\n\tconst initialState \t= (new Function( `return ${node.getAttribute('html-model') || '{}'}`))()\n\tconst tplid \t\t= node.getAttribute('tplid')\n\tconst scopeid \t\t= node.getAttribute('html-scopeid')\n\tconst tpl \t\t\t= templates[ tplid ]\n\tconst scope \t\t= g.scope[ scopeid ]\n\tconst model  \t\t= dup(module?.model?.apply ? _model({ elm:node, initialState }) : _model)\n\tconst state \t\t= Object.assign({}, scope, model, initialState)\n\tconst view \t\t\t= module.view? module.view : (data) => data\n\n\tconst base = {\n\t\tname,\n\t\tmodel,\n\t\telm: node,\n\t\ttemplate: tpl.template,\n\t\tdependencies,\n\t\tpublish,\n\t\tsubscribe,\n\n\t\tmain(fn) {\n\t\t\tnode.addEventListener(':mount', fn)\n\t\t},\n\n\t\teffect(fn) {\n\t\t\tif( fn ) {\n\t\t\t\teffect = fn\n\t\t\t} else {\n\t\t\t\treturn effect\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @State\n\t\t */\n\t\tstate : {\n\n\t\t\tprotected( list ) {\n\t\t\t\tif( list ) {\n\t\t\t\t\tpreserve = list\n\t\t\t\t} else {\n\t\t\t\t\treturn preserve\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tsave(data) {\n\t\t\t\tif( data.constructor === Function ) {\n\t\t\t\t\tdata( state )\n\t\t\t\t} else {\n\t\t\t\t\tObject.assign(state, data)\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tset( data ) {\n\n\t\t\t\tif (!document.body.contains(node)) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif( data.constructor === Function ) {\n\t\t\t\t\tdata(state)\n\t\t\t\t} else {\n\t\t\t\t\tObject.assign(state, data)\n\t\t\t\t}\n\n\t\t\t\tconst newstate = Object.assign({}, state, scope)\n\n\t\t\t\treturn new Promise((resolve) => {\n\t\t\t\t\trender(newstate, () => resolve(newstate))\n\t\t\t\t})\n\t\t\t},\n\n\t\t\tget() {\n\t\t\t\treturn Object.assign({}, state)\n\t\t\t}\n\t\t},\n\n\t\tdataset( target, name ) {\n\n\t\t\tconst el = name? target : node\n\t\t\tconst key = name? name : target\n\t\t\tconst value = el.dataset[key]\n\n\t\t\tif (value === 'true') return true\n\t\t\tif (value === 'false') return false\n\t\t\tif (!isNaN(value) && value.trim() !== '') return Number(value)\n\n\t\t\ttry {\n\t\t\t\treturn new Function('return (' + value + ')')()\n\t\t\t} catch {}\n\n\t\t\ttry {\n\t\t\t\treturn JSON.parse(value)\n\t\t\t} catch {}\n\n\t\t\treturn value\n\t\t},\n\n\t\t/**\n\t\t * @Events\n\t\t */\n\t\ton( ev, selectorOrCallback, callback ) {\n\n\t\t\tconst attribute = ev.match(/\\[(.*)\\]/)\n\n\t\t\tif( attribute ) {\n\t\t\t\tobservables.push({\n\t\t\t\t\ttarget: callback? selectorOrCallback : null,\n\t\t\t\t\tcallback: callback || selectorOrCallback\n\t\t\t\t})\n\n\t\t\t\tif( !observer ) {\n\t\t\t\t\tobserver = new MutationObserver((mutationsList) => {\n\t\t\t\t\t\tfor (const mutation of mutationsList) {\n\t\t\t\t\t\t\tif (mutation.type === 'attributes') {\n\t\t\t\t\t\t\t\tconst attrname = mutation.attributeName\n\t\t\t\t\t\t\t\tif( attrname === attribute[1] ) {\n\t\t\t\t\t\t\t\t\tobservables.forEach( item => {\n\t\t\t\t\t\t\t\t\t\tconst target = item.target? node.querySelectorAll(item.target): [node]\n\t\t\t\t\t\t\t\t\t\ttarget.forEach( target => {\n\t\t\t\t\t\t\t\t\t\t\tif( target == mutation.target ) {\n\t\t\t\t\t\t\t\t\t\t\t\titem.callback({\n\t\t\t\t\t\t\t\t\t\t\t\t\ttarget: mutation.target,\n\t\t\t\t\t\t\t\t\t\t\t\t\tattribute: attrname,\n\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: mutation.target.getAttribute(attrname)\n\t\t\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\n\t\t\t\t\tobserver.observe(node, {\n\t\t\t\t\t\tattributes: true,\n\t\t\t\t\t\tsubtree: true\n\t\t\t\t\t})\n\n\t\t\t\t\tnode.addEventListener(':unmount', () => {\n\t\t\t\t\t\tobservables = []\n\t\t\t\t\t\tobserver.disconnect()\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif( callback ) {\n\t\t\t\tcallback.handler = (e) => {\n\t\t\t\t\tconst detail = e.detail || {}\n\t\t\t\t\tlet parent = e.target\n\t\t\t\t\twhile (parent) {\n\t\t\t\t\t\tif (parent.matches(selectorOrCallback)) {\n\t\t\t\t\t\t\te.delegateTarget = parent\n\t\t\t\t\t\t\tcallback.apply(node, [e].concat(detail.args))\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (parent === node) break\n\t\t\t\t\t\tparent = parent.parentNode\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnode.addEventListener(ev, callback.handler, {\n\t\t\t\t\tsignal,\n\t\t\t\t\tcapture: (ev == 'focus' || ev == 'blur' || ev == 'mouseenter' || ev == 'mouseleave')\n\t\t\t\t})\n\n\t\t\t} else {\n\t\t\t\tselectorOrCallback.handler = (e) => {\n\t\t\t\t\te.delegateTarget = node\n\t\t\t\t\tselectorOrCallback.apply(node, [e].concat(e.detail.args))\n\t\t\t\t}\n\t\t\t\tnode.addEventListener(ev, selectorOrCallback.handler, { signal })\n\t\t\t}\n\n\t\t},\n\n\t\toff( ev, callback ) {\n\t\t\tif( callback.handler ) {\n\t\t\t\tnode.removeEventListener(ev, callback.handler)\n\t\t\t}\n\t\t},\n\n\t\ttrigger(ev, selectorOrCallback, data) {\n\t\t\tif( selectorOrCallback.constructor === String ) {\n\t\t\t\tArray\n\t\t\t\t\t.from(node.querySelectorAll(selectorOrCallback))\n\t\t\t\t\t.forEach( children => {\n\t\t\t\t\t\tchildren.dispatchEvent(new CustomEvent(ev, { bubbles: true, detail: { args: data } }) )\n\t\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tnode.dispatchEvent(new CustomEvent(ev, { bubbles: true, detail:{ args: data } }))\n\t\t\t}\n\t\t},\n\n\t\temit(ev, data) {\n\t\t\tnode.dispatchEvent(new CustomEvent(ev, { bubbles: true, detail: { args: data } }))\n\t\t},\n\n\t\tunmount( fn ) {\n\t\t\tnode.addEventListener(':unmount', fn)\n\t\t},\n\n\t\tinnerHTML ( target, html_ ) {\n\t\t\tconst element = html_? target : node\n\t\t\tconst clone = element.cloneNode()\n\t\t\tconst html = html_? html_ : target\n\t\t\tclone.innerHTML = html\n\t\t\tIdiomorph.morph(element, clone)\n\t\t}\n\t}\n\n\tconst render = ( data, callback = (() => {}) ) => {\n\t\tclearTimeout( tick )\n\t\ttick = setTimeout(() => {\n\t\t\tconst html = tpl.render.call({...data, ...view(data)}, node, safe, g )\n\t\t\tIdiomorph.morph( node, html, IdiomorphOptions(node, register) )\n\t\t\tPromise.resolve().then(() => {\n\t\t\t\tnode.querySelectorAll('[tplid]')\n\t\t\t\t\t.forEach((element) => {\n\t\t\t\t\t\tconst child = register.get(element)\n\t\t\t\t\t\tif(!child) return\n\t\t\t\t\t\tchild.state.protected().forEach( key => delete data[key] )\n\t\t\t\t\t\tconst useEffect = child.effect()\n\t\t\t\t\t\tif( useEffect ) {\n\t\t\t\t\t\t\tconst promise = useEffect(data)\n\t\t\t\t\t\t\tif( promise && promise.then ) {\n\t\t\t\t\t\t\t\tpromise.then(() => child.state.set(data))\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tchild.state.set(data)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tchild.state.set(data)\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\tPromise.resolve().then(() => {\n\t\t\t\t\tg.scope = {}\n\t\t\t\t\tcallback()\n\t\t\t\t})\n\t\t\t})\n\t\t})\n\t}\n\n\trender( state )\n\tregister.set( node, base )\n\treturn module.default( base )\n}\n\nconst IdiomorphOptions = ( parent, register ) => ({\n\tcallbacks: {\n\t\tbeforeNodeMorphed( node ) {\n\t\t\tif( node.nodeType === 1 ) {\n\t\t\t\tif( 'html-static' in node.attributes ) {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\tif( register.get(node) && node !== parent ) {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n})\n","import { Component } from './component'\n\nconst register = new WeakMap()\n\nexport const Element = ({ component, templates, start }) => {\n\n\tconst { name, module, dependencies } = component\n\n\treturn class extends HTMLElement {\n\n\t\tconstructor() {\n\t\t\tsuper()\n\t\t}\n\n\t\tconnectedCallback() {\n\n\t\t\tthis.abortController = new AbortController()\n\n\t\t\tif( !this.getAttribute('tplid') ) {\n\t\t\t\tstart( this.parentNode )\n\t\t\t}\n\n\t\t\tconst rtrn = Component({\n\t\t\t\tnode:this,\n\t\t\t\tname,\n\t\t\t\tmodule,\n\t\t\t\tdependencies,\n\t\t\t\ttemplates,\n\t\t\t\tsignal: this.abortController.signal,\n\t\t\t\tregister\n\t\t\t})\n\n\t\t\tif ( rtrn && rtrn.constructor === Promise ) {\n\t\t\t\trtrn.then(() => {\n\t\t\t\t\tthis.dispatchEvent( new CustomEvent(':mount') )\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tthis.dispatchEvent( new CustomEvent(':mount') )\n\t\t\t}\n\t\t}\n\n\t\tdisconnectedCallback() {\n\t\t\tthis.dispatchEvent( new CustomEvent(':unmount') )\n\t\t\tthis.abortController.abort()\n\t\t}\n\t}\n}\n","import { uuid, decodeHTML } from './utils'\n\nconst config = {\n\ttags: ['{{', '}}']\n}\n\nconst templates  = {}\nconst booleanAttrs = /html-(allowfullscreen|async|autofocus|autoplay|checked|controls|default|defer|disabled|formnovalidate|inert|ismap|itemscope|loop|multiple|muted|nomodule|novalidate|open|playsinline|readonly|required|reversed|selected)=\"(.*?)\"/g\nconst htmlAttr = /html-([^\\s]*?)=\"(.*?)\"/g\nconst tagExpr = () => new RegExp(`\\\\${config.tags[0]}(.+?)\\\\${config.tags[1]}`, 'g')\n\nexport const templateConfig = (newconfig) => {\n\tObject.assign( config, newconfig )\n}\n\nexport const template = ( target, { components }) => {\n\n\ttagElements( target, [...Object.keys( components ), '[html-if]', 'template'], components )\n\tconst clone = target.cloneNode( true )\n\n\ttransformTemplate( clone )\n\tremoveTemplateTagsRecursively( clone )\n\tsetTemplates( clone, components )\n\n\treturn templates\n}\n\nexport const compile = ( html ) => {\n\n\tconst parsedHtml = JSON.stringify( html )\n\n\treturn new Function('$element', 'safe', '$g',`\n\t\tvar $data = this;\n\t\twith( $data ){\n\t\t\tvar output=${parsedHtml\n\t\t\t\t.replace(/%%_=(.+?)_%%/g, function(_, variable){\n\t\t\t\t\treturn '\"+safe(function(){return '+ decodeHTML(variable) +';})+\"'\n\t\t\t\t})\n\t\t\t\t.replace(/%%_(.+?)_%%/g, function(_, variable){\n\t\t\t\t\treturn '\";' + decodeHTML(variable) +'\\noutput+=\"'\n\t\t\t\t})};return output;\n\t\t}\n\t`)\n}\n\nconst tagElements = (target, keys, components) => {\n\tconst isComponent = key => key in components\n\tconst selector = keys.join(',')\n\n\ttarget.querySelectorAll(selector).forEach(node => {\n\t\tif (node.localName === 'template') {\n\t\t\ttagElements(node.content, keys, components)\n\t\t\treturn\n\t\t}\n\t\tif (node.hasAttribute('html-if') && !node.id) {\n\t\t\tnode.id = uuid()\n\t\t}\n\t\tif (isComponent(node.localName)) {\n\t\t\tnode.setAttribute('tplid', uuid())\n\t\t}\n\t})\n}\n\nconst transformAttributes = (html) => {\n\treturn html\n\t\t.replace(/jails___scope-id/g, '%%_=$scopeid_%%')\n\t\t.replace(tagExpr(), '%%_=$1_%%')\n\t\t.replace(booleanAttrs, `%%_if(safe(function(){ return $2 })){_%%$1%%_}_%%`)\n\t\t.replace(htmlAttr, (all, key, value) => {\n\t\t\tif (['key', 'model', 'scopeid'].includes(key)) return all\n\t\t\tif (value) {\n\t\t\t\tvalue = value.replace(/^{|}$/g, '')\n\t\t\t\treturn `${key}=\"%%_=safe(function(){ return ${value} })_%%\"`\n\t\t\t}\n\t\t\treturn all\n\t\t})\n}\n\nconst transformTemplate = ( clone ) => {\n\n\tclone.querySelectorAll('template, [html-for], [html-if], [html-inner], [html-class]')\n\t\t.forEach(( element ) => {\n\n\t\t\tconst htmlFor \t= element.getAttribute('html-for')\n\t\t\tconst htmlIf \t= element.getAttribute('html-if')\n\t\t\tconst htmlInner = element.getAttribute('html-inner')\n\t\t\tconst htmlClass = element.getAttribute('html-class')\n\n\t\t\tif ( htmlFor ) {\n\n\t\t\t\telement.removeAttribute('html-for')\n\n\t\t\t\tconst split \t = htmlFor.match(/(.*)\\sin\\s(.*)/) || ''\n\t\t\t\tconst varname \t = split[1]\n\t\t\t\tconst object \t = split[2]\n\t\t\t\tconst objectname = object.split(/\\./).shift()\n\t\t\t\tconst open \t\t = document.createTextNode(`%%_ ;(function(){ var $index = 0; for(var $key in safe(function(){ return ${object} }) ){ var $scopeid = Math.random().toString(36).substring(2, 9); var ${varname} = ${object}[$key]; $g.scope[$scopeid] = Object.assign({}, { ${objectname}: ${objectname} }, { ${varname} :${varname}, $index: $index, $key: $key }); _%%`)\n\t\t\t\tconst close \t = document.createTextNode(`%%_ $index++; } })() _%%`)\n\n\t\t\t\twrap(open, element, close)\n\t\t\t}\n\n\t\t\tif (htmlIf) {\n\t\t\t\telement.removeAttribute('html-if')\n\t\t\t\tconst open = document.createTextNode(`%%_ if ( safe(function(){ return ${htmlIf} }) ){ _%%`)\n\t\t\t\tconst close = document.createTextNode(`%%_ }  _%%`)\n\t\t\t\twrap(open, element, close)\n\t\t\t}\n\n\t\t\tif (htmlInner) {\n\t\t\t\telement.removeAttribute('html-inner')\n\t\t\t\telement.innerHTML = `%%_=${htmlInner}_%%`\n\t\t\t}\n\n\t\t\tif (htmlClass) {\n\t\t\t\telement.removeAttribute('html-class')\n\t\t\t\telement.className = (element.className + ` %%_=${htmlClass}_%%`).trim()\n\t\t\t}\n\n\t\t\tif( element.localName === 'template' ) {\n\t\t\t\ttransformTemplate(element.content)\n\t\t\t}\n\t\t})\n}\n\nconst setTemplates = ( clone, components ) => {\n\n\tArray.from(clone.querySelectorAll('[tplid]'))\n\t\t.reverse()\n\t\t.forEach((node) => {\n\n\t\t\tconst tplid = node.getAttribute('tplid')\n\t\t\tconst name  = node.localName\n\t\t\tnode.setAttribute('html-scopeid', 'jails___scope-id')\n\n\t\t\tif( name in components && components[name].module.template ) {\n\t\t\t\tconst children = node.innerHTML\n\t\t\t\tconst html = components[name].module.template({ elm:node, children })\n\t\t\t\tnode.innerHTML = html\n\t\t\t\ttransformTemplate(node)\n\t\t\t\tremoveTemplateTagsRecursively(node)\n\t\t\t}\n\n\t\t\tconst html = transformAttributes(node.outerHTML)\n\n\t\t\ttemplates[ tplid ] = {\n\t\t\t\ttemplate: html,\n\t\t\t\trender\t: compile(html)\n\t\t\t}\n\t\t})\n}\n\nconst removeTemplateTagsRecursively = (node) => {\n\n\t// Get all <template> elements within the node\n\tconst templates = node.querySelectorAll('template')\n\n\ttemplates.forEach((template) => {\n\n\t\tif( template.getAttribute('html-if') || template.getAttribute('html-inner') ) {\n\t\t\treturn\n\t\t}\n\n\t\t// Process any nested <template> tags within this <template> first\n\t\tremoveTemplateTagsRecursively(template.content)\n\n\t\t// Get the parent of the <template> tag\n\t\tconst parent = template.parentNode\n\n\t\tif (parent) {\n\t\t\t// Move all child nodes from the <template>'s content to its parent\n\t\t\tconst content = template.content\n\t\t\twhile (content.firstChild) {\n\t\t\t\tparent.insertBefore(content.firstChild, template)\n\t\t\t}\n\t\t\t// Remove the <template> tag itself\n\t\t\tparent.removeChild(template)\n\t\t}\n\t})\n}\n\n\nconst wrap = (open, node, close) => {\n\tnode.parentNode?.insertBefore(open, node)\n\tnode.parentNode?.insertBefore(close, node.nextSibling)\n}\n","\nimport { Element } from './element'\nimport { template, templateConfig as config } from './template-system'\n\nexport { publish, subscribe } from './utils/pubsub'\n\nexport const templateConfig = (options) => {\n\tconfig( options )\n}\n\nglobalThis.__jails__ = globalThis.__jails__ || { components: {} }\n\nexport const register = ( name, module, dependencies ) => {\n\tconst { components } = globalThis.__jails__\n\tcomponents[ name ] = { name, module, dependencies }\n}\n\nexport const start = ( target ) => {\n\n\t// If the code is running in a Node.js environment, do nothing\n\tif( typeof window === 'undefined' ) {\n\t\treturn;\n\t}\n\n\ttarget = target || document.body\n\tconst { components } = globalThis.__jails__\n\tconst templates = template( target, { components } )\n\n\tObject\n\t\t.values( components )\n\t\t.forEach(({ name, module, dependencies }) => {\n\t\t\tif( !customElements.get(name) ) {\n\t\t\t\tcustomElements.define( name, Element({ component: { name, module, dependencies }, templates, start }))\n\t\t\t}\n\t})\n}\n"],"names":["config","ctx","morphChildren","findBestMatch","morphNode","createMorphContext","normalizeElement","normalizeParent","templates","register","name","target","Element","start","templateConfig","html","template"],"mappings":"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","x_google_ignoreList":[1]}