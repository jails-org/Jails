{"version":3,"file":"index.js","sources":["../src/utils/index.ts","../src/utils/pubsub.ts","../node_modules/morphdom/dist/morphdom-esm.js","../src/component.ts","../src/element.ts","../src/template-system.ts","../src/index.ts"],"sourcesContent":["let textarea\n\nexport const g = {\n\tscope: {}\n}\n\nexport const decodeHTML = (text) => {\n\ttextarea = textarea || document.createElement('textarea')\n\ttextarea.innerHTML = text\n\treturn textarea.value\n}\n\nexport const rAF = (fn) => {\n\tif (requestAnimationFrame)\n\t\treturn requestAnimationFrame(fn)\n\telse\n\t\treturn setTimeout(fn, 1000 / 60)\n}\n\nexport const uuid = () => {\n\treturn Math.random().toString(36).substring(2, 9)\n}\n\nexport const dup = (o) => {\n\treturn JSON.parse(JSON.stringify(o))\n}\n\nexport const safe = (execute, val) => {\n\ttry{\n\t\tconst value = execute()\n\t\treturn value !== undefined && value !== null ? value : val || ''\n\t}catch(err){\n\t\treturn val || ''\n\t}\n}\n","\nconst topics: any = {}\nconst _async: any = {}\n\nexport const publish = (name, params) => {\n\n\t_async[name] = isObject(params)? Object.assign({}, _async[name], params): params\n\n\tif (topics[name]) {\n\t\ttopics[name].forEach(topic => topic(params))\n\t}\n}\n\nexport const subscribe = (name, method) => {\n\ttopics[name] = topics[name] || []\n\ttopics[name].push(method)\n\tif (name in _async) {\n\t\tmethod(_async[name])\n\t}\n\treturn () => {\n\t\ttopics[name] = topics[name].filter( fn => fn != method )\n\t}\n}\n\nconst isObject = (value) => {\n\treturn (typeof value === 'object' && value !== null && !Array.isArray(value))\n}\n","var DOCUMENT_FRAGMENT_NODE = 11;\n\nfunction morphAttrs(fromNode, toNode) {\n    var toNodeAttrs = toNode.attributes;\n    var attr;\n    var attrName;\n    var attrNamespaceURI;\n    var attrValue;\n    var fromValue;\n\n    // document-fragments dont have attributes so lets not do anything\n    if (toNode.nodeType === DOCUMENT_FRAGMENT_NODE || fromNode.nodeType === DOCUMENT_FRAGMENT_NODE) {\n      return;\n    }\n\n    // update attributes on original DOM element\n    for (var i = toNodeAttrs.length - 1; i >= 0; i--) {\n        attr = toNodeAttrs[i];\n        attrName = attr.name;\n        attrNamespaceURI = attr.namespaceURI;\n        attrValue = attr.value;\n\n        if (attrNamespaceURI) {\n            attrName = attr.localName || attrName;\n            fromValue = fromNode.getAttributeNS(attrNamespaceURI, attrName);\n\n            if (fromValue !== attrValue) {\n                if (attr.prefix === 'xmlns'){\n                    attrName = attr.name; // It's not allowed to set an attribute with the XMLNS namespace without specifying the `xmlns` prefix\n                }\n                fromNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);\n            }\n        } else {\n            fromValue = fromNode.getAttribute(attrName);\n\n            if (fromValue !== attrValue) {\n                fromNode.setAttribute(attrName, attrValue);\n            }\n        }\n    }\n\n    // Remove any extra attributes found on the original DOM element that\n    // weren't found on the target element.\n    var fromNodeAttrs = fromNode.attributes;\n\n    for (var d = fromNodeAttrs.length - 1; d >= 0; d--) {\n        attr = fromNodeAttrs[d];\n        attrName = attr.name;\n        attrNamespaceURI = attr.namespaceURI;\n\n        if (attrNamespaceURI) {\n            attrName = attr.localName || attrName;\n\n            if (!toNode.hasAttributeNS(attrNamespaceURI, attrName)) {\n                fromNode.removeAttributeNS(attrNamespaceURI, attrName);\n            }\n        } else {\n            if (!toNode.hasAttribute(attrName)) {\n                fromNode.removeAttribute(attrName);\n            }\n        }\n    }\n}\n\nvar range; // Create a range object for efficently rendering strings to elements.\nvar NS_XHTML = 'http://www.w3.org/1999/xhtml';\n\nvar doc = typeof document === 'undefined' ? undefined : document;\nvar HAS_TEMPLATE_SUPPORT = !!doc && 'content' in doc.createElement('template');\nvar HAS_RANGE_SUPPORT = !!doc && doc.createRange && 'createContextualFragment' in doc.createRange();\n\nfunction createFragmentFromTemplate(str) {\n    var template = doc.createElement('template');\n    template.innerHTML = str;\n    return template.content.childNodes[0];\n}\n\nfunction createFragmentFromRange(str) {\n    if (!range) {\n        range = doc.createRange();\n        range.selectNode(doc.body);\n    }\n\n    var fragment = range.createContextualFragment(str);\n    return fragment.childNodes[0];\n}\n\nfunction createFragmentFromWrap(str) {\n    var fragment = doc.createElement('body');\n    fragment.innerHTML = str;\n    return fragment.childNodes[0];\n}\n\n/**\n * This is about the same\n * var html = new DOMParser().parseFromString(str, 'text/html');\n * return html.body.firstChild;\n *\n * @method toElement\n * @param {String} str\n */\nfunction toElement(str) {\n    str = str.trim();\n    if (HAS_TEMPLATE_SUPPORT) {\n      // avoid restrictions on content for things like `<tr><th>Hi</th></tr>` which\n      // createContextualFragment doesn't support\n      // <template> support not available in IE\n      return createFragmentFromTemplate(str);\n    } else if (HAS_RANGE_SUPPORT) {\n      return createFragmentFromRange(str);\n    }\n\n    return createFragmentFromWrap(str);\n}\n\n/**\n * Returns true if two node's names are the same.\n *\n * NOTE: We don't bother checking `namespaceURI` because you will never find two HTML elements with the same\n *       nodeName and different namespace URIs.\n *\n * @param {Element} a\n * @param {Element} b The target element\n * @return {boolean}\n */\nfunction compareNodeNames(fromEl, toEl) {\n    var fromNodeName = fromEl.nodeName;\n    var toNodeName = toEl.nodeName;\n    var fromCodeStart, toCodeStart;\n\n    if (fromNodeName === toNodeName) {\n        return true;\n    }\n\n    fromCodeStart = fromNodeName.charCodeAt(0);\n    toCodeStart = toNodeName.charCodeAt(0);\n\n    // If the target element is a virtual DOM node or SVG node then we may\n    // need to normalize the tag name before comparing. Normal HTML elements that are\n    // in the \"http://www.w3.org/1999/xhtml\"\n    // are converted to upper case\n    if (fromCodeStart <= 90 && toCodeStart >= 97) { // from is upper and to is lower\n        return fromNodeName === toNodeName.toUpperCase();\n    } else if (toCodeStart <= 90 && fromCodeStart >= 97) { // to is upper and from is lower\n        return toNodeName === fromNodeName.toUpperCase();\n    } else {\n        return false;\n    }\n}\n\n/**\n * Create an element, optionally with a known namespace URI.\n *\n * @param {string} name the element name, e.g. 'div' or 'svg'\n * @param {string} [namespaceURI] the element's namespace URI, i.e. the value of\n * its `xmlns` attribute or its inferred namespace.\n *\n * @return {Element}\n */\nfunction createElementNS(name, namespaceURI) {\n    return !namespaceURI || namespaceURI === NS_XHTML ?\n        doc.createElement(name) :\n        doc.createElementNS(namespaceURI, name);\n}\n\n/**\n * Copies the children of one DOM element to another DOM element\n */\nfunction moveChildren(fromEl, toEl) {\n    var curChild = fromEl.firstChild;\n    while (curChild) {\n        var nextChild = curChild.nextSibling;\n        toEl.appendChild(curChild);\n        curChild = nextChild;\n    }\n    return toEl;\n}\n\nfunction syncBooleanAttrProp(fromEl, toEl, name) {\n    if (fromEl[name] !== toEl[name]) {\n        fromEl[name] = toEl[name];\n        if (fromEl[name]) {\n            fromEl.setAttribute(name, '');\n        } else {\n            fromEl.removeAttribute(name);\n        }\n    }\n}\n\nvar specialElHandlers = {\n    OPTION: function(fromEl, toEl) {\n        var parentNode = fromEl.parentNode;\n        if (parentNode) {\n            var parentName = parentNode.nodeName.toUpperCase();\n            if (parentName === 'OPTGROUP') {\n                parentNode = parentNode.parentNode;\n                parentName = parentNode && parentNode.nodeName.toUpperCase();\n            }\n            if (parentName === 'SELECT' && !parentNode.hasAttribute('multiple')) {\n                if (fromEl.hasAttribute('selected') && !toEl.selected) {\n                    // Workaround for MS Edge bug where the 'selected' attribute can only be\n                    // removed if set to a non-empty value:\n                    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12087679/\n                    fromEl.setAttribute('selected', 'selected');\n                    fromEl.removeAttribute('selected');\n                }\n                // We have to reset select element's selectedIndex to -1, otherwise setting\n                // fromEl.selected using the syncBooleanAttrProp below has no effect.\n                // The correct selectedIndex will be set in the SELECT special handler below.\n                parentNode.selectedIndex = -1;\n            }\n        }\n        syncBooleanAttrProp(fromEl, toEl, 'selected');\n    },\n    /**\n     * The \"value\" attribute is special for the <input> element since it sets\n     * the initial value. Changing the \"value\" attribute without changing the\n     * \"value\" property will have no effect since it is only used to the set the\n     * initial value.  Similar for the \"checked\" attribute, and \"disabled\".\n     */\n    INPUT: function(fromEl, toEl) {\n        syncBooleanAttrProp(fromEl, toEl, 'checked');\n        syncBooleanAttrProp(fromEl, toEl, 'disabled');\n\n        if (fromEl.value !== toEl.value) {\n            fromEl.value = toEl.value;\n        }\n\n        if (!toEl.hasAttribute('value')) {\n            fromEl.removeAttribute('value');\n        }\n    },\n\n    TEXTAREA: function(fromEl, toEl) {\n        var newValue = toEl.value;\n        if (fromEl.value !== newValue) {\n            fromEl.value = newValue;\n        }\n\n        var firstChild = fromEl.firstChild;\n        if (firstChild) {\n            // Needed for IE. Apparently IE sets the placeholder as the\n            // node value and vise versa. This ignores an empty update.\n            var oldValue = firstChild.nodeValue;\n\n            if (oldValue == newValue || (!newValue && oldValue == fromEl.placeholder)) {\n                return;\n            }\n\n            firstChild.nodeValue = newValue;\n        }\n    },\n    SELECT: function(fromEl, toEl) {\n        if (!toEl.hasAttribute('multiple')) {\n            var selectedIndex = -1;\n            var i = 0;\n            // We have to loop through children of fromEl, not toEl since nodes can be moved\n            // from toEl to fromEl directly when morphing.\n            // At the time this special handler is invoked, all children have already been morphed\n            // and appended to / removed from fromEl, so using fromEl here is safe and correct.\n            var curChild = fromEl.firstChild;\n            var optgroup;\n            var nodeName;\n            while(curChild) {\n                nodeName = curChild.nodeName && curChild.nodeName.toUpperCase();\n                if (nodeName === 'OPTGROUP') {\n                    optgroup = curChild;\n                    curChild = optgroup.firstChild;\n                    // handle empty optgroups\n                    if (!curChild) {\n                        curChild = optgroup.nextSibling;\n                        optgroup = null;\n                    }\n                } else {\n                    if (nodeName === 'OPTION') {\n                        if (curChild.hasAttribute('selected')) {\n                            selectedIndex = i;\n                            break;\n                        }\n                        i++;\n                    }\n                    curChild = curChild.nextSibling;\n                    if (!curChild && optgroup) {\n                        curChild = optgroup.nextSibling;\n                        optgroup = null;\n                    }\n                }\n            }\n\n            fromEl.selectedIndex = selectedIndex;\n        }\n    }\n};\n\nvar ELEMENT_NODE = 1;\nvar DOCUMENT_FRAGMENT_NODE$1 = 11;\nvar TEXT_NODE = 3;\nvar COMMENT_NODE = 8;\n\nfunction noop() {}\n\nfunction defaultGetNodeKey(node) {\n  if (node) {\n    return (node.getAttribute && node.getAttribute('id')) || node.id;\n  }\n}\n\nfunction morphdomFactory(morphAttrs) {\n\n  return function morphdom(fromNode, toNode, options) {\n    if (!options) {\n      options = {};\n    }\n\n    if (typeof toNode === 'string') {\n      if (fromNode.nodeName === '#document' || fromNode.nodeName === 'HTML' || fromNode.nodeName === 'BODY') {\n        var toNodeHtml = toNode;\n        toNode = doc.createElement('html');\n        toNode.innerHTML = toNodeHtml;\n      } else {\n        toNode = toElement(toNode);\n      }\n    } else if (toNode.nodeType === DOCUMENT_FRAGMENT_NODE$1) {\n      toNode = toNode.firstElementChild;\n    }\n\n    var getNodeKey = options.getNodeKey || defaultGetNodeKey;\n    var onBeforeNodeAdded = options.onBeforeNodeAdded || noop;\n    var onNodeAdded = options.onNodeAdded || noop;\n    var onBeforeElUpdated = options.onBeforeElUpdated || noop;\n    var onElUpdated = options.onElUpdated || noop;\n    var onBeforeNodeDiscarded = options.onBeforeNodeDiscarded || noop;\n    var onNodeDiscarded = options.onNodeDiscarded || noop;\n    var onBeforeElChildrenUpdated = options.onBeforeElChildrenUpdated || noop;\n    var skipFromChildren = options.skipFromChildren || noop;\n    var addChild = options.addChild || function(parent, child){ return parent.appendChild(child); };\n    var childrenOnly = options.childrenOnly === true;\n\n    // This object is used as a lookup to quickly find all keyed elements in the original DOM tree.\n    var fromNodesLookup = Object.create(null);\n    var keyedRemovalList = [];\n\n    function addKeyedRemoval(key) {\n      keyedRemovalList.push(key);\n    }\n\n    function walkDiscardedChildNodes(node, skipKeyedNodes) {\n      if (node.nodeType === ELEMENT_NODE) {\n        var curChild = node.firstChild;\n        while (curChild) {\n\n          var key = undefined;\n\n          if (skipKeyedNodes && (key = getNodeKey(curChild))) {\n            // If we are skipping keyed nodes then we add the key\n            // to a list so that it can be handled at the very end.\n            addKeyedRemoval(key);\n          } else {\n            // Only report the node as discarded if it is not keyed. We do this because\n            // at the end we loop through all keyed elements that were unmatched\n            // and then discard them in one final pass.\n            onNodeDiscarded(curChild);\n            if (curChild.firstChild) {\n              walkDiscardedChildNodes(curChild, skipKeyedNodes);\n            }\n          }\n\n          curChild = curChild.nextSibling;\n        }\n      }\n    }\n\n    /**\n    * Removes a DOM node out of the original DOM\n    *\n    * @param  {Node} node The node to remove\n    * @param  {Node} parentNode The nodes parent\n    * @param  {Boolean} skipKeyedNodes If true then elements with keys will be skipped and not discarded.\n    * @return {undefined}\n    */\n    function removeNode(node, parentNode, skipKeyedNodes) {\n      if (onBeforeNodeDiscarded(node) === false) {\n        return;\n      }\n\n      if (parentNode) {\n        parentNode.removeChild(node);\n      }\n\n      onNodeDiscarded(node);\n      walkDiscardedChildNodes(node, skipKeyedNodes);\n    }\n\n    // // TreeWalker implementation is no faster, but keeping this around in case this changes in the future\n    // function indexTree(root) {\n    //     var treeWalker = document.createTreeWalker(\n    //         root,\n    //         NodeFilter.SHOW_ELEMENT);\n    //\n    //     var el;\n    //     while((el = treeWalker.nextNode())) {\n    //         var key = getNodeKey(el);\n    //         if (key) {\n    //             fromNodesLookup[key] = el;\n    //         }\n    //     }\n    // }\n\n    // // NodeIterator implementation is no faster, but keeping this around in case this changes in the future\n    //\n    // function indexTree(node) {\n    //     var nodeIterator = document.createNodeIterator(node, NodeFilter.SHOW_ELEMENT);\n    //     var el;\n    //     while((el = nodeIterator.nextNode())) {\n    //         var key = getNodeKey(el);\n    //         if (key) {\n    //             fromNodesLookup[key] = el;\n    //         }\n    //     }\n    // }\n\n    function indexTree(node) {\n      if (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE$1) {\n        var curChild = node.firstChild;\n        while (curChild) {\n          var key = getNodeKey(curChild);\n          if (key) {\n            fromNodesLookup[key] = curChild;\n          }\n\n          // Walk recursively\n          indexTree(curChild);\n\n          curChild = curChild.nextSibling;\n        }\n      }\n    }\n\n    indexTree(fromNode);\n\n    function handleNodeAdded(el) {\n      onNodeAdded(el);\n\n      var curChild = el.firstChild;\n      while (curChild) {\n        var nextSibling = curChild.nextSibling;\n\n        var key = getNodeKey(curChild);\n        if (key) {\n          var unmatchedFromEl = fromNodesLookup[key];\n          // if we find a duplicate #id node in cache, replace `el` with cache value\n          // and morph it to the child node.\n          if (unmatchedFromEl && compareNodeNames(curChild, unmatchedFromEl)) {\n            curChild.parentNode.replaceChild(unmatchedFromEl, curChild);\n            morphEl(unmatchedFromEl, curChild);\n          } else {\n            handleNodeAdded(curChild);\n          }\n        } else {\n          // recursively call for curChild and it's children to see if we find something in\n          // fromNodesLookup\n          handleNodeAdded(curChild);\n        }\n\n        curChild = nextSibling;\n      }\n    }\n\n    function cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey) {\n      // We have processed all of the \"to nodes\". If curFromNodeChild is\n      // non-null then we still have some from nodes left over that need\n      // to be removed\n      while (curFromNodeChild) {\n        var fromNextSibling = curFromNodeChild.nextSibling;\n        if ((curFromNodeKey = getNodeKey(curFromNodeChild))) {\n          // Since the node is keyed it might be matched up later so we defer\n          // the actual removal to later\n          addKeyedRemoval(curFromNodeKey);\n        } else {\n          // NOTE: we skip nested keyed nodes from being removed since there is\n          //       still a chance they will be matched up later\n          removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n        }\n        curFromNodeChild = fromNextSibling;\n      }\n    }\n\n    function morphEl(fromEl, toEl, childrenOnly) {\n      var toElKey = getNodeKey(toEl);\n\n      if (toElKey) {\n        // If an element with an ID is being morphed then it will be in the final\n        // DOM so clear it out of the saved elements collection\n        delete fromNodesLookup[toElKey];\n      }\n\n      if (!childrenOnly) {\n        // optional\n        var beforeUpdateResult = onBeforeElUpdated(fromEl, toEl);\n        if (beforeUpdateResult === false) {\n          return;\n        } else if (beforeUpdateResult instanceof HTMLElement) {\n          fromEl = beforeUpdateResult;\n          // reindex the new fromEl in case it's not in the same\n          // tree as the original fromEl\n          // (Phoenix LiveView sometimes returns a cloned tree,\n          //  but keyed lookups would still point to the original tree)\n          indexTree(fromEl);\n        }\n\n        // update attributes on original DOM element first\n        morphAttrs(fromEl, toEl);\n        // optional\n        onElUpdated(fromEl);\n\n        if (onBeforeElChildrenUpdated(fromEl, toEl) === false) {\n          return;\n        }\n      }\n\n      if (fromEl.nodeName !== 'TEXTAREA') {\n        morphChildren(fromEl, toEl);\n      } else {\n        specialElHandlers.TEXTAREA(fromEl, toEl);\n      }\n    }\n\n    function morphChildren(fromEl, toEl) {\n      var skipFrom = skipFromChildren(fromEl, toEl);\n      var curToNodeChild = toEl.firstChild;\n      var curFromNodeChild = fromEl.firstChild;\n      var curToNodeKey;\n      var curFromNodeKey;\n\n      var fromNextSibling;\n      var toNextSibling;\n      var matchingFromEl;\n\n      // walk the children\n      outer: while (curToNodeChild) {\n        toNextSibling = curToNodeChild.nextSibling;\n        curToNodeKey = getNodeKey(curToNodeChild);\n\n        // walk the fromNode children all the way through\n        while (!skipFrom && curFromNodeChild) {\n          fromNextSibling = curFromNodeChild.nextSibling;\n\n          if (curToNodeChild.isSameNode && curToNodeChild.isSameNode(curFromNodeChild)) {\n            curToNodeChild = toNextSibling;\n            curFromNodeChild = fromNextSibling;\n            continue outer;\n          }\n\n          curFromNodeKey = getNodeKey(curFromNodeChild);\n\n          var curFromNodeType = curFromNodeChild.nodeType;\n\n          // this means if the curFromNodeChild doesnt have a match with the curToNodeChild\n          var isCompatible = undefined;\n\n          if (curFromNodeType === curToNodeChild.nodeType) {\n            if (curFromNodeType === ELEMENT_NODE) {\n              // Both nodes being compared are Element nodes\n\n              if (curToNodeKey) {\n                // The target node has a key so we want to match it up with the correct element\n                // in the original DOM tree\n                if (curToNodeKey !== curFromNodeKey) {\n                  // The current element in the original DOM tree does not have a matching key so\n                  // let's check our lookup to see if there is a matching element in the original\n                  // DOM tree\n                  if ((matchingFromEl = fromNodesLookup[curToNodeKey])) {\n                    if (fromNextSibling === matchingFromEl) {\n                      // Special case for single element removals. To avoid removing the original\n                      // DOM node out of the tree (since that can break CSS transitions, etc.),\n                      // we will instead discard the current node and wait until the next\n                      // iteration to properly match up the keyed target element with its matching\n                      // element in the original tree\n                      isCompatible = false;\n                    } else {\n                      // We found a matching keyed element somewhere in the original DOM tree.\n                      // Let's move the original DOM node into the current position and morph\n                      // it.\n\n                      // NOTE: We use insertBefore instead of replaceChild because we want to go through\n                      // the `removeNode()` function for the node that is being discarded so that\n                      // all lifecycle hooks are correctly invoked\n                      fromEl.insertBefore(matchingFromEl, curFromNodeChild);\n\n                      // fromNextSibling = curFromNodeChild.nextSibling;\n\n                      if (curFromNodeKey) {\n                        // Since the node is keyed it might be matched up later so we defer\n                        // the actual removal to later\n                        addKeyedRemoval(curFromNodeKey);\n                      } else {\n                        // NOTE: we skip nested keyed nodes from being removed since there is\n                        //       still a chance they will be matched up later\n                        removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n                      }\n\n                      curFromNodeChild = matchingFromEl;\n                      curFromNodeKey = getNodeKey(curFromNodeChild);\n                    }\n                  } else {\n                    // The nodes are not compatible since the \"to\" node has a key and there\n                    // is no matching keyed node in the source tree\n                    isCompatible = false;\n                  }\n                }\n              } else if (curFromNodeKey) {\n                // The original has a key\n                isCompatible = false;\n              }\n\n              isCompatible = isCompatible !== false && compareNodeNames(curFromNodeChild, curToNodeChild);\n              if (isCompatible) {\n                // We found compatible DOM elements so transform\n                // the current \"from\" node to match the current\n                // target DOM node.\n                // MORPH\n                morphEl(curFromNodeChild, curToNodeChild);\n              }\n\n            } else if (curFromNodeType === TEXT_NODE || curFromNodeType == COMMENT_NODE) {\n              // Both nodes being compared are Text or Comment nodes\n              isCompatible = true;\n              // Simply update nodeValue on the original node to\n              // change the text value\n              if (curFromNodeChild.nodeValue !== curToNodeChild.nodeValue) {\n                curFromNodeChild.nodeValue = curToNodeChild.nodeValue;\n              }\n\n            }\n          }\n\n          if (isCompatible) {\n            // Advance both the \"to\" child and the \"from\" child since we found a match\n            // Nothing else to do as we already recursively called morphChildren above\n            curToNodeChild = toNextSibling;\n            curFromNodeChild = fromNextSibling;\n            continue outer;\n          }\n\n          // No compatible match so remove the old node from the DOM and continue trying to find a\n          // match in the original DOM. However, we only do this if the from node is not keyed\n          // since it is possible that a keyed node might match up with a node somewhere else in the\n          // target tree and we don't want to discard it just yet since it still might find a\n          // home in the final DOM tree. After everything is done we will remove any keyed nodes\n          // that didn't find a home\n          if (curFromNodeKey) {\n            // Since the node is keyed it might be matched up later so we defer\n            // the actual removal to later\n            addKeyedRemoval(curFromNodeKey);\n          } else {\n            // NOTE: we skip nested keyed nodes from being removed since there is\n            //       still a chance they will be matched up later\n            removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n          }\n\n          curFromNodeChild = fromNextSibling;\n        } // END: while(curFromNodeChild) {}\n\n        // If we got this far then we did not find a candidate match for\n        // our \"to node\" and we exhausted all of the children \"from\"\n        // nodes. Therefore, we will just append the current \"to\" node\n        // to the end\n        if (curToNodeKey && (matchingFromEl = fromNodesLookup[curToNodeKey]) && compareNodeNames(matchingFromEl, curToNodeChild)) {\n          // MORPH\n          if(!skipFrom){ addChild(fromEl, matchingFromEl); }\n          morphEl(matchingFromEl, curToNodeChild);\n        } else {\n          var onBeforeNodeAddedResult = onBeforeNodeAdded(curToNodeChild);\n          if (onBeforeNodeAddedResult !== false) {\n            if (onBeforeNodeAddedResult) {\n              curToNodeChild = onBeforeNodeAddedResult;\n            }\n\n            if (curToNodeChild.actualize) {\n              curToNodeChild = curToNodeChild.actualize(fromEl.ownerDocument || doc);\n            }\n            addChild(fromEl, curToNodeChild);\n            handleNodeAdded(curToNodeChild);\n          }\n        }\n\n        curToNodeChild = toNextSibling;\n        curFromNodeChild = fromNextSibling;\n      }\n\n      cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey);\n\n      var specialElHandler = specialElHandlers[fromEl.nodeName];\n      if (specialElHandler) {\n        specialElHandler(fromEl, toEl);\n      }\n    } // END: morphChildren(...)\n\n    var morphedNode = fromNode;\n    var morphedNodeType = morphedNode.nodeType;\n    var toNodeType = toNode.nodeType;\n\n    if (!childrenOnly) {\n      // Handle the case where we are given two DOM nodes that are not\n      // compatible (e.g. <div> --> <span> or <div> --> TEXT)\n      if (morphedNodeType === ELEMENT_NODE) {\n        if (toNodeType === ELEMENT_NODE) {\n          if (!compareNodeNames(fromNode, toNode)) {\n            onNodeDiscarded(fromNode);\n            morphedNode = moveChildren(fromNode, createElementNS(toNode.nodeName, toNode.namespaceURI));\n          }\n        } else {\n          // Going from an element node to a text node\n          morphedNode = toNode;\n        }\n      } else if (morphedNodeType === TEXT_NODE || morphedNodeType === COMMENT_NODE) { // Text or comment node\n        if (toNodeType === morphedNodeType) {\n          if (morphedNode.nodeValue !== toNode.nodeValue) {\n            morphedNode.nodeValue = toNode.nodeValue;\n          }\n\n          return morphedNode;\n        } else {\n          // Text node to something else\n          morphedNode = toNode;\n        }\n      }\n    }\n\n    if (morphedNode === toNode) {\n      // The \"to node\" was not compatible with the \"from node\" so we had to\n      // toss out the \"from node\" and use the \"to node\"\n      onNodeDiscarded(fromNode);\n    } else {\n      if (toNode.isSameNode && toNode.isSameNode(morphedNode)) {\n        return;\n      }\n\n      morphEl(morphedNode, toNode, childrenOnly);\n\n      // We now need to loop over any keyed nodes that might need to be\n      // removed. We only do the removal if we know that the keyed node\n      // never found a match. When a keyed node is matched up we remove\n      // it out of fromNodesLookup and we use fromNodesLookup to determine\n      // if a keyed node has been matched up or not\n      if (keyedRemovalList) {\n        for (var i=0, len=keyedRemovalList.length; i<len; i++) {\n          var elToRemove = fromNodesLookup[keyedRemovalList[i]];\n          if (elToRemove) {\n            removeNode(elToRemove, elToRemove.parentNode, false);\n          }\n        }\n      }\n    }\n\n    if (!childrenOnly && morphedNode !== fromNode && fromNode.parentNode) {\n      if (morphedNode.actualize) {\n        morphedNode = morphedNode.actualize(fromNode.ownerDocument || doc);\n      }\n      // If we had to swap out the from node with a new node because the old\n      // node was not compatible with the target node then we need to\n      // replace the old DOM node in the original DOM tree. This is only\n      // possible if the original DOM node was part of a DOM tree which\n      // we know is the case if it has a parent node.\n      fromNode.parentNode.replaceChild(morphedNode, fromNode);\n    }\n\n    return morphedNode;\n  };\n}\n\nvar morphdom = morphdomFactory(morphAttrs);\n\nexport default morphdom;\n","import { safe, g, dup } from './utils'\nimport { publish, subscribe } from './utils/pubsub'\nimport morphdom from 'morphdom'\n\nexport const Component = ({ name, module, dependencies, node, templates, signal, register }) => {\n\n\tlet tick\n\tlet preserve\t\t= []\n\tlet observer \t\t= null\n\tlet observables \t= []\n\n\tconst _model \t\t= module.model || {}\n\tconst initialState \t= (new Function( `return ${node.getAttribute('html-model') || '{}'}`))()\n\tconst tplid \t\t= node.getAttribute('tplid')\n\tconst scopeid \t\t= node.getAttribute('html-scopeid')\n\tconst tpl \t\t\t= templates[ tplid ]\n\tconst scope \t\t= g.scope[ scopeid ]\n\tconst model  \t\t= dup(module?.model?.apply ? _model({ elm:node, initialState }) : _model)\n\tconst state \t\t= Object.assign({}, scope, model, initialState)\n\tconst view \t\t\t= module.view? module.view : (data) => data\n\n\tconst base = {\n\t\tname,\n\t\tmodel,\n\t\telm: node,\n\t\ttemplate: tpl.template,\n\t\tdependencies,\n\t\tpublish,\n\t\tsubscribe,\n\n\t\tmain(fn) {\n\t\t\tnode.addEventListener(':mount', fn)\n\t\t},\n\n\t\t/**\n\t\t * @State\n\t\t */\n\t\tstate : {\n\n\t\t\tprotected( list ) {\n\t\t\t\tif( list ) {\n\t\t\t\t\tpreserve = list\n\t\t\t\t} else {\n\t\t\t\t\treturn preserve\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tsave(data) {\n\t\t\t\tif( data.constructor === Function ) {\n\t\t\t\t\tdata( state )\n\t\t\t\t} else {\n\t\t\t\t\tObject.assign(state, data)\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tset( data ) {\n\n\t\t\t\tif (!document.body.contains(node)) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif( data.constructor === Function ) {\n\t\t\t\t\tdata(state)\n\t\t\t\t} else {\n\t\t\t\t\tObject.assign(state, data)\n\t\t\t\t}\n\n\t\t\t\tconst newstate = Object.assign({}, state, scope)\n\n\t\t\t\treturn new Promise((resolve) => {\n\t\t\t\t\trender(newstate, () => resolve(newstate))\n\t\t\t\t})\n\t\t\t},\n\n\t\t\tget() {\n\t\t\t\treturn Object.assign({}, state)\n\t\t\t}\n\t\t},\n\n\t\tdataset( target, name ) {\n\n\t\t\tconst el = name? target : node\n\t\t\tconst key = name? name : target\n\t\t\tconst value = el.dataset[key]\n\n\t\t\tif (value === 'true') return true\n\t\t\tif (value === 'false') return false\n\t\t\tif (!isNaN(value) && value.trim() !== '') return Number(value)\n\n\t\t\ttry {\n\t\t\t\treturn new Function('return (' + value + ')')()\n\t\t\t} catch {}\n\n\t\t\ttry {\n\t\t\t\treturn JSON.parse(value)\n\t\t\t} catch {}\n\n\t\t\treturn value\n\t\t},\n\n\t\t/**\n\t\t * @Events\n\t\t */\n\t\ton( ev, selectorOrCallback, callback ) {\n\n\t\t\tconst attribute = ev.match(/\\[(.*)\\]/)\n\n\t\t\tif( attribute ) {\n\t\t\t\tobservables.push({\n\t\t\t\t\ttarget: callback? selectorOrCallback : null,\n\t\t\t\t\tcallback: callback || selectorOrCallback\n\t\t\t\t})\n\n\t\t\t\tif( !observer ) {\n\t\t\t\t\tobserver = new MutationObserver((mutationsList) => {\n\t\t\t\t\t\tfor (const mutation of mutationsList) {\n\t\t\t\t\t\t\tif (mutation.type === 'attributes') {\n\t\t\t\t\t\t\t\tconst attrname = mutation.attributeName\n\t\t\t\t\t\t\t\tif( attrname === attribute[1] ) {\n\t\t\t\t\t\t\t\t\tobservables.forEach( item => {\n\t\t\t\t\t\t\t\t\t\tconst target = item.target? node.querySelectorAll(item.target): [node]\n\t\t\t\t\t\t\t\t\t\ttarget.forEach( target => {\n\t\t\t\t\t\t\t\t\t\t\tif( target == mutation.target ) {\n\t\t\t\t\t\t\t\t\t\t\t\titem.callback({\n\t\t\t\t\t\t\t\t\t\t\t\t\ttarget: mutation.target,\n\t\t\t\t\t\t\t\t\t\t\t\t\tattribute: attrname,\n\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: mutation.target.getAttribute(attrname)\n\t\t\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\n\t\t\t\t\tobserver.observe(node, {\n\t\t\t\t\t\tattributes: true,\n\t\t\t\t\t\tsubtree: true\n\t\t\t\t\t})\n\n\t\t\t\t\tnode.addEventListener(':unmount', () => {\n\t\t\t\t\t\tobservables = []\n\t\t\t\t\t\tobserver.disconnect()\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif( callback ) {\n\t\t\t\tcallback.handler = (e) => {\n\t\t\t\t\tconst detail = e.detail || {}\n\t\t\t\t\tlet parent = e.target\n\t\t\t\t\twhile (parent) {\n\t\t\t\t\t\tif (parent.matches(selectorOrCallback)) {\n\t\t\t\t\t\t\te.delegateTarget = parent\n\t\t\t\t\t\t\tcallback.apply(node, [e].concat(detail.args))\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (parent === node) break\n\t\t\t\t\t\tparent = parent.parentNode\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnode.addEventListener(ev, callback.handler, {\n\t\t\t\t\tsignal,\n\t\t\t\t\tcapture: (ev == 'focus' || ev == 'blur' || ev == 'mouseenter' || ev == 'mouseleave')\n\t\t\t\t})\n\n\t\t\t} else {\n\t\t\t\tselectorOrCallback.handler = (e) => {\n\t\t\t\t\te.delegateTarget = node\n\t\t\t\t\tselectorOrCallback.apply(node, [e].concat(e.detail.args))\n\t\t\t\t}\n\t\t\t\tnode.addEventListener(ev, selectorOrCallback.handler, { signal })\n\t\t\t}\n\n\t\t},\n\n\t\toff( ev, callback ) {\n\t\t\tif( callback.handler ) {\n\t\t\t\tnode.removeEventListener(ev, callback.handler)\n\t\t\t}\n\t\t},\n\n\t\ttrigger(ev, selectorOrCallback, data) {\n\t\t\tif( selectorOrCallback.constructor === String ) {\n\t\t\t\tArray\n\t\t\t\t\t.from(node.querySelectorAll(selectorOrCallback))\n\t\t\t\t\t.forEach( children => {\n\t\t\t\t\t\tchildren.dispatchEvent(new CustomEvent(ev, { bubbles: true, detail: { args: data } }) )\n\t\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tnode.dispatchEvent(new CustomEvent(ev, { bubbles: true, detail:{ args: data } }))\n\t\t\t}\n\t\t},\n\n\t\temit(ev, data) {\n\t\t\tnode.dispatchEvent(new CustomEvent(ev, { bubbles: true, detail: { args: data } }))\n\t\t},\n\n\t\tunmount( fn ) {\n\t\t\tnode.addEventListener(':unmount', fn)\n\t\t},\n\n\t\tinnerHTML ( target, html_ ) {\n\t\t\tconst element = html_? target : node\n\t\t\tconst clone = element.cloneNode()\n\t\t\tconst html = html_? html_ : target\n\t\t\tclone.innerHTML = html\n\t\t\tmorphdom(element, clone)\n\t\t}\n\t}\n\n\tconst render = ( data, callback = (() => {}) ) => {\n\t\tclearTimeout( tick )\n\t\ttick = setTimeout(() => {\n\t\t\tconst html = tpl.render.call({...data, ...view(data)}, node, safe, g )\n\t\t\tmorphdom( node, html, morhdomOptions(node, register) )\n\t\t\tPromise.resolve().then(() => {\n\t\t\t\tnode.querySelectorAll('[tplid]')\n\t\t\t\t\t.forEach((element) => {\n\t\t\t\t\t\tconst child = register.get(element)\n\t\t\t\t\t\tif(!child) return\n\t\t\t\t\t\tchild.state.protected().forEach( key => delete data[key] )\n\t\t\t\t\t\tchild.state.set(data)\n\t\t\t\t\t})\n\t\t\t\tPromise.resolve().then(() => {\n\t\t\t\t\tg.scope = {}\n\t\t\t\t\tcallback()\n\t\t\t\t})\n\t\t\t})\n\t\t})\n\t}\n\n\trender( state )\n\tregister.set( node, base )\n\treturn module.default( base )\n}\n\nconst morhdomOptions = ( parent, register ) => {\n\n\tconst update = ( node ) => {\n\t\tif( node.nodeType === 1 ) {\n\t\t\tif( 'html-static' in node.attributes ) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif( register.get(node) && node !== parent ) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\treturn {\n\t\tonBeforeElChildrenUpdated: update,\n\t\tonBeforeElUpdated: update\n\t}\n}\n","import { Component } from './component'\n\nconst register = new WeakMap()\n\nexport const Element = ({ component, templates, start }) => {\n\n\tconst { name, module, dependencies } = component\n\n\treturn class extends HTMLElement {\n\n\t\tconstructor() {\n\t\t\tsuper()\n\t\t}\n\n\t\tconnectedCallback() {\n\n\t\t\tthis.abortController = new AbortController()\n\n\t\t\tif( !this.getAttribute('tplid') ) {\n\t\t\t\tstart( this.parentNode )\n\t\t\t}\n\n\t\t\tconst rtrn = Component({\n\t\t\t\tnode:this,\n\t\t\t\tname,\n\t\t\t\tmodule,\n\t\t\t\tdependencies,\n\t\t\t\ttemplates,\n\t\t\t\tsignal: this.abortController.signal,\n\t\t\t\tregister\n\t\t\t})\n\n\t\t\tif ( rtrn && rtrn.constructor === Promise ) {\n\t\t\t\trtrn.then(() => {\n\t\t\t\t\tthis.dispatchEvent( new CustomEvent(':mount') )\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tthis.dispatchEvent( new CustomEvent(':mount') )\n\t\t\t}\n\t\t}\n\n\t\tdisconnectedCallback() {\n\t\t\tthis.dispatchEvent( new CustomEvent(':unmount') )\n\t\t\tthis.abortController.abort()\n\t\t}\n\t}\n}\n","import { uuid, decodeHTML } from './utils'\n\nconst config = {\n\ttags: ['{{', '}}']\n}\n\nconst templates  = {}\nconst booleanAttrs = /html-(allowfullscreen|async|autofocus|autoplay|checked|controls|default|defer|disabled|formnovalidate|inert|ismap|itemscope|loop|multiple|muted|nomodule|novalidate|open|playsinline|readonly|required|reversed|selected)=\"(.*?)\"/g\nconst htmlAttr = /html-([^\\s]*?)=\"(.*?)\"/g\nconst tagExpr = () => new RegExp(`\\\\${config.tags[0]}(.+?)\\\\${config.tags[1]}`, 'g')\n\nexport const templateConfig = (newconfig) => {\n\tObject.assign( config, newconfig )\n}\n\nexport const template = ( target, { components }) => {\n\n\ttagElements( target, [...Object.keys( components ), '[html-if]', 'template'], components )\n\tconst clone = target.cloneNode( true )\n\n\ttransformTemplate( clone )\n\tremoveTemplateTagsRecursively( clone )\n\tsetTemplates( clone, components )\n\n\treturn templates\n}\n\nexport const compile = ( html ) => {\n\n\tconst parsedHtml = JSON.stringify( html )\n\n\treturn new Function('$element', 'safe', '$g',`\n\t\tvar $data = this;\n\t\twith( $data ){\n\t\t\tvar output=${parsedHtml\n\t\t\t\t.replace(/%%_=(.+?)_%%/g, function(_, variable){\n\t\t\t\t\treturn '\"+safe(function(){return '+ decodeHTML(variable) +';})+\"'\n\t\t\t\t})\n\t\t\t\t.replace(/%%_(.+?)_%%/g, function(_, variable){\n\t\t\t\t\treturn '\";' + decodeHTML(variable) +'\\noutput+=\"'\n\t\t\t\t})};return output;\n\t\t}\n\t`)\n}\n\nconst tagElements = (target, keys, components) => {\n\tconst isComponent = key => key in components\n\tconst selector = keys.join(',')\n\n\ttarget.querySelectorAll(selector).forEach(node => {\n\t\tif (node.localName === 'template') {\n\t\t\ttagElements(node.content, keys, components)\n\t\t\treturn\n\t\t}\n\t\tif (node.hasAttribute('html-if') && !node.id) {\n\t\t\tnode.id = uuid()\n\t\t}\n\t\tif (isComponent(node.localName)) {\n\t\t\tnode.setAttribute('tplid', uuid())\n\t\t}\n\t})\n}\n\nconst transformAttributes = (html) => {\n\treturn html\n\t\t.replace(/jails___scope-id/g, '%%_=$scopeid_%%')\n\t\t.replace(tagExpr(), '%%_=$1_%%')\n\t\t.replace(booleanAttrs, `%%_if(safe(function(){ return $2 })){_%%$1%%_}_%%`)\n\t\t.replace(htmlAttr, (all, key, value) => {\n\t\t\tif (['key', 'model', 'scopeid'].includes(key)) return all\n\t\t\tif (value) {\n\t\t\t\tvalue = value.replace(/^{|}$/g, '')\n\t\t\t\treturn `${key}=\"%%_=safe(function(){ return ${value} })_%%\"`\n\t\t\t}\n\t\t\treturn all\n\t\t})\n}\n\nconst transformTemplate = ( clone ) => {\n\n\tclone.querySelectorAll('template, [html-for], [html-if], [html-inner], [html-class]')\n\t\t.forEach(( element ) => {\n\n\t\t\tconst htmlFor \t= element.getAttribute('html-for')\n\t\t\tconst htmlIf \t= element.getAttribute('html-if')\n\t\t\tconst htmlInner = element.getAttribute('html-inner')\n\t\t\tconst htmlClass = element.getAttribute('html-class')\n\n\t\t\tif ( htmlFor ) {\n\n\t\t\t\telement.removeAttribute('html-for')\n\n\t\t\t\tconst split \t = htmlFor.match(/(.*)\\sin\\s(.*)/) || ''\n\t\t\t\tconst varname \t = split[1]\n\t\t\t\tconst object \t = split[2]\n\t\t\t\tconst objectname = object.split(/\\./).shift()\n\t\t\t\tconst open \t\t = document.createTextNode(`%%_ ;(function(){ var $index = 0; for(var $key in safe(function(){ return ${object} }) ){ var $scopeid = Math.random().toString(36).substring(2, 9); var ${varname} = ${object}[$key]; $g.scope[$scopeid] = Object.assign({}, { ${objectname}: ${objectname} }, { ${varname} :${varname}, $index: $index, $key: $key }); _%%`)\n\t\t\t\tconst close \t = document.createTextNode(`%%_ $index++; } })() _%%`)\n\n\t\t\t\twrap(open, element, close)\n\t\t\t}\n\n\t\t\tif (htmlIf) {\n\t\t\t\telement.removeAttribute('html-if')\n\t\t\t\tconst open = document.createTextNode(`%%_ if ( safe(function(){ return ${htmlIf} }) ){ _%%`)\n\t\t\t\tconst close = document.createTextNode(`%%_ }  _%%`)\n\t\t\t\twrap(open, element, close)\n\t\t\t}\n\n\t\t\tif (htmlInner) {\n\t\t\t\telement.removeAttribute('html-inner')\n\t\t\t\telement.innerHTML = `%%_=${htmlInner}_%%`\n\t\t\t}\n\n\t\t\tif (htmlClass) {\n\t\t\t\telement.removeAttribute('html-class')\n\t\t\t\telement.className = (element.className + ` %%_=${htmlClass}_%%`).trim()\n\t\t\t}\n\n\t\t\tif( element.localName === 'template' ) {\n\t\t\t\ttransformTemplate(element.content)\n\t\t\t}\n\t\t})\n}\n\nconst setTemplates = ( clone, components ) => {\n\n\tArray.from(clone.querySelectorAll('[tplid]'))\n\t\t.reverse()\n\t\t.forEach((node) => {\n\n\t\t\tconst tplid = node.getAttribute('tplid')\n\t\t\tconst name  = node.localName\n\t\t\tnode.setAttribute('html-scopeid', 'jails___scope-id')\n\n\t\t\tif( name in components && components[name].module.template ) {\n\t\t\t\tconst children = node.innerHTML\n\t\t\t\tconst html = components[name].module.template({ elm:node, children })\n\t\t\t\tnode.innerHTML = html\n\t\t\t\ttransformTemplate(node)\n\t\t\t\tremoveTemplateTagsRecursively(node)\n\t\t\t}\n\n\t\t\tconst html = transformAttributes(node.outerHTML)\n\n\t\t\ttemplates[ tplid ] = {\n\t\t\t\ttemplate: html,\n\t\t\t\trender\t: compile(html)\n\t\t\t}\n\t\t})\n}\n\nconst removeTemplateTagsRecursively = (node) => {\n\n\t// Get all <template> elements within the node\n\tconst templates = node.querySelectorAll('template')\n\n\ttemplates.forEach((template) => {\n\n\t\tif( template.getAttribute('html-if') || template.getAttribute('html-inner') ) {\n\t\t\treturn\n\t\t}\n\n\t\t// Process any nested <template> tags within this <template> first\n\t\tremoveTemplateTagsRecursively(template.content)\n\n\t\t// Get the parent of the <template> tag\n\t\tconst parent = template.parentNode\n\n\t\tif (parent) {\n\t\t\t// Move all child nodes from the <template>'s content to its parent\n\t\t\tconst content = template.content\n\t\t\twhile (content.firstChild) {\n\t\t\t\tparent.insertBefore(content.firstChild, template)\n\t\t\t}\n\t\t\t// Remove the <template> tag itself\n\t\t\tparent.removeChild(template)\n\t\t}\n\t})\n}\n\n\nconst wrap = (open, node, close) => {\n\tnode.parentNode?.insertBefore(open, node)\n\tnode.parentNode?.insertBefore(close, node.nextSibling)\n}\n","\nimport { Element } from './element'\nimport { template, templateConfig as config } from './template-system'\n\nexport { publish, subscribe } from './utils/pubsub'\n\nexport const templateConfig = (options) => {\n\tconfig( options )\n}\n\nglobalThis.__jails__ = globalThis.__jails__ || { components: {} }\n\nexport const register = ( name, module, dependencies ) => {\n\tconst { components } = globalThis.__jails__\n\tcomponents[ name ] = { name, module, dependencies }\n}\n\nexport const start = ( target ) => {\n\n\t// If the code is running in a Node.js environment, do nothing\n\tif( typeof window === 'undefined' ) {\n\t\treturn;\n\t}\n\n\ttarget = target || document.body\n\tconst { components } = globalThis.__jails__\n\tconst templates = template( target, { components } )\n\n\tObject\n\t\t.values( components )\n\t\t.forEach(({ name, module, dependencies }) => {\n\t\t\tif( !customElements.get(name) ) {\n\t\t\t\tcustomElements.define( name, Element({ component: { name, module, dependencies }, templates, start }))\n\t\t\t}\n\t})\n}\n"],"names":["template","morphAttrs","morphdom","childrenOnly","templates","register","name","target","start","templateConfig","html","config"],"mappings":"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","x_google_ignoreList":[2]}