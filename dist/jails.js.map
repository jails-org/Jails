{"version":3,"file":"jails.js","sources":["../src/transpile.ts","../src/utils/index.ts","../src/template-system.ts","../src/utils/pubsub.ts","../node_modules/idiomorph/dist/idiomorph.esm.js","../src/utils/events.ts","../src/component.ts","../src/element.ts","../src/index.ts"],"sourcesContent":["const parser = new DOMParser()\n\nexport default function Transpile(html, config) {\n\n\tconst regexTags = new RegExp(`\\\\${config.tags[0]}(.+?)\\\\${config.tags[1]}`, 'g')\n\tconst virtual = parser.parseFromString(html.replace(/<\\/?template[^>]*>/g, ''), 'text/html')\n\n\tvirtual.querySelectorAll('[html-for], [html-if], [html-inner], [html-class], [html-model]').forEach((element) => {\n\n\t\tconst htmlForeach = element.getAttribute('html-foreach')\n\t\tconst htmlFor \t= element.getAttribute('html-for')\n\t\tconst htmlIf \t= element.getAttribute('html-if')\n\t\tconst htmlInner = element.getAttribute('html-inner')\n\t\tconst htmlClass = element.getAttribute('html-class')\n\t\tconst forEachInstruction = htmlFor || htmlForeach\n\n\t\tif ( forEachInstruction ) {\n\t\t\tconst selector = htmlFor? 'html-for': 'html-foreach'\n\t\t\tconst split = forEachInstruction.match(/(.*)\\sin\\s(.*)/) || ''\n\t\t\tconst varname = split[1]\n\t\t\tconst object = split[2]\n\n\t\t\telement.removeAttribute(selector)\n\t\t\telement.setAttribute('scope', '')\n\t\t\tconst script = document.createElement('script')\n\n\t\t\tscript.dataset.scope = ''\n\t\t\tscript.type = 'text/html'\n\t\t\tscript.text = `%%_= $scope _%%`\n\n\t\t\telement.appendChild( script )\n\n\t\t\tconst open = document.createTextNode(`%%_(function(){ var $index = 0; for(var $key in safe(function(){ return ${object} }) ){ var ${varname} = ${object}[$key]; var $scope = JSON.stringify({ '${varname}':${varname}, $index: $index, $key:$key }); _%%`)\n\t\t\tconst close = document.createTextNode(`%%_ $index++; } })() _%%`)\n\t\t\twrap(open, element, close)\n\t\t}\n\t\tif (htmlIf) {\n\t\t\telement.removeAttribute('html-if')\n\t\t\tconst open = document.createTextNode(`%%_ if ( safe(function(){ return ${htmlIf} }) ){ _%%`)\n\t\t\tconst close = document.createTextNode(`%%_ } _%%`)\n\t\t\twrap(open, element, close)\n\t\t}\n\t\tif (htmlInner) {\n\t\t\telement.removeAttribute('html-inner')\n\t\t\telement.innerHTML = `%%_=${htmlInner}_%%`\n\t\t}\n\t\tif (htmlClass) {\n\t\t\telement.removeAttribute('html-class')\n\t\t\telement.className = (element.className + ` %%_=${htmlClass}_%%`).trim()\n\t\t}\n\t})\n\n\n\treturn (\n\t\tvirtual.body.innerHTML\n\t\t\t.replace(regexTags, '%%_=$1_%%')\n\t\t\t// Booleans\n\t\t\t// https://meiert.com/en/blog/boolean-attributes-of-html/\n\t\t\t.replace(/html-(allowfullscreen|async|autofocus|autoplay|checked|controls|default|defer|disabled|formnovalidate|inert|ismap|itemscope|loop|multiple|muted|nomodule|novalidate|open|playsinline|readonly|required|reversed|selected)=\\\"(.*?)\\\"/g, `%%_if(safe(function(){ return $2 })){_%%$1%%_}_%%`)\n\t\t\t// The rest\n\t\t\t.replace(/html-(.*?)=\\\"(.*?)\\\"/g, (all, key, value) => {\n\t\t\t\tif (key === 'key' || key === 'model' || key == 'scope') {\n\t\t\t\t\treturn all\n\t\t\t\t}\n\t\t\t\tif (value) {\n\t\t\t\t\tvalue = value.replace(/^{|}$/g, '')\n\t\t\t\t\treturn `${key}=\"%%_=safe(function(){ return ${value} })_%%\"`\n\t\t\t\t} else {\n\t\t\t\t\treturn all\n\t\t\t\t}\n\t\t\t})\n\t)\n}\n\nconst wrap = (open, node, close) => {\n\tnode.parentNode?.insertBefore(open, node)\n\tnode.parentNode?.insertBefore(close, node.nextSibling)\n}\n","const textarea = document.createElement('textarea')\n\nexport const decodeHTML = (text) => {\n\ttextarea.innerHTML = text\n\treturn textarea.value\n}\n\nexport const rAF = (fn) => {\n\tif (requestAnimationFrame)\n\t\treturn requestAnimationFrame(fn)\n\telse\n\t\treturn setTimeout(fn, 1000 / 60)\n}\n\nexport const uuid = () => {\n\treturn 'xxxxxxxx'.replace(/[xy]/g, (c) => {\n\t\tconst r = Math.random() * 8 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8)\n\t\treturn v.toString(8)\n\t})\n}\n\n\nexport const dup = (o) => {\n\treturn JSON.parse(JSON.stringify(o))\n}\n\n// http://crockford.com/javascript/memory/leak.html\nexport const purge = (d) => {\n\tvar a = d.attributes, i, l, n\n\tif (a) {\n\t\tfor (i = a.length - 1; i >= 0; i -= 1) {\n\t\t\tn = a[i].name\n\t\t\tif (typeof d[n] === 'function') {\n\t\t\t\td[n] = null\n\t\t\t}\n\t\t}\n\t}\n\ta = d.childNodes\n\tif (a) {\n\t\tl = a.length\n\t\tfor (i = 0; i < l; i += 1) {\n\t\t\tpurge(d.childNodes[i])\n\t\t}\n\t}\n}\n\nexport const safe = (execute, val) => {\n\ttry{return execute()}catch(err){return val || ''}\n}\n\n// From\n// https://2ality.com/2015/01/template-strings-html.html#comment-2078932192\nexport const html = (literalSections, ...substs) => {\n\n\t// Use raw literal sections: we donâ€™t want\n\t// backslashes (\\n etc.) to be interpreted\n\tlet raw = literalSections.raw\n\n\tlet result = ''\n\n\tsubsts.forEach((subst, i) => {\n\t\t// Retrieve the literal section preceding\n\t\t// the current substitution\n\t\tlet lit = raw[i]\n\n\t\t// In the example, map() returns an array:\n\t\t// If substitution is an array (and not a string),\n\t\t// we turn it into a string\n\t\tif (Array.isArray(subst)) {\n\t\t\tsubst = subst.join('')\n\t\t}\n\n\t\tresult += lit\n\t\tresult += subst\n\t})\n\t// Take care of last literal section\n\t// (Never fails, because an empty template string\n\t// produces one literal section, an empty string)\n\tresult += raw[raw.length-1] // (A)\n\n\treturn result\n}\n","import Transpile from './transpile'\nimport { uuid, decodeHTML } from './utils'\n\nconst config = {\n\ttags: ['${', '}']\n}\n\nexport const templateConfig = (newconfig) => {\n\tObject.assign(config, newconfig)\n}\n\nexport default function Template(element) {\n\n\tconst html = Transpile(element.outerHTML, config)\n\tconst decodedHTML  = JSON.stringify(html)\n\n\treturn new Function('$element', 'safe',`\n\t\tvar $data = this;\n\t\twith( $data ){\n\t\t\tvar output=${decodedHTML\n\t\t\t\t.replace(/%%_=(.+?)_%%/g, function(_, variable){\n\t\t\t\t\treturn '\"+safe(function(){return '+decodeHTML(variable)+';})+\"'\n\t\t\t\t})\n\t\t\t\t.replace(/%%_(.+?)_%%/g, function(_, variable){\n\t\t\t\t\treturn '\";' + decodeHTML(variable) +'\\noutput+=\"'\n\t\t\t\t})};return output;\n\t\t}\n\t`)\n}\n\nexport const buildtemplates = ( target, selector, templates, components ) => {\n\t[]\n\t\t.concat( target.matches? (target.matches(selector)? target : []) : [] )\n\t\t.concat( Array.from(target.querySelectorAll( selector )) )\n\t\t.reverse()\n\t\t.forEach( (node:HTMLElement) => {\n\t\t\tnode.querySelectorAll('template').forEach( template => buildtemplates(template.content, selector, templates, components ))\n\t\t\tcreateTemplateId(node, templates, components)\n\t\t})\n}\n\nconst createTemplateId = (element, templates, components ) => {\n\n\tconst tplid = element.getAttribute('tplid')\n\n\tif (!tplid) {\n\t\tconst id = uuid()\n\t\telement.setAttribute('tplid', id)\n\t\tconst name = element.localName\n\n\t\tif( name in components && components[name].module.template ) {\n\t\t\tconst html = components[name].module.template()\n\t\t\tif( html.constructor === Promise ) {\n\t\t\t\telement.__template = html\n\t\t\t\thtml.then( htmlstring => {\n\t\t\t\t\telement.innerHTML = htmlstring\n\t\t\t\t\ttemplates[id] = Template(element)\n\t\t\t\t})\n\t\t\t}else {\n\t\t\t\telement.innerHTML = html\n\t\t\t}\n\t\t}\n\t\ttemplates[id] = Template(element)\n\t}\n}\n\n","const topics: any = {}\nconst _async: any = {}\n\nexport const publish = (name, params) => {\n\t_async[name] = Object.assign({}, _async[name], params)\n\tif (topics[name])\n\t\ttopics[name].forEach(topic => topic(params))\n}\n\nexport const subscribe = (name, method) => {\n\ttopics[name] = topics[name] || []\n\ttopics[name].push(method)\n\tif (name in _async) {\n\t\tmethod(_async[name])\n\t}\n\treturn () => {\n\t\ttopics[name] = topics[name].filter( fn => fn != method )\n\t}\n}\n\n","// base IIFE to define idiomorph\nvar Idiomorph = (function () {\n        'use strict';\n\n        //=============================================================================\n        // AND NOW IT BEGINS...\n        //=============================================================================\n        let EMPTY_SET = new Set();\n\n        // default configuration values, updatable by users now\n        let defaults = {\n            morphStyle: \"outerHTML\",\n            callbacks : {\n                beforeNodeAdded: noOp,\n                afterNodeAdded: noOp,\n                beforeNodeMorphed: noOp,\n                afterNodeMorphed: noOp,\n                beforeNodeRemoved: noOp,\n                afterNodeRemoved: noOp,\n                beforeAttributeUpdated: noOp,\n\n            },\n            head: {\n                style: 'merge',\n                shouldPreserve: function (elt) {\n                    return elt.getAttribute(\"im-preserve\") === \"true\";\n                },\n                shouldReAppend: function (elt) {\n                    return elt.getAttribute(\"im-re-append\") === \"true\";\n                },\n                shouldRemove: noOp,\n                afterHeadMorphed: noOp,\n            }\n        };\n\n        //=============================================================================\n        // Core Morphing Algorithm - morph, morphNormalizedContent, morphOldNodeTo, morphChildren\n        //=============================================================================\n        function morph(oldNode, newContent, config = {}) {\n\n            if (oldNode instanceof Document) {\n                oldNode = oldNode.documentElement;\n            }\n\n            if (typeof newContent === 'string') {\n                newContent = parseContent(newContent);\n            }\n\n            let normalizedContent = normalizeContent(newContent);\n\n            let ctx = createMorphContext(oldNode, normalizedContent, config);\n\n            return morphNormalizedContent(oldNode, normalizedContent, ctx);\n        }\n\n        function morphNormalizedContent(oldNode, normalizedNewContent, ctx) {\n            if (ctx.head.block) {\n                let oldHead = oldNode.querySelector('head');\n                let newHead = normalizedNewContent.querySelector('head');\n                if (oldHead && newHead) {\n                    let promises = handleHeadElement(newHead, oldHead, ctx);\n                    // when head promises resolve, call morph again, ignoring the head tag\n                    Promise.all(promises).then(function () {\n                        morphNormalizedContent(oldNode, normalizedNewContent, Object.assign(ctx, {\n                            head: {\n                                block: false,\n                                ignore: true\n                            }\n                        }));\n                    });\n                    return;\n                }\n            }\n\n            if (ctx.morphStyle === \"innerHTML\") {\n\n                // innerHTML, so we are only updating the children\n                morphChildren(normalizedNewContent, oldNode, ctx);\n                return oldNode.children;\n\n            } else if (ctx.morphStyle === \"outerHTML\" || ctx.morphStyle == null) {\n                // otherwise find the best element match in the new content, morph that, and merge its siblings\n                // into either side of the best match\n                let bestMatch = findBestNodeMatch(normalizedNewContent, oldNode, ctx);\n\n                // stash the siblings that will need to be inserted on either side of the best match\n                let previousSibling = bestMatch?.previousSibling;\n                let nextSibling = bestMatch?.nextSibling;\n\n                // morph it\n                let morphedNode = morphOldNodeTo(oldNode, bestMatch, ctx);\n\n                if (bestMatch) {\n                    // if there was a best match, merge the siblings in too and return the\n                    // whole bunch\n                    return insertSiblings(previousSibling, morphedNode, nextSibling);\n                } else {\n                    // otherwise nothing was added to the DOM\n                    return []\n                }\n            } else {\n                throw \"Do not understand how to morph style \" + ctx.morphStyle;\n            }\n        }\n\n\n        /**\n         * @param possibleActiveElement\n         * @param ctx\n         * @returns {boolean}\n         */\n        function ignoreValueOfActiveElement(possibleActiveElement, ctx) {\n            return ctx.ignoreActiveValue && possibleActiveElement === document.activeElement;\n        }\n\n        /**\n         * @param oldNode root node to merge content into\n         * @param newContent new content to merge\n         * @param ctx the merge context\n         * @returns {Element} the element that ended up in the DOM\n         */\n        function morphOldNodeTo(oldNode, newContent, ctx) {\n            if (ctx.ignoreActive && oldNode === document.activeElement) {\n                // don't morph focused element\n            } else if (newContent == null) {\n                if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return oldNode;\n\n                oldNode.remove();\n                ctx.callbacks.afterNodeRemoved(oldNode);\n                return null;\n            } else if (!isSoftMatch(oldNode, newContent)) {\n                if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return oldNode;\n                if (ctx.callbacks.beforeNodeAdded(newContent) === false) return oldNode;\n\n                oldNode.parentElement.replaceChild(newContent, oldNode);\n                ctx.callbacks.afterNodeAdded(newContent);\n                ctx.callbacks.afterNodeRemoved(oldNode);\n                return newContent;\n            } else {\n                if (ctx.callbacks.beforeNodeMorphed(oldNode, newContent) === false) return oldNode;\n\n                if (oldNode instanceof HTMLHeadElement && ctx.head.ignore) {\n                    // ignore the head element\n                } else if (oldNode instanceof HTMLHeadElement && ctx.head.style !== \"morph\") {\n                    handleHeadElement(newContent, oldNode, ctx);\n                } else {\n                    syncNodeFrom(newContent, oldNode, ctx);\n                    if (!ignoreValueOfActiveElement(oldNode, ctx)) {\n                        morphChildren(newContent, oldNode, ctx);\n                    }\n                }\n                ctx.callbacks.afterNodeMorphed(oldNode, newContent);\n                return oldNode;\n            }\n        }\n\n        /**\n         * This is the core algorithm for matching up children.  The idea is to use id sets to try to match up\n         * nodes as faithfully as possible.  We greedily match, which allows us to keep the algorithm fast, but\n         * by using id sets, we are able to better match up with content deeper in the DOM.\n         *\n         * Basic algorithm is, for each node in the new content:\n         *\n         * - if we have reached the end of the old parent, append the new content\n         * - if the new content has an id set match with the current insertion point, morph\n         * - search for an id set match\n         * - if id set match found, morph\n         * - otherwise search for a \"soft\" match\n         * - if a soft match is found, morph\n         * - otherwise, prepend the new node before the current insertion point\n         *\n         * The two search algorithms terminate if competing node matches appear to outweigh what can be achieved\n         * with the current node.  See findIdSetMatch() and findSoftMatch() for details.\n         *\n         * @param {Element} newParent the parent element of the new content\n         * @param {Element } oldParent the old content that we are merging the new content into\n         * @param ctx the merge context\n         */\n        function morphChildren(newParent, oldParent, ctx) {\n\n            let nextNewChild = newParent.firstChild;\n            let insertionPoint = oldParent.firstChild;\n            let newChild;\n\n            // run through all the new content\n            while (nextNewChild) {\n\n                newChild = nextNewChild;\n                nextNewChild = newChild.nextSibling;\n\n                // if we are at the end of the exiting parent's children, just append\n                if (insertionPoint == null) {\n                    if (ctx.callbacks.beforeNodeAdded(newChild) === false) return;\n\n                    oldParent.appendChild(newChild);\n                    ctx.callbacks.afterNodeAdded(newChild);\n                    removeIdsFromConsideration(ctx, newChild);\n                    continue;\n                }\n\n                // if the current node has an id set match then morph\n                if (isIdSetMatch(newChild, insertionPoint, ctx)) {\n                    morphOldNodeTo(insertionPoint, newChild, ctx);\n                    insertionPoint = insertionPoint.nextSibling;\n                    removeIdsFromConsideration(ctx, newChild);\n                    continue;\n                }\n\n                // otherwise search forward in the existing old children for an id set match\n                let idSetMatch = findIdSetMatch(newParent, oldParent, newChild, insertionPoint, ctx);\n\n                // if we found a potential match, remove the nodes until that point and morph\n                if (idSetMatch) {\n                    insertionPoint = removeNodesBetween(insertionPoint, idSetMatch, ctx);\n                    morphOldNodeTo(idSetMatch, newChild, ctx);\n                    removeIdsFromConsideration(ctx, newChild);\n                    continue;\n                }\n\n                // no id set match found, so scan forward for a soft match for the current node\n                let softMatch = findSoftMatch(newParent, oldParent, newChild, insertionPoint, ctx);\n\n                // if we found a soft match for the current node, morph\n                if (softMatch) {\n                    insertionPoint = removeNodesBetween(insertionPoint, softMatch, ctx);\n                    morphOldNodeTo(softMatch, newChild, ctx);\n                    removeIdsFromConsideration(ctx, newChild);\n                    continue;\n                }\n\n                // abandon all hope of morphing, just insert the new child before the insertion point\n                // and move on\n                if (ctx.callbacks.beforeNodeAdded(newChild) === false) return;\n\n                oldParent.insertBefore(newChild, insertionPoint);\n                ctx.callbacks.afterNodeAdded(newChild);\n                removeIdsFromConsideration(ctx, newChild);\n            }\n\n            // remove any remaining old nodes that didn't match up with new content\n            while (insertionPoint !== null) {\n\n                let tempNode = insertionPoint;\n                insertionPoint = insertionPoint.nextSibling;\n                removeNode(tempNode, ctx);\n            }\n        }\n\n        //=============================================================================\n        // Attribute Syncing Code\n        //=============================================================================\n\n        /**\n         * @param attr {String} the attribute to be mutated\n         * @param to {Element} the element that is going to be updated\n         * @param updateType {(\"update\"|\"remove\")}\n         * @param ctx the merge context\n         * @returns {boolean} true if the attribute should be ignored, false otherwise\n         */\n        function ignoreAttribute(attr, to, updateType, ctx) {\n            if(attr === 'value' && ctx.ignoreActiveValue && to === document.activeElement){\n                return true;\n            }\n            return ctx.callbacks.beforeAttributeUpdated(attr, to, updateType) === false;\n        }\n\n        /**\n         * syncs a given node with another node, copying over all attributes and\n         * inner element state from the 'from' node to the 'to' node\n         *\n         * @param {Element} from the element to copy attributes & state from\n         * @param {Element} to the element to copy attributes & state to\n         * @param ctx the merge context\n         */\n        function syncNodeFrom(from, to, ctx) {\n            let type = from.nodeType\n\n            // if is an element type, sync the attributes from the\n            // new node into the new node\n            if (type === 1 /* element type */) {\n                const fromAttributes = from.attributes;\n                const toAttributes = to.attributes;\n                for (const fromAttribute of fromAttributes) {\n                    if (ignoreAttribute(fromAttribute.name, to, 'update', ctx)) {\n                        continue;\n                    }\n                    if (to.getAttribute(fromAttribute.name) !== fromAttribute.value) {\n                        to.setAttribute(fromAttribute.name, fromAttribute.value);\n                    }\n                }\n                // iterate backwards to avoid skipping over items when a delete occurs\n                for (let i = toAttributes.length - 1; 0 <= i; i--) {\n                    const toAttribute = toAttributes[i];\n                    if (ignoreAttribute(toAttribute.name, to, 'remove', ctx)) {\n                        continue;\n                    }\n                    if (!from.hasAttribute(toAttribute.name)) {\n                        to.removeAttribute(toAttribute.name);\n                    }\n                }\n            }\n\n            // sync text nodes\n            if (type === 8 /* comment */ || type === 3 /* text */) {\n                if (to.nodeValue !== from.nodeValue) {\n                    to.nodeValue = from.nodeValue;\n                }\n            }\n\n            if (!ignoreValueOfActiveElement(to, ctx)) {\n                // sync input values\n                syncInputValue(from, to, ctx);\n            }\n        }\n\n        /**\n         * @param from {Element} element to sync the value from\n         * @param to {Element} element to sync the value to\n         * @param attributeName {String} the attribute name\n         * @param ctx the merge context\n         */\n        function syncBooleanAttribute(from, to, attributeName, ctx) {\n            if (from[attributeName] !== to[attributeName]) {\n                let ignoreUpdate = ignoreAttribute(attributeName, to, 'update', ctx);\n                if (!ignoreUpdate) {\n                    to[attributeName] = from[attributeName];\n                }\n                if (from[attributeName]) {\n                    if (!ignoreUpdate) {\n                        to.setAttribute(attributeName, from[attributeName]);\n                    }\n                } else {\n                    if (!ignoreAttribute(attributeName, to, 'remove', ctx)) {\n                        to.removeAttribute(attributeName);\n                    }\n                }\n            }\n        }\n\n        /**\n         * NB: many bothans died to bring us information:\n         *\n         *  https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n         *  https://github.com/choojs/nanomorph/blob/master/lib/morph.jsL113\n         *\n         * @param from {Element} the element to sync the input value from\n         * @param to {Element} the element to sync the input value to\n         * @param ctx the merge context\n         */\n        function syncInputValue(from, to, ctx) {\n            if (from instanceof HTMLInputElement &&\n                to instanceof HTMLInputElement &&\n                from.type !== 'file') {\n\n                let fromValue = from.value;\n                let toValue = to.value;\n\n                // sync boolean attributes\n                syncBooleanAttribute(from, to, 'checked', ctx);\n                syncBooleanAttribute(from, to, 'disabled', ctx);\n\n                if (!from.hasAttribute('value')) {\n                    if (!ignoreAttribute('value', to, 'remove', ctx)) {\n                        to.value = '';\n                        to.removeAttribute('value');\n                    }\n                } else if (fromValue !== toValue) {\n                    if (!ignoreAttribute('value', to, 'update', ctx)) {\n                        to.setAttribute('value', fromValue);\n                        to.value = fromValue;\n                    }\n                }\n            } else if (from instanceof HTMLOptionElement) {\n                syncBooleanAttribute(from, to, 'selected', ctx)\n            } else if (from instanceof HTMLTextAreaElement && to instanceof HTMLTextAreaElement) {\n                let fromValue = from.value;\n                let toValue = to.value;\n                if (ignoreAttribute('value', to, 'update', ctx)) {\n                    return;\n                }\n                if (fromValue !== toValue) {\n                    to.value = fromValue;\n                }\n                if (to.firstChild && to.firstChild.nodeValue !== fromValue) {\n                    to.firstChild.nodeValue = fromValue\n                }\n            }\n        }\n\n        //=============================================================================\n        // the HEAD tag can be handled specially, either w/ a 'merge' or 'append' style\n        //=============================================================================\n        function handleHeadElement(newHeadTag, currentHead, ctx) {\n\n            let added = []\n            let removed = []\n            let preserved = []\n            let nodesToAppend = []\n\n            let headMergeStyle = ctx.head.style;\n\n            // put all new head elements into a Map, by their outerHTML\n            let srcToNewHeadNodes = new Map();\n            for (const newHeadChild of newHeadTag.children) {\n                srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild);\n            }\n\n            // for each elt in the current head\n            for (const currentHeadElt of currentHead.children) {\n\n                // If the current head element is in the map\n                let inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML);\n                let isReAppended = ctx.head.shouldReAppend(currentHeadElt);\n                let isPreserved = ctx.head.shouldPreserve(currentHeadElt);\n                if (inNewContent || isPreserved) {\n                    if (isReAppended) {\n                        // remove the current version and let the new version replace it and re-execute\n                        removed.push(currentHeadElt);\n                    } else {\n                        // this element already exists and should not be re-appended, so remove it from\n                        // the new content map, preserving it in the DOM\n                        srcToNewHeadNodes.delete(currentHeadElt.outerHTML);\n                        preserved.push(currentHeadElt);\n                    }\n                } else {\n                    if (headMergeStyle === \"append\") {\n                        // we are appending and this existing element is not new content\n                        // so if and only if it is marked for re-append do we do anything\n                        if (isReAppended) {\n                            removed.push(currentHeadElt);\n                            nodesToAppend.push(currentHeadElt);\n                        }\n                    } else {\n                        // if this is a merge, we remove this content since it is not in the new head\n                        if (ctx.head.shouldRemove(currentHeadElt) !== false) {\n                            removed.push(currentHeadElt);\n                        }\n                    }\n                }\n            }\n\n            // Push the remaining new head elements in the Map into the\n            // nodes to append to the head tag\n            nodesToAppend.push(...srcToNewHeadNodes.values());\n            log(\"to append: \", nodesToAppend);\n\n            let promises = [];\n            for (const newNode of nodesToAppend) {\n                log(\"adding: \", newNode);\n                let newElt = document.createRange().createContextualFragment(newNode.outerHTML).firstChild;\n                log(newElt);\n                if (ctx.callbacks.beforeNodeAdded(newElt) !== false) {\n                    if (newElt.href || newElt.src) {\n                        let resolve = null;\n                        let promise = new Promise(function (_resolve) {\n                            resolve = _resolve;\n                        });\n                        newElt.addEventListener('load', function () {\n                            resolve();\n                        });\n                        promises.push(promise);\n                    }\n                    currentHead.appendChild(newElt);\n                    ctx.callbacks.afterNodeAdded(newElt);\n                    added.push(newElt);\n                }\n            }\n\n            // remove all removed elements, after we have appended the new elements to avoid\n            // additional network requests for things like style sheets\n            for (const removedElement of removed) {\n                if (ctx.callbacks.beforeNodeRemoved(removedElement) !== false) {\n                    currentHead.removeChild(removedElement);\n                    ctx.callbacks.afterNodeRemoved(removedElement);\n                }\n            }\n\n            ctx.head.afterHeadMorphed(currentHead, {added: added, kept: preserved, removed: removed});\n            return promises;\n        }\n\n        //=============================================================================\n        // Misc\n        //=============================================================================\n\n        function log() {\n            //console.log(arguments);\n        }\n\n        function noOp() {\n        }\n\n        /*\n          Deep merges the config object and the Idiomoroph.defaults object to\n          produce a final configuration object\n         */\n        function mergeDefaults(config) {\n            let finalConfig = {};\n            // copy top level stuff into final config\n            Object.assign(finalConfig, defaults);\n            Object.assign(finalConfig, config);\n\n            // copy callbacks into final config (do this to deep merge the callbacks)\n            finalConfig.callbacks = {};\n            Object.assign(finalConfig.callbacks, defaults.callbacks);\n            Object.assign(finalConfig.callbacks, config.callbacks);\n\n            // copy head config into final config  (do this to deep merge the head)\n            finalConfig.head = {};\n            Object.assign(finalConfig.head, defaults.head);\n            Object.assign(finalConfig.head, config.head);\n            return finalConfig;\n        }\n\n        function createMorphContext(oldNode, newContent, config) {\n            config = mergeDefaults(config);\n            return {\n                target: oldNode,\n                newContent: newContent,\n                config: config,\n                morphStyle: config.morphStyle,\n                ignoreActive: config.ignoreActive,\n                ignoreActiveValue: config.ignoreActiveValue,\n                idMap: createIdMap(oldNode, newContent),\n                deadIds: new Set(),\n                callbacks: config.callbacks,\n                head: config.head\n            }\n        }\n\n        function isIdSetMatch(node1, node2, ctx) {\n            if (node1 == null || node2 == null) {\n                return false;\n            }\n            if (node1.nodeType === node2.nodeType && node1.tagName === node2.tagName) {\n                if (node1.id !== \"\" && node1.id === node2.id) {\n                    return true;\n                } else {\n                    return getIdIntersectionCount(ctx, node1, node2) > 0;\n                }\n            }\n            return false;\n        }\n\n        function isSoftMatch(node1, node2) {\n            if (node1 == null || node2 == null) {\n                return false;\n            }\n            return node1.nodeType === node2.nodeType && node1.tagName === node2.tagName\n        }\n\n        function removeNodesBetween(startInclusive, endExclusive, ctx) {\n            while (startInclusive !== endExclusive) {\n                let tempNode = startInclusive;\n                startInclusive = startInclusive.nextSibling;\n                removeNode(tempNode, ctx);\n            }\n            removeIdsFromConsideration(ctx, endExclusive);\n            return endExclusive.nextSibling;\n        }\n\n        //=============================================================================\n        // Scans forward from the insertionPoint in the old parent looking for a potential id match\n        // for the newChild.  We stop if we find a potential id match for the new child OR\n        // if the number of potential id matches we are discarding is greater than the\n        // potential id matches for the new child\n        //=============================================================================\n        function findIdSetMatch(newContent, oldParent, newChild, insertionPoint, ctx) {\n\n            // max id matches we are willing to discard in our search\n            let newChildPotentialIdCount = getIdIntersectionCount(ctx, newChild, oldParent);\n\n            let potentialMatch = null;\n\n            // only search forward if there is a possibility of an id match\n            if (newChildPotentialIdCount > 0) {\n                let potentialMatch = insertionPoint;\n                // if there is a possibility of an id match, scan forward\n                // keep track of the potential id match count we are discarding (the\n                // newChildPotentialIdCount must be greater than this to make it likely\n                // worth it)\n                let otherMatchCount = 0;\n                while (potentialMatch != null) {\n\n                    // If we have an id match, return the current potential match\n                    if (isIdSetMatch(newChild, potentialMatch, ctx)) {\n                        return potentialMatch;\n                    }\n\n                    // computer the other potential matches of this new content\n                    otherMatchCount += getIdIntersectionCount(ctx, potentialMatch, newContent);\n                    if (otherMatchCount > newChildPotentialIdCount) {\n                        // if we have more potential id matches in _other_ content, we\n                        // do not have a good candidate for an id match, so return null\n                        return null;\n                    }\n\n                    // advanced to the next old content child\n                    potentialMatch = potentialMatch.nextSibling;\n                }\n            }\n            return potentialMatch;\n        }\n\n        //=============================================================================\n        // Scans forward from the insertionPoint in the old parent looking for a potential soft match\n        // for the newChild.  We stop if we find a potential soft match for the new child OR\n        // if we find a potential id match in the old parents children OR if we find two\n        // potential soft matches for the next two pieces of new content\n        //=============================================================================\n        function findSoftMatch(newContent, oldParent, newChild, insertionPoint, ctx) {\n\n            let potentialSoftMatch = insertionPoint;\n            let nextSibling = newChild.nextSibling;\n            let siblingSoftMatchCount = 0;\n\n            while (potentialSoftMatch != null) {\n\n                if (getIdIntersectionCount(ctx, potentialSoftMatch, newContent) > 0) {\n                    // the current potential soft match has a potential id set match with the remaining new\n                    // content so bail out of looking\n                    return null;\n                }\n\n                // if we have a soft match with the current node, return it\n                if (isSoftMatch(newChild, potentialSoftMatch)) {\n                    return potentialSoftMatch;\n                }\n\n                if (isSoftMatch(nextSibling, potentialSoftMatch)) {\n                    // the next new node has a soft match with this node, so\n                    // increment the count of future soft matches\n                    siblingSoftMatchCount++;\n                    nextSibling = nextSibling.nextSibling;\n\n                    // If there are two future soft matches, bail to allow the siblings to soft match\n                    // so that we don't consume future soft matches for the sake of the current node\n                    if (siblingSoftMatchCount >= 2) {\n                        return null;\n                    }\n                }\n\n                // advanced to the next old content child\n                potentialSoftMatch = potentialSoftMatch.nextSibling;\n            }\n\n            return potentialSoftMatch;\n        }\n\n        function parseContent(newContent) {\n            let parser = new DOMParser();\n\n            // remove svgs to avoid false-positive matches on head, etc.\n            let contentWithSvgsRemoved = newContent.replace(/<svg(\\s[^>]*>|>)([\\s\\S]*?)<\\/svg>/gim, '');\n\n            // if the newContent contains a html, head or body tag, we can simply parse it w/o wrapping\n            if (contentWithSvgsRemoved.match(/<\\/html>/) || contentWithSvgsRemoved.match(/<\\/head>/) || contentWithSvgsRemoved.match(/<\\/body>/)) {\n                let content = parser.parseFromString(newContent, \"text/html\");\n                // if it is a full HTML document, return the document itself as the parent container\n                if (contentWithSvgsRemoved.match(/<\\/html>/)) {\n                    content.generatedByIdiomorph = true;\n                    return content;\n                } else {\n                    // otherwise return the html element as the parent container\n                    let htmlElement = content.firstChild;\n                    if (htmlElement) {\n                        htmlElement.generatedByIdiomorph = true;\n                        return htmlElement;\n                    } else {\n                        return null;\n                    }\n                }\n            } else {\n                // if it is partial HTML, wrap it in a template tag to provide a parent element and also to help\n                // deal with touchy tags like tr, tbody, etc.\n                let responseDoc = parser.parseFromString(\"<body><template>\" + newContent + \"</template></body>\", \"text/html\");\n                let content = responseDoc.body.querySelector('template').content;\n                content.generatedByIdiomorph = true;\n                return content\n            }\n        }\n\n        function normalizeContent(newContent) {\n            if (newContent == null) {\n                // noinspection UnnecessaryLocalVariableJS\n                const dummyParent = document.createElement('div');\n                return dummyParent;\n            } else if (newContent.generatedByIdiomorph) {\n                // the template tag created by idiomorph parsing can serve as a dummy parent\n                return newContent;\n            } else if (newContent instanceof Node) {\n                // a single node is added as a child to a dummy parent\n                const dummyParent = document.createElement('div');\n                dummyParent.append(newContent);\n                return dummyParent;\n            } else {\n                // all nodes in the array or HTMLElement collection are consolidated under\n                // a single dummy parent element\n                const dummyParent = document.createElement('div');\n                for (const elt of [...newContent]) {\n                    dummyParent.append(elt);\n                }\n                return dummyParent;\n            }\n        }\n\n        function insertSiblings(previousSibling, morphedNode, nextSibling) {\n            let stack = []\n            let added = []\n            while (previousSibling != null) {\n                stack.push(previousSibling);\n                previousSibling = previousSibling.previousSibling;\n            }\n            while (stack.length > 0) {\n                let node = stack.pop();\n                added.push(node); // push added preceding siblings on in order and insert\n                morphedNode.parentElement.insertBefore(node, morphedNode);\n            }\n            added.push(morphedNode);\n            while (nextSibling != null) {\n                stack.push(nextSibling);\n                added.push(nextSibling); // here we are going in order, so push on as we scan, rather than add\n                nextSibling = nextSibling.nextSibling;\n            }\n            while (stack.length > 0) {\n                morphedNode.parentElement.insertBefore(stack.pop(), morphedNode.nextSibling);\n            }\n            return added;\n        }\n\n        function findBestNodeMatch(newContent, oldNode, ctx) {\n            let currentElement;\n            currentElement = newContent.firstChild;\n            let bestElement = currentElement;\n            let score = 0;\n            while (currentElement) {\n                let newScore = scoreElement(currentElement, oldNode, ctx);\n                if (newScore > score) {\n                    bestElement = currentElement;\n                    score = newScore;\n                }\n                currentElement = currentElement.nextSibling;\n            }\n            return bestElement;\n        }\n\n        function scoreElement(node1, node2, ctx) {\n            if (isSoftMatch(node1, node2)) {\n                return .5 + getIdIntersectionCount(ctx, node1, node2);\n            }\n            return 0;\n        }\n\n        function removeNode(tempNode, ctx) {\n            removeIdsFromConsideration(ctx, tempNode)\n            if (ctx.callbacks.beforeNodeRemoved(tempNode) === false) return;\n\n            tempNode.remove();\n            ctx.callbacks.afterNodeRemoved(tempNode);\n        }\n\n        //=============================================================================\n        // ID Set Functions\n        //=============================================================================\n\n        function isIdInConsideration(ctx, id) {\n            return !ctx.deadIds.has(id);\n        }\n\n        function idIsWithinNode(ctx, id, targetNode) {\n            let idSet = ctx.idMap.get(targetNode) || EMPTY_SET;\n            return idSet.has(id);\n        }\n\n        function removeIdsFromConsideration(ctx, node) {\n            let idSet = ctx.idMap.get(node) || EMPTY_SET;\n            for (const id of idSet) {\n                ctx.deadIds.add(id);\n            }\n        }\n\n        function getIdIntersectionCount(ctx, node1, node2) {\n            let sourceSet = ctx.idMap.get(node1) || EMPTY_SET;\n            let matchCount = 0;\n            for (const id of sourceSet) {\n                // a potential match is an id in the source and potentialIdsSet, but\n                // that has not already been merged into the DOM\n                if (isIdInConsideration(ctx, id) && idIsWithinNode(ctx, id, node2)) {\n                    ++matchCount;\n                }\n            }\n            return matchCount;\n        }\n\n        /**\n         * A bottom up algorithm that finds all elements with ids inside of the node\n         * argument and populates id sets for those nodes and all their parents, generating\n         * a set of ids contained within all nodes for the entire hierarchy in the DOM\n         *\n         * @param node {Element}\n         * @param {Map<Node, Set<String>>} idMap\n         */\n        function populateIdMapForNode(node, idMap) {\n            let nodeParent = node.parentElement;\n            // find all elements with an id property\n            let idElements = node.querySelectorAll('[id]');\n            for (const elt of idElements) {\n                let current = elt;\n                // walk up the parent hierarchy of that element, adding the id\n                // of element to the parent's id set\n                while (current !== nodeParent && current != null) {\n                    let idSet = idMap.get(current);\n                    // if the id set doesn't exist, create it and insert it in the  map\n                    if (idSet == null) {\n                        idSet = new Set();\n                        idMap.set(current, idSet);\n                    }\n                    idSet.add(elt.id);\n                    current = current.parentElement;\n                }\n            }\n        }\n\n        /**\n         * This function computes a map of nodes to all ids contained within that node (inclusive of the\n         * node).  This map can be used to ask if two nodes have intersecting sets of ids, which allows\n         * for a looser definition of \"matching\" than tradition id matching, and allows child nodes\n         * to contribute to a parent nodes matching.\n         *\n         * @param {Element} oldContent  the old content that will be morphed\n         * @param {Element} newContent  the new content to morph to\n         * @returns {Map<Node, Set<String>>} a map of nodes to id sets for the\n         */\n        function createIdMap(oldContent, newContent) {\n            let idMap = new Map();\n            populateIdMapForNode(oldContent, idMap);\n            populateIdMapForNode(newContent, idMap);\n            return idMap;\n        }\n\n        //=============================================================================\n        // This is what ends up becoming the Idiomorph global object\n        //=============================================================================\n        return {\n            morph,\n            defaults\n        }\n    })();\n\nexport {Idiomorph};\n","const customEvent = (() => {\n\treturn ('CustomEvent' in window && typeof window.CustomEvent === 'function')\n\t\t? (name, data) => new CustomEvent(name, data)\n\t\t: (name, data) => {\n\t\t\tconst newEvent = document.createEvent('CustomEvent')\n\t\t\tnewEvent.initCustomEvent(name, true, true, data)\n\t\t\treturn newEvent\n\t\t}\n})()\n\nconst handler = (node, ev) => {\n\treturn function (e) {\n\t\tconst scope = this\n\t\tconst detail = e.detail || {}\n\t\tnode.__events[ev].forEach(o => {\n\t\t\to.handler.apply(scope, [e].concat(detail.args))\n\t\t})\n\t}\n}\n\nconst removeListener = (node, ev) => {\n\tif (node.__events[ev] && node.__events[ev].listener) {\n\t\tnode.removeEventListener(\n\t\t\tev,\n\t\t\tnode.__events[ev].listener,\n\t\t\t(ev == 'focus' || ev == 'blur' || ev == 'mouseenter' || ev == 'mouseleave'))\n\t\tdelete node.__events[ev]\n\t}\n}\n\nconst delegate = (node, selector, callback) => {\n\treturn function (e) {\n\n\t\tconst element = this\n\t\tconst detail = e.detail || {}\n\n\t\tlet parent = e.target\n\n\t\twhile (parent) {\n\t\t\tif (parent.matches(selector)) {\n\t\t\t\te.delegateTarget = parent\n\t\t\t\tcallback.apply(element, [e].concat(detail.args))\n\t\t\t}\n\t\t\tif (parent === node) break\n\t\t\tparent = parent.parentNode\n\t\t}\n\t}\n}\n\nexport const on = (node, ev, selectorOrCallback, callback) => {\n\n\tnode.__events = node.__events || {}\n\tnode.__events[ev] = (node.__events[ev] || [])\n\n\tif (!node.__events[ev].length) {\n\t\tconst fn = handler(node, ev)\n\t\tnode.addEventListener(\n\t\t\tev,\n\t\t\tfn,\n\t\t\t(ev == 'focus' || ev == 'blur' || ev == 'mouseenter' || ev == 'mouseleave'))\n\t\tnode.__events[ev].listener = fn\n\t}\n\n\tif (selectorOrCallback.call) {\n\t\tnode.__events[ev].push({ handler: selectorOrCallback, callback: selectorOrCallback })\n\t} else {\n\t\tnode.__events[ev].push({ handler: delegate(node, selectorOrCallback, callback), callback })\n\t}\n}\n\nexport const off = (node, ev, fn) => {\n\n\tif (fn && node.__events[ev] && node.__events[ev].length) {\n\t\tvar old = node.__events[ev]\n\t\tnode.__events[ev] = node.__events[ev].filter(function (o) { return o.callback != fn; })\n\t\tnode.__events[ev].listener = old.listener\n\t\tif (!node.__events[ev].length)\n\t\t\tremoveListener(node, ev)\n\t} else {\n\t\tremoveListener(node, ev)\n\t}\n}\n\nexport const trigger = (node, name, args) => {\n\tnode.dispatchEvent(customEvent(name, { bubbles: true, detail: args }))\n}\n","import { type Component } from '..'\nimport { Idiomorph } from 'idiomorph/dist/idiomorph.esm'\nimport { rAF, dup, safe } from './utils'\nimport { buildtemplates } from './template-system'\nimport { on, off, trigger } from './utils/events'\nimport { publish, subscribe } from './utils/pubsub'\n\nexport default function Component( elm, { module, dependencies, templates, components }) {\n\n\tconst options = getOptions( module )\n\tconst initialState = (new Function( `return ${elm.getAttribute('html-model') || '{}'}`))()\n\tconst selector = Object.keys(components).toString()\n\n\tbuildtemplates( elm, selector, templates, components )\n\n\tconst tplid = elm.getAttribute('tplid')\n\tconst template = tplid ? templates[tplid] : null\n\tconst state = { data: module.model ? dup(module.model) : {} }\n\tstate.data = Object.assign( state.data, initialState)\n\n\tconst base: Component = {\n\t\ttemplate,\n\t\telm,\n\t\tdependencies,\n\t\tpublish,\n\t\tsubscribe,\n\n\t\tmain(fn) {\n\t\t\toptions.main = fn\n\t\t},\n\n\t\tunmount(fn) {\n\t\t\toptions.unmount = fn\n\t\t},\n\n\t\tonupdate(fn) {\n\t\t\toptions.onupdate = fn\n\t\t},\n\n\t\ton(eventName, selectorOrCallback, callback) {\n\t\t\ton(elm, eventName, selectorOrCallback, callback)\n\t\t},\n\n\t\toff(eventName, callback) {\n\t\t\toff(elm, eventName, callback)\n\t\t},\n\n\t\ttrigger(eventName, target, args) {\n\t\t\tif (target.constructor === String) {\n\t\t\t\tArray\n\t\t\t\t\t.from(elm.querySelectorAll(target))\n\t\t\t\t\t.forEach( children => trigger(children, eventName, { args: args }) )\n\t\t\t}\n\t\t\telse trigger(elm, eventName, { args: target })\n\t\t},\n\n\t\temit: ( ...args ) => {\n\t\t\ttrigger(elm, args.shift(), { args: args })\n\t\t},\n\n\t\tstate: {\n\t\t\tset( data ) {\n\t\t\t\tif (data.constructor === Function) {\n\t\t\t\t\tconst newstate = dup(state.data)\n\t\t\t\t\tdata(newstate)\n\t\t\t\t\tbase.render(newstate)\n\t\t\t\t} else {\n\t\t\t\t\tbase.render(data)\n\t\t\t\t}\n\t\t\t\treturn new Promise((resolve) => rAF(_ => rAF(() => resolve(state.data))))\n\t\t\t},\n\t\t\tget() {\n\t\t\t\treturn dup(state.data)\n\t\t\t},\n\n\t\t\tgetRaw(){\n\t\t\t\treturn state.data\n\t\t\t}\n\t\t},\n\n\t\trender(data = state.data) {\n\n\t\t\tif (!document.body.contains(elm)) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tstate.data = Object.assign(state.data, data)\n\n\t\t\tconst newdata = dup(state.data)\n\t\t\tconst newhtml = templates[tplid].call(Object.assign(options.view(newdata), elm.___scope___), elm, safe)\n\n\t\t\tIdiomorph.morph(elm, newhtml, IdiomorphOptions(elm))\n\t\t\tupdateScope( elm )\n\n\t\t\trAF(_ => {\n\t\t\t\tArray\n\t\t\t\t\t.from(elm.querySelectorAll('[tplid]'))\n\t\t\t\t\t.forEach((child: any) => {\n\t\t\t\t\t\tconst props = Object.assign( child.base.state.getRaw(), data )\n\t\t\t\t\t\tchild.options.onupdate(props)\n\t\t\t\t\t\tchild.base.render(props)\n\t\t\t\t\t})\n\t\t\t})\n\t\t},\n\n\t\tinnerHTML( target, html_ ) {\n\n\t\t\tconst element = html_? target : elm\n\t\t\tconst clone = element.cloneNode()\n\t\t\tconst html = html_? html_ : target\n\t\t\tclone.innerHTML = html\n\n\t\t\trAF( _ => Idiomorph.morph(element, clone, IdiomorphOptions) )\n\t\t}\n\t}\n\n\treturn { base, options }\n}\n\nconst getOptions = (module) => ({\n\tmain: (a) => a,\n\tunmount: (a) => a,\n\tonupdate: (a) => a,\n\tview: module.view ? module.view : (a) => a\n})\n\nconst updateScope = (node) => {\n\tnode.querySelectorAll('[scope]').forEach( scopeElement => {\n\t\tscopeElement.querySelectorAll('[tplid]').forEach( cp => {\n\t\t\tif( !cp.___scope___ ) {\n\t\t\t\tconst script = scopeElement.lastElementChild\n\t\t\t\tcp.___scope___ = 'scope' in script.dataset? (new Function(`return ${script.text}`))() : {}\n\t\t\t}\n\t\t})\n\t})\n}\n\n\nconst IdiomorphOptions = (parent) => ({\n\n\tcallbacks: {\n\n\t\tbeforeNodeMorphed( node ) {\n\t\t\tif( node.nodeType === 1 ) {\n\t\t\t\tif( 'html-static' in node.attributes ) {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\tif( node.base && node !== parent ) {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n})\n","import Component from './component'\nimport { purge, rAF } from './utils'\n\nexport default function Element(module, dependencies, templates, components) {\n\treturn class extends HTMLElement {\n\n\t\tbase: any\n\t\toptions: any\n\t\treturns : any\n\t\t__events: any\n\n\t\tconstructor() {\n\n\t\t\tsuper()\n\t\t\tconst { base, options } = Component(this, { module, dependencies, templates, components })\n\n\t\t\tthis.base = base\n\t\t\tthis.options = options\n\t\t\tthis.returns = module.default(base)\n\t\t}\n\n\t\tconnectedCallback() {\n\n\t\t\tthis.base.render()\n\n\t\t\tif( this.__template && this.__template.constructor === Promise ) {\n\t\t\t\tthis.__template.then( _ => {\n\t\t\t\t\tif( this.base && this.options.main) {\n\t\t\t\t\t\tconst array = this.options.main(this.base)\n\t\t\t\t\t\tif( array && array.length ){\n\t\t\t\t\t\t\tarray.forEach(f => f(this.base))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif( this.returns && this.returns.constructor === Promise ) {\n\t\t\t\tthis.returns.then( _ => {\n\t\t\t\t\tif( this.base && this.options.main) {\n\t\t\t\t\t\tconst array = this.options.main(this.base)\n\t\t\t\t\t\tif( array && array.length ){\n\t\t\t\t\t\t\tarray.forEach(f => f(this.base))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}else {\n\t\t\t\tif( this.base && this.options.main ){\n\t\t\t\t\tconst array = this.options.main(this.base)\n\t\t\t\t\tif( array && array.length ) {\n\t\t\t\t\t\tarray.forEach(f => f(this.base))\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdisconnectedCallback() {\n\t\t\tthis.options.unmount(this.base)\n\t\t\trAF(() => {\n\t\t\t\tif(!document.body.contains(this) ) {\n\t\t\t\t\tthis.__events? this.__events = null : null\n\t\t\t\t\tthis.base? this.base.elm = null : null\n\t\t\t\t\tthis.base? this.base = null : null\n\t\t\t\t\tpurge(this)\n\t\t\t\t}\n\t\t\t})\n\n\t\t}\n\n\t\tattributeChangedCallback() {\n\t\t\t//TODO\n\t\t}\n\t}\n}\n","import { templateConfig, buildtemplates } from './template-system'\nimport { publish, subscribe } from './utils/pubsub'\nimport { html } from './utils'\nimport Element from './element'\n\nconst templates = {}\nconst components = {}\n\nexport { html }\n\nexport default {\n\n\ttemplateConfig,\n\n\tpublish,\n\tsubscribe,\n\n\tregister( name, module, dependencies = {} ) {\n\t\tcomponents[name] = { name, module, dependencies }\n\t},\n\n\tstart( target = document.body ) {\n\t\tconst keys = Object.keys(components)\n\t\tconst selector = keys.toString()\n\t\tif( keys.length ) {\n\t\t\tbuildtemplates( target, selector, templates, components )\n\t\t\tregisterComponents()\n\t\t}\n\t}\n}\n\nconst registerComponents = () => {\n\tObject\n\t\t.values( components )\n\t\t.forEach( (component) => {\n\t\t\tconst { name, module, dependencies } = component as any\n\t\t\tif( !customElements.get(name) ){\n\t\t\t\tconst Base = Element(module, dependencies, templates, components)\n\t\t\t\tcustomElements.define(name, Base)\n\t\t\t}\n\t\t})\n}\n"],"names":["parser","DOMParser","wrap","open","node","close","_a","parentNode","insertBefore","_b","nextSibling","textarea","document","createElement","decodeHTML","text","innerHTML","value","rAF","fn","requestAnimationFrame","setTimeout","dup","o","JSON","parse","stringify","purge","d","i","l","n","a","attributes","length","name","childNodes","safe","execute","val","err","config","tags","Template","element","html","regexTags","RegExp","virtual","parseFromString","replace","querySelectorAll","forEach","htmlForeach","getAttribute","htmlFor","htmlIf","htmlInner","htmlClass","forEachInstruction","selector","split","match","varname","object","removeAttribute","setAttribute","script","dataset","scope","type","appendChild","createTextNode","className","trim","body","all","key","Transpile","outerHTML","decodedHTML","Function","_","variable","buildtemplates","target","templates","components","concat","matches","Array","from","reverse","template","content","createTemplateId","id","c","r","Math","random","toString","localName","module","constructor","Promise","__template","then","htmlstring","topics","_async","publish","params","Object","assign","topic","subscribe","method","push","filter","Idiomorph","EMPTY_SET","Set","defaults","morphStyle","callbacks","beforeNodeAdded","noOp","afterNodeAdded","beforeNodeMorphed","afterNodeMorphed","beforeNodeRemoved","afterNodeRemoved","beforeAttributeUpdated","head","style","shouldPreserve","elt","shouldReAppend","shouldRemove","afterHeadMorphed","morphNormalizedContent","oldNode","normalizedNewContent","ctx","block","oldHead","querySelector","newHead","promises","handleHeadElement","ignore","morphChildren","children","bestMatch","newContent","currentElement","firstChild","bestElement","score","newScore","scoreElement","findBestNodeMatch","previousSibling","morphedNode","morphOldNodeTo","stack","added","pop","parentElement","insertSiblings","ignoreValueOfActiveElement","possibleActiveElement","ignoreActiveValue","activeElement","ignoreActive","remove","isSoftMatch","HTMLHeadElement","to","nodeType","fromAttributes","toAttributes","fromAttribute","ignoreAttribute","toAttribute","hasAttribute","nodeValue","HTMLInputElement","fromValue","toValue","syncBooleanAttribute","HTMLOptionElement","HTMLTextAreaElement","syncInputValue","syncNodeFrom","replaceChild","newParent","oldParent","newChild","nextNewChild","insertionPoint","removeIdsFromConsideration","isIdSetMatch","idSetMatch","findIdSetMatch","removeNodesBetween","softMatch","findSoftMatch","tempNode","removeNode","attr","updateType","attributeName","ignoreUpdate","newHeadTag","currentHead","removed","preserved","nodesToAppend","headMergeStyle","srcToNewHeadNodes","Map","newHeadChild","set","currentHeadElt","inNewContent","has","isReAppended","isPreserved","delete","values","newNode","newElt","createRange","createContextualFragment","href","src","resolve","promise","_resolve","addEventListener","removedElement","removeChild","kept","node1","node2","tagName","getIdIntersectionCount","startInclusive","endExclusive","newChildPotentialIdCount","potentialMatch","otherMatchCount","potentialSoftMatch","siblingSoftMatchCount","isIdInConsideration","deadIds","idIsWithinNode","targetNode","idMap","get","idSet","add","sourceSet","matchCount","populateIdMapForNode","nodeParent","idElements","current","createIdMap","oldContent","morph","Document","documentElement","contentWithSvgsRemoved","generatedByIdiomorph","htmlElement","parseContent","normalizedContent","Node","dummyParent","append","normalizeContent","finalConfig","mergeDefaults","createMorphContext","customEvent","window","CustomEvent","data","newEvent","createEvent","initCustomEvent","handler","ev","e","this","detail","__events","apply","args","removeListener","listener","removeEventListener","delegate","callback","parent","delegateTarget","on","selectorOrCallback","call","off","old","trigger","dispatchEvent","bubbles","getOptions","main","unmount","onupdate","view","updateScope","scopeElement","cp","___scope___","lastElementChild","IdiomorphOptions","base","Element","dependencies","HTMLElement","options","elm","initialState","keys","tplid","state","model","eventName","String","emit","shift","newstate","render","getRaw","contains","newdata","newhtml","child","props","html_","clone","cloneNode","Component","returns","default","connectedCallback","array","f","disconnectedCallback","attributeChangedCallback","index","templateConfig","newconfig","register","start","registerComponents","component","customElements","Base","define","literalSections","substs","raw","result","subst","lit","isArray","join"],"mappings":"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","x_google_ignoreList":[4]}