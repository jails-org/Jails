{"version":3,"file":"jails.js","sources":["../src/utils/index.ts","../src/utils/pubsub.ts","../node_modules/morphdom/dist/morphdom-esm.js","../src/component.ts","../src/element.ts","../src/template-system.ts","../src/index.ts"],"sourcesContent":["let textarea\n\nexport const g = {\n\tscope: {}\n}\n\nexport const decodeHTML = (text) => {\n\ttextarea = textarea || document.createElement('textarea')\n\ttextarea.innerHTML = text\n\treturn textarea.value\n}\n\nexport const rAF = (fn) => {\n\tif (requestAnimationFrame)\n\t\treturn requestAnimationFrame(fn)\n\telse\n\t\treturn setTimeout(fn, 1000 / 60)\n}\n\nexport const uuid = () => {\n\treturn Math.random().toString(36).substring(2, 9)\n}\n\nexport const dup = (o) => {\n\treturn JSON.parse(JSON.stringify(o))\n}\n\nexport const safe = (execute, val) => {\n\ttry{\n\t\tconst value = execute()\n\t\treturn value !== undefined && value !== null ? value : val || ''\n\t}catch(err){\n\t\treturn val || ''\n\t}\n}\n","\nconst topics: any = {}\nconst _async: any = {}\n\nexport const publish = (name, params) => {\n\n\t_async[name] = isObject(params)? Object.assign({}, _async[name], params): params\n\n\tif (topics[name]) {\n\t\ttopics[name].forEach(topic => topic(params))\n\t}\n}\n\nexport const subscribe = (name, method) => {\n\ttopics[name] = topics[name] || []\n\ttopics[name].push(method)\n\tif (name in _async) {\n\t\tmethod(_async[name])\n\t}\n\treturn () => {\n\t\ttopics[name] = topics[name].filter( fn => fn != method )\n\t}\n}\n\nconst isObject = (value) => {\n\treturn (typeof value === 'object' && value !== null && !Array.isArray(value))\n}\n","var DOCUMENT_FRAGMENT_NODE = 11;\n\nfunction morphAttrs(fromNode, toNode) {\n    var toNodeAttrs = toNode.attributes;\n    var attr;\n    var attrName;\n    var attrNamespaceURI;\n    var attrValue;\n    var fromValue;\n\n    // document-fragments dont have attributes so lets not do anything\n    if (toNode.nodeType === DOCUMENT_FRAGMENT_NODE || fromNode.nodeType === DOCUMENT_FRAGMENT_NODE) {\n      return;\n    }\n\n    // update attributes on original DOM element\n    for (var i = toNodeAttrs.length - 1; i >= 0; i--) {\n        attr = toNodeAttrs[i];\n        attrName = attr.name;\n        attrNamespaceURI = attr.namespaceURI;\n        attrValue = attr.value;\n\n        if (attrNamespaceURI) {\n            attrName = attr.localName || attrName;\n            fromValue = fromNode.getAttributeNS(attrNamespaceURI, attrName);\n\n            if (fromValue !== attrValue) {\n                if (attr.prefix === 'xmlns'){\n                    attrName = attr.name; // It's not allowed to set an attribute with the XMLNS namespace without specifying the `xmlns` prefix\n                }\n                fromNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);\n            }\n        } else {\n            fromValue = fromNode.getAttribute(attrName);\n\n            if (fromValue !== attrValue) {\n                fromNode.setAttribute(attrName, attrValue);\n            }\n        }\n    }\n\n    // Remove any extra attributes found on the original DOM element that\n    // weren't found on the target element.\n    var fromNodeAttrs = fromNode.attributes;\n\n    for (var d = fromNodeAttrs.length - 1; d >= 0; d--) {\n        attr = fromNodeAttrs[d];\n        attrName = attr.name;\n        attrNamespaceURI = attr.namespaceURI;\n\n        if (attrNamespaceURI) {\n            attrName = attr.localName || attrName;\n\n            if (!toNode.hasAttributeNS(attrNamespaceURI, attrName)) {\n                fromNode.removeAttributeNS(attrNamespaceURI, attrName);\n            }\n        } else {\n            if (!toNode.hasAttribute(attrName)) {\n                fromNode.removeAttribute(attrName);\n            }\n        }\n    }\n}\n\nvar range; // Create a range object for efficently rendering strings to elements.\nvar NS_XHTML = 'http://www.w3.org/1999/xhtml';\n\nvar doc = typeof document === 'undefined' ? undefined : document;\nvar HAS_TEMPLATE_SUPPORT = !!doc && 'content' in doc.createElement('template');\nvar HAS_RANGE_SUPPORT = !!doc && doc.createRange && 'createContextualFragment' in doc.createRange();\n\nfunction createFragmentFromTemplate(str) {\n    var template = doc.createElement('template');\n    template.innerHTML = str;\n    return template.content.childNodes[0];\n}\n\nfunction createFragmentFromRange(str) {\n    if (!range) {\n        range = doc.createRange();\n        range.selectNode(doc.body);\n    }\n\n    var fragment = range.createContextualFragment(str);\n    return fragment.childNodes[0];\n}\n\nfunction createFragmentFromWrap(str) {\n    var fragment = doc.createElement('body');\n    fragment.innerHTML = str;\n    return fragment.childNodes[0];\n}\n\n/**\n * This is about the same\n * var html = new DOMParser().parseFromString(str, 'text/html');\n * return html.body.firstChild;\n *\n * @method toElement\n * @param {String} str\n */\nfunction toElement(str) {\n    str = str.trim();\n    if (HAS_TEMPLATE_SUPPORT) {\n      // avoid restrictions on content for things like `<tr><th>Hi</th></tr>` which\n      // createContextualFragment doesn't support\n      // <template> support not available in IE\n      return createFragmentFromTemplate(str);\n    } else if (HAS_RANGE_SUPPORT) {\n      return createFragmentFromRange(str);\n    }\n\n    return createFragmentFromWrap(str);\n}\n\n/**\n * Returns true if two node's names are the same.\n *\n * NOTE: We don't bother checking `namespaceURI` because you will never find two HTML elements with the same\n *       nodeName and different namespace URIs.\n *\n * @param {Element} a\n * @param {Element} b The target element\n * @return {boolean}\n */\nfunction compareNodeNames(fromEl, toEl) {\n    var fromNodeName = fromEl.nodeName;\n    var toNodeName = toEl.nodeName;\n    var fromCodeStart, toCodeStart;\n\n    if (fromNodeName === toNodeName) {\n        return true;\n    }\n\n    fromCodeStart = fromNodeName.charCodeAt(0);\n    toCodeStart = toNodeName.charCodeAt(0);\n\n    // If the target element is a virtual DOM node or SVG node then we may\n    // need to normalize the tag name before comparing. Normal HTML elements that are\n    // in the \"http://www.w3.org/1999/xhtml\"\n    // are converted to upper case\n    if (fromCodeStart <= 90 && toCodeStart >= 97) { // from is upper and to is lower\n        return fromNodeName === toNodeName.toUpperCase();\n    } else if (toCodeStart <= 90 && fromCodeStart >= 97) { // to is upper and from is lower\n        return toNodeName === fromNodeName.toUpperCase();\n    } else {\n        return false;\n    }\n}\n\n/**\n * Create an element, optionally with a known namespace URI.\n *\n * @param {string} name the element name, e.g. 'div' or 'svg'\n * @param {string} [namespaceURI] the element's namespace URI, i.e. the value of\n * its `xmlns` attribute or its inferred namespace.\n *\n * @return {Element}\n */\nfunction createElementNS(name, namespaceURI) {\n    return !namespaceURI || namespaceURI === NS_XHTML ?\n        doc.createElement(name) :\n        doc.createElementNS(namespaceURI, name);\n}\n\n/**\n * Copies the children of one DOM element to another DOM element\n */\nfunction moveChildren(fromEl, toEl) {\n    var curChild = fromEl.firstChild;\n    while (curChild) {\n        var nextChild = curChild.nextSibling;\n        toEl.appendChild(curChild);\n        curChild = nextChild;\n    }\n    return toEl;\n}\n\nfunction syncBooleanAttrProp(fromEl, toEl, name) {\n    if (fromEl[name] !== toEl[name]) {\n        fromEl[name] = toEl[name];\n        if (fromEl[name]) {\n            fromEl.setAttribute(name, '');\n        } else {\n            fromEl.removeAttribute(name);\n        }\n    }\n}\n\nvar specialElHandlers = {\n    OPTION: function(fromEl, toEl) {\n        var parentNode = fromEl.parentNode;\n        if (parentNode) {\n            var parentName = parentNode.nodeName.toUpperCase();\n            if (parentName === 'OPTGROUP') {\n                parentNode = parentNode.parentNode;\n                parentName = parentNode && parentNode.nodeName.toUpperCase();\n            }\n            if (parentName === 'SELECT' && !parentNode.hasAttribute('multiple')) {\n                if (fromEl.hasAttribute('selected') && !toEl.selected) {\n                    // Workaround for MS Edge bug where the 'selected' attribute can only be\n                    // removed if set to a non-empty value:\n                    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12087679/\n                    fromEl.setAttribute('selected', 'selected');\n                    fromEl.removeAttribute('selected');\n                }\n                // We have to reset select element's selectedIndex to -1, otherwise setting\n                // fromEl.selected using the syncBooleanAttrProp below has no effect.\n                // The correct selectedIndex will be set in the SELECT special handler below.\n                parentNode.selectedIndex = -1;\n            }\n        }\n        syncBooleanAttrProp(fromEl, toEl, 'selected');\n    },\n    /**\n     * The \"value\" attribute is special for the <input> element since it sets\n     * the initial value. Changing the \"value\" attribute without changing the\n     * \"value\" property will have no effect since it is only used to the set the\n     * initial value.  Similar for the \"checked\" attribute, and \"disabled\".\n     */\n    INPUT: function(fromEl, toEl) {\n        syncBooleanAttrProp(fromEl, toEl, 'checked');\n        syncBooleanAttrProp(fromEl, toEl, 'disabled');\n\n        if (fromEl.value !== toEl.value) {\n            fromEl.value = toEl.value;\n        }\n\n        if (!toEl.hasAttribute('value')) {\n            fromEl.removeAttribute('value');\n        }\n    },\n\n    TEXTAREA: function(fromEl, toEl) {\n        var newValue = toEl.value;\n        if (fromEl.value !== newValue) {\n            fromEl.value = newValue;\n        }\n\n        var firstChild = fromEl.firstChild;\n        if (firstChild) {\n            // Needed for IE. Apparently IE sets the placeholder as the\n            // node value and vise versa. This ignores an empty update.\n            var oldValue = firstChild.nodeValue;\n\n            if (oldValue == newValue || (!newValue && oldValue == fromEl.placeholder)) {\n                return;\n            }\n\n            firstChild.nodeValue = newValue;\n        }\n    },\n    SELECT: function(fromEl, toEl) {\n        if (!toEl.hasAttribute('multiple')) {\n            var selectedIndex = -1;\n            var i = 0;\n            // We have to loop through children of fromEl, not toEl since nodes can be moved\n            // from toEl to fromEl directly when morphing.\n            // At the time this special handler is invoked, all children have already been morphed\n            // and appended to / removed from fromEl, so using fromEl here is safe and correct.\n            var curChild = fromEl.firstChild;\n            var optgroup;\n            var nodeName;\n            while(curChild) {\n                nodeName = curChild.nodeName && curChild.nodeName.toUpperCase();\n                if (nodeName === 'OPTGROUP') {\n                    optgroup = curChild;\n                    curChild = optgroup.firstChild;\n                    // handle empty optgroups\n                    if (!curChild) {\n                        curChild = optgroup.nextSibling;\n                        optgroup = null;\n                    }\n                } else {\n                    if (nodeName === 'OPTION') {\n                        if (curChild.hasAttribute('selected')) {\n                            selectedIndex = i;\n                            break;\n                        }\n                        i++;\n                    }\n                    curChild = curChild.nextSibling;\n                    if (!curChild && optgroup) {\n                        curChild = optgroup.nextSibling;\n                        optgroup = null;\n                    }\n                }\n            }\n\n            fromEl.selectedIndex = selectedIndex;\n        }\n    }\n};\n\nvar ELEMENT_NODE = 1;\nvar DOCUMENT_FRAGMENT_NODE$1 = 11;\nvar TEXT_NODE = 3;\nvar COMMENT_NODE = 8;\n\nfunction noop() {}\n\nfunction defaultGetNodeKey(node) {\n  if (node) {\n    return (node.getAttribute && node.getAttribute('id')) || node.id;\n  }\n}\n\nfunction morphdomFactory(morphAttrs) {\n\n  return function morphdom(fromNode, toNode, options) {\n    if (!options) {\n      options = {};\n    }\n\n    if (typeof toNode === 'string') {\n      if (fromNode.nodeName === '#document' || fromNode.nodeName === 'HTML' || fromNode.nodeName === 'BODY') {\n        var toNodeHtml = toNode;\n        toNode = doc.createElement('html');\n        toNode.innerHTML = toNodeHtml;\n      } else {\n        toNode = toElement(toNode);\n      }\n    } else if (toNode.nodeType === DOCUMENT_FRAGMENT_NODE$1) {\n      toNode = toNode.firstElementChild;\n    }\n\n    var getNodeKey = options.getNodeKey || defaultGetNodeKey;\n    var onBeforeNodeAdded = options.onBeforeNodeAdded || noop;\n    var onNodeAdded = options.onNodeAdded || noop;\n    var onBeforeElUpdated = options.onBeforeElUpdated || noop;\n    var onElUpdated = options.onElUpdated || noop;\n    var onBeforeNodeDiscarded = options.onBeforeNodeDiscarded || noop;\n    var onNodeDiscarded = options.onNodeDiscarded || noop;\n    var onBeforeElChildrenUpdated = options.onBeforeElChildrenUpdated || noop;\n    var skipFromChildren = options.skipFromChildren || noop;\n    var addChild = options.addChild || function(parent, child){ return parent.appendChild(child); };\n    var childrenOnly = options.childrenOnly === true;\n\n    // This object is used as a lookup to quickly find all keyed elements in the original DOM tree.\n    var fromNodesLookup = Object.create(null);\n    var keyedRemovalList = [];\n\n    function addKeyedRemoval(key) {\n      keyedRemovalList.push(key);\n    }\n\n    function walkDiscardedChildNodes(node, skipKeyedNodes) {\n      if (node.nodeType === ELEMENT_NODE) {\n        var curChild = node.firstChild;\n        while (curChild) {\n\n          var key = undefined;\n\n          if (skipKeyedNodes && (key = getNodeKey(curChild))) {\n            // If we are skipping keyed nodes then we add the key\n            // to a list so that it can be handled at the very end.\n            addKeyedRemoval(key);\n          } else {\n            // Only report the node as discarded if it is not keyed. We do this because\n            // at the end we loop through all keyed elements that were unmatched\n            // and then discard them in one final pass.\n            onNodeDiscarded(curChild);\n            if (curChild.firstChild) {\n              walkDiscardedChildNodes(curChild, skipKeyedNodes);\n            }\n          }\n\n          curChild = curChild.nextSibling;\n        }\n      }\n    }\n\n    /**\n    * Removes a DOM node out of the original DOM\n    *\n    * @param  {Node} node The node to remove\n    * @param  {Node} parentNode The nodes parent\n    * @param  {Boolean} skipKeyedNodes If true then elements with keys will be skipped and not discarded.\n    * @return {undefined}\n    */\n    function removeNode(node, parentNode, skipKeyedNodes) {\n      if (onBeforeNodeDiscarded(node) === false) {\n        return;\n      }\n\n      if (parentNode) {\n        parentNode.removeChild(node);\n      }\n\n      onNodeDiscarded(node);\n      walkDiscardedChildNodes(node, skipKeyedNodes);\n    }\n\n    // // TreeWalker implementation is no faster, but keeping this around in case this changes in the future\n    // function indexTree(root) {\n    //     var treeWalker = document.createTreeWalker(\n    //         root,\n    //         NodeFilter.SHOW_ELEMENT);\n    //\n    //     var el;\n    //     while((el = treeWalker.nextNode())) {\n    //         var key = getNodeKey(el);\n    //         if (key) {\n    //             fromNodesLookup[key] = el;\n    //         }\n    //     }\n    // }\n\n    // // NodeIterator implementation is no faster, but keeping this around in case this changes in the future\n    //\n    // function indexTree(node) {\n    //     var nodeIterator = document.createNodeIterator(node, NodeFilter.SHOW_ELEMENT);\n    //     var el;\n    //     while((el = nodeIterator.nextNode())) {\n    //         var key = getNodeKey(el);\n    //         if (key) {\n    //             fromNodesLookup[key] = el;\n    //         }\n    //     }\n    // }\n\n    function indexTree(node) {\n      if (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE$1) {\n        var curChild = node.firstChild;\n        while (curChild) {\n          var key = getNodeKey(curChild);\n          if (key) {\n            fromNodesLookup[key] = curChild;\n          }\n\n          // Walk recursively\n          indexTree(curChild);\n\n          curChild = curChild.nextSibling;\n        }\n      }\n    }\n\n    indexTree(fromNode);\n\n    function handleNodeAdded(el) {\n      onNodeAdded(el);\n\n      var curChild = el.firstChild;\n      while (curChild) {\n        var nextSibling = curChild.nextSibling;\n\n        var key = getNodeKey(curChild);\n        if (key) {\n          var unmatchedFromEl = fromNodesLookup[key];\n          // if we find a duplicate #id node in cache, replace `el` with cache value\n          // and morph it to the child node.\n          if (unmatchedFromEl && compareNodeNames(curChild, unmatchedFromEl)) {\n            curChild.parentNode.replaceChild(unmatchedFromEl, curChild);\n            morphEl(unmatchedFromEl, curChild);\n          } else {\n            handleNodeAdded(curChild);\n          }\n        } else {\n          // recursively call for curChild and it's children to see if we find something in\n          // fromNodesLookup\n          handleNodeAdded(curChild);\n        }\n\n        curChild = nextSibling;\n      }\n    }\n\n    function cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey) {\n      // We have processed all of the \"to nodes\". If curFromNodeChild is\n      // non-null then we still have some from nodes left over that need\n      // to be removed\n      while (curFromNodeChild) {\n        var fromNextSibling = curFromNodeChild.nextSibling;\n        if ((curFromNodeKey = getNodeKey(curFromNodeChild))) {\n          // Since the node is keyed it might be matched up later so we defer\n          // the actual removal to later\n          addKeyedRemoval(curFromNodeKey);\n        } else {\n          // NOTE: we skip nested keyed nodes from being removed since there is\n          //       still a chance they will be matched up later\n          removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n        }\n        curFromNodeChild = fromNextSibling;\n      }\n    }\n\n    function morphEl(fromEl, toEl, childrenOnly) {\n      var toElKey = getNodeKey(toEl);\n\n      if (toElKey) {\n        // If an element with an ID is being morphed then it will be in the final\n        // DOM so clear it out of the saved elements collection\n        delete fromNodesLookup[toElKey];\n      }\n\n      if (!childrenOnly) {\n        // optional\n        var beforeUpdateResult = onBeforeElUpdated(fromEl, toEl);\n        if (beforeUpdateResult === false) {\n          return;\n        } else if (beforeUpdateResult instanceof HTMLElement) {\n          fromEl = beforeUpdateResult;\n          // reindex the new fromEl in case it's not in the same\n          // tree as the original fromEl\n          // (Phoenix LiveView sometimes returns a cloned tree,\n          //  but keyed lookups would still point to the original tree)\n          indexTree(fromEl);\n        }\n\n        // update attributes on original DOM element first\n        morphAttrs(fromEl, toEl);\n        // optional\n        onElUpdated(fromEl);\n\n        if (onBeforeElChildrenUpdated(fromEl, toEl) === false) {\n          return;\n        }\n      }\n\n      if (fromEl.nodeName !== 'TEXTAREA') {\n        morphChildren(fromEl, toEl);\n      } else {\n        specialElHandlers.TEXTAREA(fromEl, toEl);\n      }\n    }\n\n    function morphChildren(fromEl, toEl) {\n      var skipFrom = skipFromChildren(fromEl, toEl);\n      var curToNodeChild = toEl.firstChild;\n      var curFromNodeChild = fromEl.firstChild;\n      var curToNodeKey;\n      var curFromNodeKey;\n\n      var fromNextSibling;\n      var toNextSibling;\n      var matchingFromEl;\n\n      // walk the children\n      outer: while (curToNodeChild) {\n        toNextSibling = curToNodeChild.nextSibling;\n        curToNodeKey = getNodeKey(curToNodeChild);\n\n        // walk the fromNode children all the way through\n        while (!skipFrom && curFromNodeChild) {\n          fromNextSibling = curFromNodeChild.nextSibling;\n\n          if (curToNodeChild.isSameNode && curToNodeChild.isSameNode(curFromNodeChild)) {\n            curToNodeChild = toNextSibling;\n            curFromNodeChild = fromNextSibling;\n            continue outer;\n          }\n\n          curFromNodeKey = getNodeKey(curFromNodeChild);\n\n          var curFromNodeType = curFromNodeChild.nodeType;\n\n          // this means if the curFromNodeChild doesnt have a match with the curToNodeChild\n          var isCompatible = undefined;\n\n          if (curFromNodeType === curToNodeChild.nodeType) {\n            if (curFromNodeType === ELEMENT_NODE) {\n              // Both nodes being compared are Element nodes\n\n              if (curToNodeKey) {\n                // The target node has a key so we want to match it up with the correct element\n                // in the original DOM tree\n                if (curToNodeKey !== curFromNodeKey) {\n                  // The current element in the original DOM tree does not have a matching key so\n                  // let's check our lookup to see if there is a matching element in the original\n                  // DOM tree\n                  if ((matchingFromEl = fromNodesLookup[curToNodeKey])) {\n                    if (fromNextSibling === matchingFromEl) {\n                      // Special case for single element removals. To avoid removing the original\n                      // DOM node out of the tree (since that can break CSS transitions, etc.),\n                      // we will instead discard the current node and wait until the next\n                      // iteration to properly match up the keyed target element with its matching\n                      // element in the original tree\n                      isCompatible = false;\n                    } else {\n                      // We found a matching keyed element somewhere in the original DOM tree.\n                      // Let's move the original DOM node into the current position and morph\n                      // it.\n\n                      // NOTE: We use insertBefore instead of replaceChild because we want to go through\n                      // the `removeNode()` function for the node that is being discarded so that\n                      // all lifecycle hooks are correctly invoked\n                      fromEl.insertBefore(matchingFromEl, curFromNodeChild);\n\n                      // fromNextSibling = curFromNodeChild.nextSibling;\n\n                      if (curFromNodeKey) {\n                        // Since the node is keyed it might be matched up later so we defer\n                        // the actual removal to later\n                        addKeyedRemoval(curFromNodeKey);\n                      } else {\n                        // NOTE: we skip nested keyed nodes from being removed since there is\n                        //       still a chance they will be matched up later\n                        removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n                      }\n\n                      curFromNodeChild = matchingFromEl;\n                      curFromNodeKey = getNodeKey(curFromNodeChild);\n                    }\n                  } else {\n                    // The nodes are not compatible since the \"to\" node has a key and there\n                    // is no matching keyed node in the source tree\n                    isCompatible = false;\n                  }\n                }\n              } else if (curFromNodeKey) {\n                // The original has a key\n                isCompatible = false;\n              }\n\n              isCompatible = isCompatible !== false && compareNodeNames(curFromNodeChild, curToNodeChild);\n              if (isCompatible) {\n                // We found compatible DOM elements so transform\n                // the current \"from\" node to match the current\n                // target DOM node.\n                // MORPH\n                morphEl(curFromNodeChild, curToNodeChild);\n              }\n\n            } else if (curFromNodeType === TEXT_NODE || curFromNodeType == COMMENT_NODE) {\n              // Both nodes being compared are Text or Comment nodes\n              isCompatible = true;\n              // Simply update nodeValue on the original node to\n              // change the text value\n              if (curFromNodeChild.nodeValue !== curToNodeChild.nodeValue) {\n                curFromNodeChild.nodeValue = curToNodeChild.nodeValue;\n              }\n\n            }\n          }\n\n          if (isCompatible) {\n            // Advance both the \"to\" child and the \"from\" child since we found a match\n            // Nothing else to do as we already recursively called morphChildren above\n            curToNodeChild = toNextSibling;\n            curFromNodeChild = fromNextSibling;\n            continue outer;\n          }\n\n          // No compatible match so remove the old node from the DOM and continue trying to find a\n          // match in the original DOM. However, we only do this if the from node is not keyed\n          // since it is possible that a keyed node might match up with a node somewhere else in the\n          // target tree and we don't want to discard it just yet since it still might find a\n          // home in the final DOM tree. After everything is done we will remove any keyed nodes\n          // that didn't find a home\n          if (curFromNodeKey) {\n            // Since the node is keyed it might be matched up later so we defer\n            // the actual removal to later\n            addKeyedRemoval(curFromNodeKey);\n          } else {\n            // NOTE: we skip nested keyed nodes from being removed since there is\n            //       still a chance they will be matched up later\n            removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n          }\n\n          curFromNodeChild = fromNextSibling;\n        } // END: while(curFromNodeChild) {}\n\n        // If we got this far then we did not find a candidate match for\n        // our \"to node\" and we exhausted all of the children \"from\"\n        // nodes. Therefore, we will just append the current \"to\" node\n        // to the end\n        if (curToNodeKey && (matchingFromEl = fromNodesLookup[curToNodeKey]) && compareNodeNames(matchingFromEl, curToNodeChild)) {\n          // MORPH\n          if(!skipFrom){ addChild(fromEl, matchingFromEl); }\n          morphEl(matchingFromEl, curToNodeChild);\n        } else {\n          var onBeforeNodeAddedResult = onBeforeNodeAdded(curToNodeChild);\n          if (onBeforeNodeAddedResult !== false) {\n            if (onBeforeNodeAddedResult) {\n              curToNodeChild = onBeforeNodeAddedResult;\n            }\n\n            if (curToNodeChild.actualize) {\n              curToNodeChild = curToNodeChild.actualize(fromEl.ownerDocument || doc);\n            }\n            addChild(fromEl, curToNodeChild);\n            handleNodeAdded(curToNodeChild);\n          }\n        }\n\n        curToNodeChild = toNextSibling;\n        curFromNodeChild = fromNextSibling;\n      }\n\n      cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey);\n\n      var specialElHandler = specialElHandlers[fromEl.nodeName];\n      if (specialElHandler) {\n        specialElHandler(fromEl, toEl);\n      }\n    } // END: morphChildren(...)\n\n    var morphedNode = fromNode;\n    var morphedNodeType = morphedNode.nodeType;\n    var toNodeType = toNode.nodeType;\n\n    if (!childrenOnly) {\n      // Handle the case where we are given two DOM nodes that are not\n      // compatible (e.g. <div> --> <span> or <div> --> TEXT)\n      if (morphedNodeType === ELEMENT_NODE) {\n        if (toNodeType === ELEMENT_NODE) {\n          if (!compareNodeNames(fromNode, toNode)) {\n            onNodeDiscarded(fromNode);\n            morphedNode = moveChildren(fromNode, createElementNS(toNode.nodeName, toNode.namespaceURI));\n          }\n        } else {\n          // Going from an element node to a text node\n          morphedNode = toNode;\n        }\n      } else if (morphedNodeType === TEXT_NODE || morphedNodeType === COMMENT_NODE) { // Text or comment node\n        if (toNodeType === morphedNodeType) {\n          if (morphedNode.nodeValue !== toNode.nodeValue) {\n            morphedNode.nodeValue = toNode.nodeValue;\n          }\n\n          return morphedNode;\n        } else {\n          // Text node to something else\n          morphedNode = toNode;\n        }\n      }\n    }\n\n    if (morphedNode === toNode) {\n      // The \"to node\" was not compatible with the \"from node\" so we had to\n      // toss out the \"from node\" and use the \"to node\"\n      onNodeDiscarded(fromNode);\n    } else {\n      if (toNode.isSameNode && toNode.isSameNode(morphedNode)) {\n        return;\n      }\n\n      morphEl(morphedNode, toNode, childrenOnly);\n\n      // We now need to loop over any keyed nodes that might need to be\n      // removed. We only do the removal if we know that the keyed node\n      // never found a match. When a keyed node is matched up we remove\n      // it out of fromNodesLookup and we use fromNodesLookup to determine\n      // if a keyed node has been matched up or not\n      if (keyedRemovalList) {\n        for (var i=0, len=keyedRemovalList.length; i<len; i++) {\n          var elToRemove = fromNodesLookup[keyedRemovalList[i]];\n          if (elToRemove) {\n            removeNode(elToRemove, elToRemove.parentNode, false);\n          }\n        }\n      }\n    }\n\n    if (!childrenOnly && morphedNode !== fromNode && fromNode.parentNode) {\n      if (morphedNode.actualize) {\n        morphedNode = morphedNode.actualize(fromNode.ownerDocument || doc);\n      }\n      // If we had to swap out the from node with a new node because the old\n      // node was not compatible with the target node then we need to\n      // replace the old DOM node in the original DOM tree. This is only\n      // possible if the original DOM node was part of a DOM tree which\n      // we know is the case if it has a parent node.\n      fromNode.parentNode.replaceChild(morphedNode, fromNode);\n    }\n\n    return morphedNode;\n  };\n}\n\nvar morphdom = morphdomFactory(morphAttrs);\n\nexport default morphdom;\n","import { safe, g, dup } from './utils'\nimport { publish, subscribe } from './utils/pubsub'\nimport morphdom from 'morphdom'\n\nexport const Component = ({ name, module, dependencies, node, templates, signal, register }) => {\n\n\tlet tick\n\tlet preserve\t\t= []\n\tlet observer \t\t= null\n\tlet observables \t= []\n\n\tconst _model \t\t= module.model || {}\n\tconst initialState \t= (new Function( `return ${node.getAttribute('html-model') || '{}'}`))()\n\tconst tplid \t\t= node.getAttribute('tplid')\n\tconst scopeid \t\t= node.getAttribute('html-scopeid')\n\tconst tpl \t\t\t= templates[ tplid ]\n\tconst scope \t\t= g.scope[ scopeid ]\n\tconst model  \t\t= dup(module?.model?.apply ? _model({ elm:node, initialState }) : _model)\n\tconst state \t\t= Object.assign({}, scope, model, initialState)\n\tconst view \t\t\t= module.view? module.view : (data) => data\n\n\tconst base = {\n\t\tname,\n\t\tmodel,\n\t\telm: node,\n\t\ttemplate: tpl.template,\n\t\tdependencies,\n\t\tpublish,\n\t\tsubscribe,\n\n\t\tmain(fn) {\n\t\t\tnode.addEventListener(':mount', fn)\n\t\t},\n\n\t\t/**\n\t\t * @State\n\t\t */\n\t\tstate : {\n\n\t\t\tprotected( list ) {\n\t\t\t\tif( list ) {\n\t\t\t\t\tpreserve = list\n\t\t\t\t} else {\n\t\t\t\t\treturn preserve\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tsave(data) {\n\t\t\t\tif( data.constructor === Function ) {\n\t\t\t\t\tdata( state )\n\t\t\t\t} else {\n\t\t\t\t\tObject.assign(state, data)\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tset( data ) {\n\n\t\t\t\tif (!document.body.contains(node)) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif( data.constructor === Function ) {\n\t\t\t\t\tdata(state)\n\t\t\t\t} else {\n\t\t\t\t\tObject.assign(state, data)\n\t\t\t\t}\n\n\t\t\t\tconst newstate = Object.assign({}, state, scope)\n\n\t\t\t\treturn new Promise((resolve) => {\n\t\t\t\t\trender(newstate, () => resolve(newstate))\n\t\t\t\t})\n\t\t\t},\n\n\t\t\tget() {\n\t\t\t\treturn Object.assign({}, state)\n\t\t\t}\n\t\t},\n\n\t\tdataset( target, name ) {\n\n\t\t\tconst el = name? target : node\n\t\t\tconst key = name? name : target\n\t\t\tconst value = el.dataset[key]\n\n\t\t\tif (value === 'true') return true\n\t\t\tif (value === 'false') return false\n\t\t\tif (!isNaN(value) && value.trim() !== '') return Number(value)\n\n\t\t\ttry {\n\t\t\t\treturn new Function('return (' + value + ')')()\n\t\t\t} catch {}\n\n\t\t\ttry {\n\t\t\t\treturn JSON.parse(value)\n\t\t\t} catch {}\n\n\t\t\treturn value\n\t\t},\n\n\t\t/**\n\t\t * @Events\n\t\t */\n\t\ton( ev, selectorOrCallback, callback ) {\n\n\t\t\tconst attribute = ev.match(/\\[(.*)\\]/)\n\n\t\t\tif( attribute ) {\n\t\t\t\tobservables.push({\n\t\t\t\t\ttarget: callback? selectorOrCallback : null,\n\t\t\t\t\tcallback: callback || selectorOrCallback\n\t\t\t\t})\n\n\t\t\t\tif( !observer ) {\n\t\t\t\t\tobserver = new MutationObserver((mutationsList) => {\n\t\t\t\t\t\tfor (const mutation of mutationsList) {\n\t\t\t\t\t\t\tif (mutation.type === 'attributes') {\n\t\t\t\t\t\t\t\tconst attrname = mutation.attributeName\n\t\t\t\t\t\t\t\tif( attrname === attribute[1] ) {\n\t\t\t\t\t\t\t\t\tobservables.forEach( item => {\n\t\t\t\t\t\t\t\t\t\tconst target = item.target? node.querySelectorAll(item.target): [node]\n\t\t\t\t\t\t\t\t\t\ttarget.forEach( target => {\n\t\t\t\t\t\t\t\t\t\t\tif( target == mutation.target ) {\n\t\t\t\t\t\t\t\t\t\t\t\titem.callback({\n\t\t\t\t\t\t\t\t\t\t\t\t\ttarget: mutation.target,\n\t\t\t\t\t\t\t\t\t\t\t\t\tattribute: attrname,\n\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: mutation.target.getAttribute(attrname)\n\t\t\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\n\t\t\t\t\tobserver.observe(node, {\n\t\t\t\t\t\tattributes: true,\n\t\t\t\t\t\tsubtree: true\n\t\t\t\t\t})\n\n\t\t\t\t\tnode.addEventListener(':unmount', () => {\n\t\t\t\t\t\tobservables = []\n\t\t\t\t\t\tobserver.disconnect()\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif( callback ) {\n\t\t\t\tcallback.handler = (e) => {\n\t\t\t\t\tconst detail = e.detail || {}\n\t\t\t\t\tlet parent = e.target\n\t\t\t\t\twhile (parent) {\n\t\t\t\t\t\tif (parent.matches(selectorOrCallback)) {\n\t\t\t\t\t\t\te.delegateTarget = parent\n\t\t\t\t\t\t\tcallback.apply(node, [e].concat(detail.args))\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (parent === node) break\n\t\t\t\t\t\tparent = parent.parentNode\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnode.addEventListener(ev, callback.handler, {\n\t\t\t\t\tsignal,\n\t\t\t\t\tcapture: (ev == 'focus' || ev == 'blur' || ev == 'mouseenter' || ev == 'mouseleave')\n\t\t\t\t})\n\n\t\t\t} else {\n\t\t\t\tselectorOrCallback.handler = (e) => {\n\t\t\t\t\te.delegateTarget = node\n\t\t\t\t\tselectorOrCallback.apply(node, [e].concat(e.detail.args))\n\t\t\t\t}\n\t\t\t\tnode.addEventListener(ev, selectorOrCallback.handler, { signal })\n\t\t\t}\n\n\t\t},\n\n\t\toff( ev, callback ) {\n\t\t\tif( callback.handler ) {\n\t\t\t\tnode.removeEventListener(ev, callback.handler)\n\t\t\t}\n\t\t},\n\n\t\ttrigger(ev, selectorOrCallback, data) {\n\t\t\tif( selectorOrCallback.constructor === String ) {\n\t\t\t\tArray\n\t\t\t\t\t.from(node.querySelectorAll(selectorOrCallback))\n\t\t\t\t\t.forEach( children => {\n\t\t\t\t\t\tchildren.dispatchEvent(new CustomEvent(ev, { bubbles: true, detail: { args: data } }) )\n\t\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tnode.dispatchEvent(new CustomEvent(ev, { bubbles: true, detail:{ args: data } }))\n\t\t\t}\n\t\t},\n\n\t\temit(ev, data) {\n\t\t\tnode.dispatchEvent(new CustomEvent(ev, { bubbles: true, detail: { args: data } }))\n\t\t},\n\n\t\tunmount( fn ) {\n\t\t\tnode.addEventListener(':unmount', fn)\n\t\t},\n\n\t\tinnerHTML ( target, html_ ) {\n\t\t\tconst element = html_? target : node\n\t\t\tconst clone = element.cloneNode()\n\t\t\tconst html = html_? html_ : target\n\t\t\tclone.innerHTML = html\n\t\t\tmorphdom(element, clone)\n\t\t}\n\t}\n\n\tconst render = ( data, callback = (() => {}) ) => {\n\t\tclearTimeout( tick )\n\t\ttick = setTimeout(() => {\n\t\t\tconst html = tpl.render.call({...data, ...view(data)}, node, safe, g )\n\t\t\tmorphdom( node, html, morhdomOptions(node, register) )\n\t\t\tPromise.resolve().then(() => {\n\t\t\t\tnode.querySelectorAll('[tplid]')\n\t\t\t\t\t.forEach((element) => {\n\t\t\t\t\t\tconst child = register.get(element)\n\t\t\t\t\t\tif(!child) return\n\t\t\t\t\t\tchild.state.protected().forEach( key => delete data[key] )\n\t\t\t\t\t\tchild.state.set(data)\n\t\t\t\t\t})\n\t\t\t\tPromise.resolve().then(() => {\n\t\t\t\t\tg.scope = {}\n\t\t\t\t\tcallback()\n\t\t\t\t})\n\t\t\t})\n\t\t})\n\t}\n\n\trender( state )\n\tregister.set( node, base )\n\treturn module.default( base )\n}\n\nconst morhdomOptions = ( parent, register ) => {\n\n\tconst update = ( node ) => {\n\t\tif( node.nodeType === 1 ) {\n\t\t\tif( 'html-static' in node.attributes ) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif( register.get(node) && node !== parent ) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\treturn {\n\t\tonBeforeElChildrenUpdated: update,\n\t\tonBeforeElUpdated: update\n\t}\n}\n","import { Component } from './component'\n\nconst register = new WeakMap()\n\nexport const Element = ({ component, templates, start }) => {\n\n\tconst { name, module, dependencies } = component\n\n\treturn class extends HTMLElement {\n\n\t\tconstructor() {\n\t\t\tsuper()\n\t\t}\n\n\t\tconnectedCallback() {\n\n\t\t\tthis.abortController = new AbortController()\n\n\t\t\tif( !this.getAttribute('tplid') ) {\n\t\t\t\tstart( this.parentNode )\n\t\t\t}\n\n\t\t\tconst rtrn = Component({\n\t\t\t\tnode:this,\n\t\t\t\tname,\n\t\t\t\tmodule,\n\t\t\t\tdependencies,\n\t\t\t\ttemplates,\n\t\t\t\tsignal: this.abortController.signal,\n\t\t\t\tregister\n\t\t\t})\n\n\t\t\tif ( rtrn && rtrn.constructor === Promise ) {\n\t\t\t\trtrn.then(() => {\n\t\t\t\t\tthis.dispatchEvent( new CustomEvent(':mount') )\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tthis.dispatchEvent( new CustomEvent(':mount') )\n\t\t\t}\n\t\t}\n\n\t\tdisconnectedCallback() {\n\t\t\tthis.dispatchEvent( new CustomEvent(':unmount') )\n\t\t\tthis.abortController.abort()\n\t\t}\n\t}\n}\n","import { uuid, decodeHTML } from './utils'\n\nconst config = {\n\ttags: ['{{', '}}']\n}\n\nconst templates  = {}\nconst booleanAttrs = /html-(allowfullscreen|async|autofocus|autoplay|checked|controls|default|defer|disabled|formnovalidate|inert|ismap|itemscope|loop|multiple|muted|nomodule|novalidate|open|playsinline|readonly|required|reversed|selected)=\"(.*?)\"/g\nconst htmlAttr = /html-([^\\s]*?)=\"(.*?)\"/g\nconst tagExpr = () => new RegExp(`\\\\${config.tags[0]}(.+?)\\\\${config.tags[1]}`, 'g')\n\nexport const templateConfig = (newconfig) => {\n\tObject.assign( config, newconfig )\n}\n\nexport const template = ( target, { components }) => {\n\n\ttagElements( target, [...Object.keys( components ), '[html-if]', 'template'], components )\n\tconst clone = target.cloneNode( true )\n\n\ttransformTemplate( clone )\n\tremoveTemplateTagsRecursively( clone )\n\tsetTemplates( clone, components )\n\n\treturn templates\n}\n\nexport const compile = ( html ) => {\n\n\tconst parsedHtml = JSON.stringify( html )\n\n\treturn new Function('$element', 'safe', '$g',`\n\t\tvar $data = this;\n\t\twith( $data ){\n\t\t\tvar output=${parsedHtml\n\t\t\t\t.replace(/%%_=(.+?)_%%/g, function(_, variable){\n\t\t\t\t\treturn '\"+safe(function(){return '+ decodeHTML(variable) +';})+\"'\n\t\t\t\t})\n\t\t\t\t.replace(/%%_(.+?)_%%/g, function(_, variable){\n\t\t\t\t\treturn '\";' + decodeHTML(variable) +'\\noutput+=\"'\n\t\t\t\t})};return output;\n\t\t}\n\t`)\n}\n\nconst tagElements = (target, keys, components) => {\n\tconst isComponent = key => key in components\n\tconst selector = keys.join(',')\n\n\ttarget.querySelectorAll(selector).forEach(node => {\n\t\tif (node.localName === 'template') {\n\t\t\ttagElements(node.content, keys, components)\n\t\t\treturn\n\t\t}\n\t\tif (node.hasAttribute('html-if') && !node.id) {\n\t\t\tnode.id = uuid()\n\t\t}\n\t\tif (isComponent(node.localName)) {\n\t\t\tnode.setAttribute('tplid', uuid())\n\t\t}\n\t})\n}\n\nconst transformAttributes = (html) => {\n\treturn html\n\t\t.replace(/jails___scope-id/g, '%%_=$scopeid_%%')\n\t\t.replace(tagExpr(), '%%_=$1_%%')\n\t\t.replace(booleanAttrs, `%%_if(safe(function(){ return $2 })){_%%$1%%_}_%%`)\n\t\t.replace(htmlAttr, (all, key, value) => {\n\t\t\tif (['key', 'model', 'scopeid'].includes(key)) return all\n\t\t\tif (value) {\n\t\t\t\tvalue = value.replace(/^{|}$/g, '')\n\t\t\t\treturn `${key}=\"%%_=safe(function(){ return ${value} })_%%\"`\n\t\t\t}\n\t\t\treturn all\n\t\t})\n}\n\nconst transformTemplate = ( clone ) => {\n\n\tclone.querySelectorAll('template, [html-for], [html-if], [html-inner], [html-class]')\n\t\t.forEach(( element ) => {\n\n\t\t\tconst htmlFor \t= element.getAttribute('html-for')\n\t\t\tconst htmlIf \t= element.getAttribute('html-if')\n\t\t\tconst htmlInner = element.getAttribute('html-inner')\n\t\t\tconst htmlClass = element.getAttribute('html-class')\n\n\t\t\tif ( htmlFor ) {\n\n\t\t\t\telement.removeAttribute('html-for')\n\n\t\t\t\tconst split \t = htmlFor.match(/(.*)\\sin\\s(.*)/) || ''\n\t\t\t\tconst varname \t = split[1]\n\t\t\t\tconst object \t = split[2]\n\t\t\t\tconst objectname = object.split(/\\./).shift()\n\t\t\t\tconst open \t\t = document.createTextNode(`%%_ ;(function(){ var $index = 0; for(var $key in safe(function(){ return ${object} }) ){ var $scopeid = Math.random().toString(36).substring(2, 9); var ${varname} = ${object}[$key]; $g.scope[$scopeid] = Object.assign({}, { ${objectname}: ${objectname} }, { ${varname} :${varname}, $index: $index, $key: $key }); _%%`)\n\t\t\t\tconst close \t = document.createTextNode(`%%_ $index++; } })() _%%`)\n\n\t\t\t\twrap(open, element, close)\n\t\t\t}\n\n\t\t\tif (htmlIf) {\n\t\t\t\telement.removeAttribute('html-if')\n\t\t\t\tconst open = document.createTextNode(`%%_ if ( safe(function(){ return ${htmlIf} }) ){ _%%`)\n\t\t\t\tconst close = document.createTextNode(`%%_ }  _%%`)\n\t\t\t\twrap(open, element, close)\n\t\t\t}\n\n\t\t\tif (htmlInner) {\n\t\t\t\telement.removeAttribute('html-inner')\n\t\t\t\telement.innerHTML = `%%_=${htmlInner}_%%`\n\t\t\t}\n\n\t\t\tif (htmlClass) {\n\t\t\t\telement.removeAttribute('html-class')\n\t\t\t\telement.className = (element.className + ` %%_=${htmlClass}_%%`).trim()\n\t\t\t}\n\n\t\t\tif( element.localName === 'template' ) {\n\t\t\t\ttransformTemplate(element.content)\n\t\t\t}\n\t\t})\n}\n\nconst setTemplates = ( clone, components ) => {\n\n\tArray.from(clone.querySelectorAll('[tplid]'))\n\t\t.reverse()\n\t\t.forEach((node) => {\n\n\t\t\tconst tplid = node.getAttribute('tplid')\n\t\t\tconst name  = node.localName\n\t\t\tnode.setAttribute('html-scopeid', 'jails___scope-id')\n\n\t\t\tif( name in components && components[name].module.template ) {\n\t\t\t\tconst children = node.innerHTML\n\t\t\t\tconst html = components[name].module.template({ elm:node, children })\n\t\t\t\tnode.innerHTML = html\n\t\t\t\ttransformTemplate(node)\n\t\t\t\tremoveTemplateTagsRecursively(node)\n\t\t\t}\n\n\t\t\tconst html = transformAttributes(node.outerHTML)\n\n\t\t\ttemplates[ tplid ] = {\n\t\t\t\ttemplate: html,\n\t\t\t\trender\t: compile(html)\n\t\t\t}\n\t\t})\n}\n\nconst removeTemplateTagsRecursively = (node) => {\n\n\t// Get all <template> elements within the node\n\tconst templates = node.querySelectorAll('template')\n\n\ttemplates.forEach((template) => {\n\n\t\tif( template.getAttribute('html-if') || template.getAttribute('html-inner') ) {\n\t\t\treturn\n\t\t}\n\n\t\t// Process any nested <template> tags within this <template> first\n\t\tremoveTemplateTagsRecursively(template.content)\n\n\t\t// Get the parent of the <template> tag\n\t\tconst parent = template.parentNode\n\n\t\tif (parent) {\n\t\t\t// Move all child nodes from the <template>'s content to its parent\n\t\t\tconst content = template.content\n\t\t\twhile (content.firstChild) {\n\t\t\t\tparent.insertBefore(content.firstChild, template)\n\t\t\t}\n\t\t\t// Remove the <template> tag itself\n\t\t\tparent.removeChild(template)\n\t\t}\n\t})\n}\n\n\nconst wrap = (open, node, close) => {\n\tnode.parentNode?.insertBefore(open, node)\n\tnode.parentNode?.insertBefore(close, node.nextSibling)\n}\n","\nimport { Element } from './element'\nimport { template, templateConfig as config } from './template-system'\n\nexport { publish, subscribe } from './utils/pubsub'\n\nexport const templateConfig = (options) => {\n\tconfig( options )\n}\n\nglobalThis.__jails__ = globalThis.__jails__ || { components: {} }\n\nexport const register = ( name, module, dependencies ) => {\n\tconst { components } = globalThis.__jails__\n\tcomponents[ name ] = { name, module, dependencies }\n}\n\nexport const start = ( target ) => {\n\n\t// If the code is running in a Node.js environment, do nothing\n\tif( typeof window === 'undefined' ) {\n\t\treturn;\n\t}\n\n\ttarget = target || document.body\n\tconst { components } = globalThis.__jails__\n\tconst templates = template( target, { components } )\n\n\tObject\n\t\t.values( components )\n\t\t.forEach(({ name, module, dependencies }) => {\n\t\t\tif( !customElements.get(name) ) {\n\t\t\t\tcustomElements.define( name, Element({ component: { name, module, dependencies }, templates, start }))\n\t\t\t}\n\t})\n}\n"],"names":["textarea","g","scope","decodeHTML","text","document","createElement","innerHTML","value","uuid","Math","random","toString","substring","safe","execute","val","err","topics","_async","publish","name","params","isObject","Object","assign","forEach","topic","subscribe","method","push","filter","fn","Array","isArray","range","doc","HAS_TEMPLATE_SUPPORT","HAS_RANGE_SUPPORT","createRange","toElement","str","trim","template","content","childNodes","createFragmentFromTemplate","selectNode","body","createContextualFragment","createFragmentFromRange","fragment","createFragmentFromWrap","compareNodeNames","fromEl","toEl","fromCodeStart","toCodeStart","fromNodeName","nodeName","toNodeName","charCodeAt","toUpperCase","syncBooleanAttrProp","setAttribute","removeAttribute","specialElHandlers","OPTION","parentNode","parentName","hasAttribute","selected","selectedIndex","INPUT","TEXTAREA","newValue","firstChild","oldValue","nodeValue","placeholder","SELECT","optgroup","i","curChild","nextSibling","noop","defaultGetNodeKey","node","getAttribute","id","morphAttrs","morphdom","fromNode","toNode","attr","attrName","attrNamespaceURI","attrValue","toNodeAttrs","attributes","nodeType","length","namespaceURI","localName","getAttributeNS","prefix","setAttributeNS","fromNodeAttrs","d","hasAttributeNS","removeAttributeNS","options","toNodeHtml","firstElementChild","getNodeKey","onBeforeNodeAdded","onNodeAdded","onBeforeElUpdated","onElUpdated","onBeforeNodeDiscarded","onNodeDiscarded","onBeforeElChildrenUpdated","skipFromChildren","addChild","parent","child","appendChild","childrenOnly","fromNodesLookup","create","keyedRemovalList","addKeyedRemoval","key","walkDiscardedChildNodes","skipKeyedNodes","removeNode","removeChild","indexTree","handleNodeAdded","el","unmatchedFromEl","replaceChild","morphEl","toElKey","beforeUpdateResult","HTMLElement","curToNodeKey","curFromNodeKey","fromNextSibling","toNextSibling","matchingFromEl","skipFrom","curToNodeChild","curFromNodeChild","outer","isSameNode","curFromNodeType","isCompatible","insertBefore","onBeforeNodeAddedResult","actualize","ownerDocument","cleanupFromEl","specialElHandler","morphChildren","morphedNode","morphedNodeType","toNodeType","nextChild","moveChildren","createElementNS","len","elToRemove","Component","module","dependencies","templates","signal","register","tick","preserve","observer","observables","_model","model","initialState","Function","tplid","scopeid","tpl","o","_a","apply","elm","JSON","parse","stringify","state","view","data","base","main","addEventListener","protected","list","save","constructor","set","contains","newstate","Promise","resolve","render","get","dataset","target","isNaN","Number","e","on","ev","selectorOrCallback","callback","attribute","match","MutationObserver","mutationsList","mutation","type","attrname","attributeName","item","querySelectorAll","observe","subtree","disconnect","handler","detail","matches","delegateTarget","concat","args","capture","off","removeEventListener","trigger","String","from","children","dispatchEvent","CustomEvent","bubbles","emit","unmount","html_","element","clone","cloneNode","html","clearTimeout","setTimeout","call","__spreadValues","morhdomOptions","then","default","update","WeakMap","Element","component","start","super","connectedCallback","this","abortController","AbortController","rtrn","disconnectedCallback","abort","config","tags","booleanAttrs","htmlAttr","compile","parsedHtml","replace","_","variable","tagElements","keys","components","selector","join","transformAttributes","RegExp","all","includes","transformTemplate","htmlFor","htmlIf","htmlInner","htmlClass","split","varname","object","objectname","shift","open","createTextNode","close","wrap","className","setTemplates","reverse","removeTemplateTagsRecursively","outerHTML","_b","globalThis","__jails__","window","values","customElements","define","newconfig"],"mappings":"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","x_google_ignoreList":[2]}