{"version":3,"file":"jails.js","sources":["../node_modules/morphdom/dist/morphdom-esm.js","../src/utils/index.ts","../src/utils/pubsub.ts","../src/component.ts","../src/element.ts","../src/template-system.ts","../src/index.ts"],"sourcesContent":["var DOCUMENT_FRAGMENT_NODE = 11;\n\nfunction morphAttrs(fromNode, toNode) {\n    var toNodeAttrs = toNode.attributes;\n    var attr;\n    var attrName;\n    var attrNamespaceURI;\n    var attrValue;\n    var fromValue;\n\n    // document-fragments dont have attributes so lets not do anything\n    if (toNode.nodeType === DOCUMENT_FRAGMENT_NODE || fromNode.nodeType === DOCUMENT_FRAGMENT_NODE) {\n      return;\n    }\n\n    // update attributes on original DOM element\n    for (var i = toNodeAttrs.length - 1; i >= 0; i--) {\n        attr = toNodeAttrs[i];\n        attrName = attr.name;\n        attrNamespaceURI = attr.namespaceURI;\n        attrValue = attr.value;\n\n        if (attrNamespaceURI) {\n            attrName = attr.localName || attrName;\n            fromValue = fromNode.getAttributeNS(attrNamespaceURI, attrName);\n\n            if (fromValue !== attrValue) {\n                if (attr.prefix === 'xmlns'){\n                    attrName = attr.name; // It's not allowed to set an attribute with the XMLNS namespace without specifying the `xmlns` prefix\n                }\n                fromNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);\n            }\n        } else {\n            fromValue = fromNode.getAttribute(attrName);\n\n            if (fromValue !== attrValue) {\n                fromNode.setAttribute(attrName, attrValue);\n            }\n        }\n    }\n\n    // Remove any extra attributes found on the original DOM element that\n    // weren't found on the target element.\n    var fromNodeAttrs = fromNode.attributes;\n\n    for (var d = fromNodeAttrs.length - 1; d >= 0; d--) {\n        attr = fromNodeAttrs[d];\n        attrName = attr.name;\n        attrNamespaceURI = attr.namespaceURI;\n\n        if (attrNamespaceURI) {\n            attrName = attr.localName || attrName;\n\n            if (!toNode.hasAttributeNS(attrNamespaceURI, attrName)) {\n                fromNode.removeAttributeNS(attrNamespaceURI, attrName);\n            }\n        } else {\n            if (!toNode.hasAttribute(attrName)) {\n                fromNode.removeAttribute(attrName);\n            }\n        }\n    }\n}\n\nvar range; // Create a range object for efficently rendering strings to elements.\nvar NS_XHTML = 'http://www.w3.org/1999/xhtml';\n\nvar doc = typeof document === 'undefined' ? undefined : document;\nvar HAS_TEMPLATE_SUPPORT = !!doc && 'content' in doc.createElement('template');\nvar HAS_RANGE_SUPPORT = !!doc && doc.createRange && 'createContextualFragment' in doc.createRange();\n\nfunction createFragmentFromTemplate(str) {\n    var template = doc.createElement('template');\n    template.innerHTML = str;\n    return template.content.childNodes[0];\n}\n\nfunction createFragmentFromRange(str) {\n    if (!range) {\n        range = doc.createRange();\n        range.selectNode(doc.body);\n    }\n\n    var fragment = range.createContextualFragment(str);\n    return fragment.childNodes[0];\n}\n\nfunction createFragmentFromWrap(str) {\n    var fragment = doc.createElement('body');\n    fragment.innerHTML = str;\n    return fragment.childNodes[0];\n}\n\n/**\n * This is about the same\n * var html = new DOMParser().parseFromString(str, 'text/html');\n * return html.body.firstChild;\n *\n * @method toElement\n * @param {String} str\n */\nfunction toElement(str) {\n    str = str.trim();\n    if (HAS_TEMPLATE_SUPPORT) {\n      // avoid restrictions on content for things like `<tr><th>Hi</th></tr>` which\n      // createContextualFragment doesn't support\n      // <template> support not available in IE\n      return createFragmentFromTemplate(str);\n    } else if (HAS_RANGE_SUPPORT) {\n      return createFragmentFromRange(str);\n    }\n\n    return createFragmentFromWrap(str);\n}\n\n/**\n * Returns true if two node's names are the same.\n *\n * NOTE: We don't bother checking `namespaceURI` because you will never find two HTML elements with the same\n *       nodeName and different namespace URIs.\n *\n * @param {Element} a\n * @param {Element} b The target element\n * @return {boolean}\n */\nfunction compareNodeNames(fromEl, toEl) {\n    var fromNodeName = fromEl.nodeName;\n    var toNodeName = toEl.nodeName;\n    var fromCodeStart, toCodeStart;\n\n    if (fromNodeName === toNodeName) {\n        return true;\n    }\n\n    fromCodeStart = fromNodeName.charCodeAt(0);\n    toCodeStart = toNodeName.charCodeAt(0);\n\n    // If the target element is a virtual DOM node or SVG node then we may\n    // need to normalize the tag name before comparing. Normal HTML elements that are\n    // in the \"http://www.w3.org/1999/xhtml\"\n    // are converted to upper case\n    if (fromCodeStart <= 90 && toCodeStart >= 97) { // from is upper and to is lower\n        return fromNodeName === toNodeName.toUpperCase();\n    } else if (toCodeStart <= 90 && fromCodeStart >= 97) { // to is upper and from is lower\n        return toNodeName === fromNodeName.toUpperCase();\n    } else {\n        return false;\n    }\n}\n\n/**\n * Create an element, optionally with a known namespace URI.\n *\n * @param {string} name the element name, e.g. 'div' or 'svg'\n * @param {string} [namespaceURI] the element's namespace URI, i.e. the value of\n * its `xmlns` attribute or its inferred namespace.\n *\n * @return {Element}\n */\nfunction createElementNS(name, namespaceURI) {\n    return !namespaceURI || namespaceURI === NS_XHTML ?\n        doc.createElement(name) :\n        doc.createElementNS(namespaceURI, name);\n}\n\n/**\n * Copies the children of one DOM element to another DOM element\n */\nfunction moveChildren(fromEl, toEl) {\n    var curChild = fromEl.firstChild;\n    while (curChild) {\n        var nextChild = curChild.nextSibling;\n        toEl.appendChild(curChild);\n        curChild = nextChild;\n    }\n    return toEl;\n}\n\nfunction syncBooleanAttrProp(fromEl, toEl, name) {\n    if (fromEl[name] !== toEl[name]) {\n        fromEl[name] = toEl[name];\n        if (fromEl[name]) {\n            fromEl.setAttribute(name, '');\n        } else {\n            fromEl.removeAttribute(name);\n        }\n    }\n}\n\nvar specialElHandlers = {\n    OPTION: function(fromEl, toEl) {\n        var parentNode = fromEl.parentNode;\n        if (parentNode) {\n            var parentName = parentNode.nodeName.toUpperCase();\n            if (parentName === 'OPTGROUP') {\n                parentNode = parentNode.parentNode;\n                parentName = parentNode && parentNode.nodeName.toUpperCase();\n            }\n            if (parentName === 'SELECT' && !parentNode.hasAttribute('multiple')) {\n                if (fromEl.hasAttribute('selected') && !toEl.selected) {\n                    // Workaround for MS Edge bug where the 'selected' attribute can only be\n                    // removed if set to a non-empty value:\n                    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12087679/\n                    fromEl.setAttribute('selected', 'selected');\n                    fromEl.removeAttribute('selected');\n                }\n                // We have to reset select element's selectedIndex to -1, otherwise setting\n                // fromEl.selected using the syncBooleanAttrProp below has no effect.\n                // The correct selectedIndex will be set in the SELECT special handler below.\n                parentNode.selectedIndex = -1;\n            }\n        }\n        syncBooleanAttrProp(fromEl, toEl, 'selected');\n    },\n    /**\n     * The \"value\" attribute is special for the <input> element since it sets\n     * the initial value. Changing the \"value\" attribute without changing the\n     * \"value\" property will have no effect since it is only used to the set the\n     * initial value.  Similar for the \"checked\" attribute, and \"disabled\".\n     */\n    INPUT: function(fromEl, toEl) {\n        syncBooleanAttrProp(fromEl, toEl, 'checked');\n        syncBooleanAttrProp(fromEl, toEl, 'disabled');\n\n        if (fromEl.value !== toEl.value) {\n            fromEl.value = toEl.value;\n        }\n\n        if (!toEl.hasAttribute('value')) {\n            fromEl.removeAttribute('value');\n        }\n    },\n\n    TEXTAREA: function(fromEl, toEl) {\n        var newValue = toEl.value;\n        if (fromEl.value !== newValue) {\n            fromEl.value = newValue;\n        }\n\n        var firstChild = fromEl.firstChild;\n        if (firstChild) {\n            // Needed for IE. Apparently IE sets the placeholder as the\n            // node value and vise versa. This ignores an empty update.\n            var oldValue = firstChild.nodeValue;\n\n            if (oldValue == newValue || (!newValue && oldValue == fromEl.placeholder)) {\n                return;\n            }\n\n            firstChild.nodeValue = newValue;\n        }\n    },\n    SELECT: function(fromEl, toEl) {\n        if (!toEl.hasAttribute('multiple')) {\n            var selectedIndex = -1;\n            var i = 0;\n            // We have to loop through children of fromEl, not toEl since nodes can be moved\n            // from toEl to fromEl directly when morphing.\n            // At the time this special handler is invoked, all children have already been morphed\n            // and appended to / removed from fromEl, so using fromEl here is safe and correct.\n            var curChild = fromEl.firstChild;\n            var optgroup;\n            var nodeName;\n            while(curChild) {\n                nodeName = curChild.nodeName && curChild.nodeName.toUpperCase();\n                if (nodeName === 'OPTGROUP') {\n                    optgroup = curChild;\n                    curChild = optgroup.firstChild;\n                    // handle empty optgroups\n                    if (!curChild) {\n                        curChild = optgroup.nextSibling;\n                        optgroup = null;\n                    }\n                } else {\n                    if (nodeName === 'OPTION') {\n                        if (curChild.hasAttribute('selected')) {\n                            selectedIndex = i;\n                            break;\n                        }\n                        i++;\n                    }\n                    curChild = curChild.nextSibling;\n                    if (!curChild && optgroup) {\n                        curChild = optgroup.nextSibling;\n                        optgroup = null;\n                    }\n                }\n            }\n\n            fromEl.selectedIndex = selectedIndex;\n        }\n    }\n};\n\nvar ELEMENT_NODE = 1;\nvar DOCUMENT_FRAGMENT_NODE$1 = 11;\nvar TEXT_NODE = 3;\nvar COMMENT_NODE = 8;\n\nfunction noop() {}\n\nfunction defaultGetNodeKey(node) {\n  if (node) {\n    return (node.getAttribute && node.getAttribute('id')) || node.id;\n  }\n}\n\nfunction morphdomFactory(morphAttrs) {\n\n  return function morphdom(fromNode, toNode, options) {\n    if (!options) {\n      options = {};\n    }\n\n    if (typeof toNode === 'string') {\n      if (fromNode.nodeName === '#document' || fromNode.nodeName === 'HTML' || fromNode.nodeName === 'BODY') {\n        var toNodeHtml = toNode;\n        toNode = doc.createElement('html');\n        toNode.innerHTML = toNodeHtml;\n      } else {\n        toNode = toElement(toNode);\n      }\n    } else if (toNode.nodeType === DOCUMENT_FRAGMENT_NODE$1) {\n      toNode = toNode.firstElementChild;\n    }\n\n    var getNodeKey = options.getNodeKey || defaultGetNodeKey;\n    var onBeforeNodeAdded = options.onBeforeNodeAdded || noop;\n    var onNodeAdded = options.onNodeAdded || noop;\n    var onBeforeElUpdated = options.onBeforeElUpdated || noop;\n    var onElUpdated = options.onElUpdated || noop;\n    var onBeforeNodeDiscarded = options.onBeforeNodeDiscarded || noop;\n    var onNodeDiscarded = options.onNodeDiscarded || noop;\n    var onBeforeElChildrenUpdated = options.onBeforeElChildrenUpdated || noop;\n    var skipFromChildren = options.skipFromChildren || noop;\n    var addChild = options.addChild || function(parent, child){ return parent.appendChild(child); };\n    var childrenOnly = options.childrenOnly === true;\n\n    // This object is used as a lookup to quickly find all keyed elements in the original DOM tree.\n    var fromNodesLookup = Object.create(null);\n    var keyedRemovalList = [];\n\n    function addKeyedRemoval(key) {\n      keyedRemovalList.push(key);\n    }\n\n    function walkDiscardedChildNodes(node, skipKeyedNodes) {\n      if (node.nodeType === ELEMENT_NODE) {\n        var curChild = node.firstChild;\n        while (curChild) {\n\n          var key = undefined;\n\n          if (skipKeyedNodes && (key = getNodeKey(curChild))) {\n            // If we are skipping keyed nodes then we add the key\n            // to a list so that it can be handled at the very end.\n            addKeyedRemoval(key);\n          } else {\n            // Only report the node as discarded if it is not keyed. We do this because\n            // at the end we loop through all keyed elements that were unmatched\n            // and then discard them in one final pass.\n            onNodeDiscarded(curChild);\n            if (curChild.firstChild) {\n              walkDiscardedChildNodes(curChild, skipKeyedNodes);\n            }\n          }\n\n          curChild = curChild.nextSibling;\n        }\n      }\n    }\n\n    /**\n    * Removes a DOM node out of the original DOM\n    *\n    * @param  {Node} node The node to remove\n    * @param  {Node} parentNode The nodes parent\n    * @param  {Boolean} skipKeyedNodes If true then elements with keys will be skipped and not discarded.\n    * @return {undefined}\n    */\n    function removeNode(node, parentNode, skipKeyedNodes) {\n      if (onBeforeNodeDiscarded(node) === false) {\n        return;\n      }\n\n      if (parentNode) {\n        parentNode.removeChild(node);\n      }\n\n      onNodeDiscarded(node);\n      walkDiscardedChildNodes(node, skipKeyedNodes);\n    }\n\n    // // TreeWalker implementation is no faster, but keeping this around in case this changes in the future\n    // function indexTree(root) {\n    //     var treeWalker = document.createTreeWalker(\n    //         root,\n    //         NodeFilter.SHOW_ELEMENT);\n    //\n    //     var el;\n    //     while((el = treeWalker.nextNode())) {\n    //         var key = getNodeKey(el);\n    //         if (key) {\n    //             fromNodesLookup[key] = el;\n    //         }\n    //     }\n    // }\n\n    // // NodeIterator implementation is no faster, but keeping this around in case this changes in the future\n    //\n    // function indexTree(node) {\n    //     var nodeIterator = document.createNodeIterator(node, NodeFilter.SHOW_ELEMENT);\n    //     var el;\n    //     while((el = nodeIterator.nextNode())) {\n    //         var key = getNodeKey(el);\n    //         if (key) {\n    //             fromNodesLookup[key] = el;\n    //         }\n    //     }\n    // }\n\n    function indexTree(node) {\n      if (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE$1) {\n        var curChild = node.firstChild;\n        while (curChild) {\n          var key = getNodeKey(curChild);\n          if (key) {\n            fromNodesLookup[key] = curChild;\n          }\n\n          // Walk recursively\n          indexTree(curChild);\n\n          curChild = curChild.nextSibling;\n        }\n      }\n    }\n\n    indexTree(fromNode);\n\n    function handleNodeAdded(el) {\n      onNodeAdded(el);\n\n      var curChild = el.firstChild;\n      while (curChild) {\n        var nextSibling = curChild.nextSibling;\n\n        var key = getNodeKey(curChild);\n        if (key) {\n          var unmatchedFromEl = fromNodesLookup[key];\n          // if we find a duplicate #id node in cache, replace `el` with cache value\n          // and morph it to the child node.\n          if (unmatchedFromEl && compareNodeNames(curChild, unmatchedFromEl)) {\n            curChild.parentNode.replaceChild(unmatchedFromEl, curChild);\n            morphEl(unmatchedFromEl, curChild);\n          } else {\n            handleNodeAdded(curChild);\n          }\n        } else {\n          // recursively call for curChild and it's children to see if we find something in\n          // fromNodesLookup\n          handleNodeAdded(curChild);\n        }\n\n        curChild = nextSibling;\n      }\n    }\n\n    function cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey) {\n      // We have processed all of the \"to nodes\". If curFromNodeChild is\n      // non-null then we still have some from nodes left over that need\n      // to be removed\n      while (curFromNodeChild) {\n        var fromNextSibling = curFromNodeChild.nextSibling;\n        if ((curFromNodeKey = getNodeKey(curFromNodeChild))) {\n          // Since the node is keyed it might be matched up later so we defer\n          // the actual removal to later\n          addKeyedRemoval(curFromNodeKey);\n        } else {\n          // NOTE: we skip nested keyed nodes from being removed since there is\n          //       still a chance they will be matched up later\n          removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n        }\n        curFromNodeChild = fromNextSibling;\n      }\n    }\n\n    function morphEl(fromEl, toEl, childrenOnly) {\n      var toElKey = getNodeKey(toEl);\n\n      if (toElKey) {\n        // If an element with an ID is being morphed then it will be in the final\n        // DOM so clear it out of the saved elements collection\n        delete fromNodesLookup[toElKey];\n      }\n\n      if (!childrenOnly) {\n        // optional\n        var beforeUpdateResult = onBeforeElUpdated(fromEl, toEl);\n        if (beforeUpdateResult === false) {\n          return;\n        } else if (beforeUpdateResult instanceof HTMLElement) {\n          fromEl = beforeUpdateResult;\n          // reindex the new fromEl in case it's not in the same\n          // tree as the original fromEl\n          // (Phoenix LiveView sometimes returns a cloned tree,\n          //  but keyed lookups would still point to the original tree)\n          indexTree(fromEl);\n        }\n\n        // update attributes on original DOM element first\n        morphAttrs(fromEl, toEl);\n        // optional\n        onElUpdated(fromEl);\n\n        if (onBeforeElChildrenUpdated(fromEl, toEl) === false) {\n          return;\n        }\n      }\n\n      if (fromEl.nodeName !== 'TEXTAREA') {\n        morphChildren(fromEl, toEl);\n      } else {\n        specialElHandlers.TEXTAREA(fromEl, toEl);\n      }\n    }\n\n    function morphChildren(fromEl, toEl) {\n      var skipFrom = skipFromChildren(fromEl, toEl);\n      var curToNodeChild = toEl.firstChild;\n      var curFromNodeChild = fromEl.firstChild;\n      var curToNodeKey;\n      var curFromNodeKey;\n\n      var fromNextSibling;\n      var toNextSibling;\n      var matchingFromEl;\n\n      // walk the children\n      outer: while (curToNodeChild) {\n        toNextSibling = curToNodeChild.nextSibling;\n        curToNodeKey = getNodeKey(curToNodeChild);\n\n        // walk the fromNode children all the way through\n        while (!skipFrom && curFromNodeChild) {\n          fromNextSibling = curFromNodeChild.nextSibling;\n\n          if (curToNodeChild.isSameNode && curToNodeChild.isSameNode(curFromNodeChild)) {\n            curToNodeChild = toNextSibling;\n            curFromNodeChild = fromNextSibling;\n            continue outer;\n          }\n\n          curFromNodeKey = getNodeKey(curFromNodeChild);\n\n          var curFromNodeType = curFromNodeChild.nodeType;\n\n          // this means if the curFromNodeChild doesnt have a match with the curToNodeChild\n          var isCompatible = undefined;\n\n          if (curFromNodeType === curToNodeChild.nodeType) {\n            if (curFromNodeType === ELEMENT_NODE) {\n              // Both nodes being compared are Element nodes\n\n              if (curToNodeKey) {\n                // The target node has a key so we want to match it up with the correct element\n                // in the original DOM tree\n                if (curToNodeKey !== curFromNodeKey) {\n                  // The current element in the original DOM tree does not have a matching key so\n                  // let's check our lookup to see if there is a matching element in the original\n                  // DOM tree\n                  if ((matchingFromEl = fromNodesLookup[curToNodeKey])) {\n                    if (fromNextSibling === matchingFromEl) {\n                      // Special case for single element removals. To avoid removing the original\n                      // DOM node out of the tree (since that can break CSS transitions, etc.),\n                      // we will instead discard the current node and wait until the next\n                      // iteration to properly match up the keyed target element with its matching\n                      // element in the original tree\n                      isCompatible = false;\n                    } else {\n                      // We found a matching keyed element somewhere in the original DOM tree.\n                      // Let's move the original DOM node into the current position and morph\n                      // it.\n\n                      // NOTE: We use insertBefore instead of replaceChild because we want to go through\n                      // the `removeNode()` function for the node that is being discarded so that\n                      // all lifecycle hooks are correctly invoked\n                      fromEl.insertBefore(matchingFromEl, curFromNodeChild);\n\n                      // fromNextSibling = curFromNodeChild.nextSibling;\n\n                      if (curFromNodeKey) {\n                        // Since the node is keyed it might be matched up later so we defer\n                        // the actual removal to later\n                        addKeyedRemoval(curFromNodeKey);\n                      } else {\n                        // NOTE: we skip nested keyed nodes from being removed since there is\n                        //       still a chance they will be matched up later\n                        removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n                      }\n\n                      curFromNodeChild = matchingFromEl;\n                      curFromNodeKey = getNodeKey(curFromNodeChild);\n                    }\n                  } else {\n                    // The nodes are not compatible since the \"to\" node has a key and there\n                    // is no matching keyed node in the source tree\n                    isCompatible = false;\n                  }\n                }\n              } else if (curFromNodeKey) {\n                // The original has a key\n                isCompatible = false;\n              }\n\n              isCompatible = isCompatible !== false && compareNodeNames(curFromNodeChild, curToNodeChild);\n              if (isCompatible) {\n                // We found compatible DOM elements so transform\n                // the current \"from\" node to match the current\n                // target DOM node.\n                // MORPH\n                morphEl(curFromNodeChild, curToNodeChild);\n              }\n\n            } else if (curFromNodeType === TEXT_NODE || curFromNodeType == COMMENT_NODE) {\n              // Both nodes being compared are Text or Comment nodes\n              isCompatible = true;\n              // Simply update nodeValue on the original node to\n              // change the text value\n              if (curFromNodeChild.nodeValue !== curToNodeChild.nodeValue) {\n                curFromNodeChild.nodeValue = curToNodeChild.nodeValue;\n              }\n\n            }\n          }\n\n          if (isCompatible) {\n            // Advance both the \"to\" child and the \"from\" child since we found a match\n            // Nothing else to do as we already recursively called morphChildren above\n            curToNodeChild = toNextSibling;\n            curFromNodeChild = fromNextSibling;\n            continue outer;\n          }\n\n          // No compatible match so remove the old node from the DOM and continue trying to find a\n          // match in the original DOM. However, we only do this if the from node is not keyed\n          // since it is possible that a keyed node might match up with a node somewhere else in the\n          // target tree and we don't want to discard it just yet since it still might find a\n          // home in the final DOM tree. After everything is done we will remove any keyed nodes\n          // that didn't find a home\n          if (curFromNodeKey) {\n            // Since the node is keyed it might be matched up later so we defer\n            // the actual removal to later\n            addKeyedRemoval(curFromNodeKey);\n          } else {\n            // NOTE: we skip nested keyed nodes from being removed since there is\n            //       still a chance they will be matched up later\n            removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n          }\n\n          curFromNodeChild = fromNextSibling;\n        } // END: while(curFromNodeChild) {}\n\n        // If we got this far then we did not find a candidate match for\n        // our \"to node\" and we exhausted all of the children \"from\"\n        // nodes. Therefore, we will just append the current \"to\" node\n        // to the end\n        if (curToNodeKey && (matchingFromEl = fromNodesLookup[curToNodeKey]) && compareNodeNames(matchingFromEl, curToNodeChild)) {\n          // MORPH\n          if(!skipFrom){ addChild(fromEl, matchingFromEl); }\n          morphEl(matchingFromEl, curToNodeChild);\n        } else {\n          var onBeforeNodeAddedResult = onBeforeNodeAdded(curToNodeChild);\n          if (onBeforeNodeAddedResult !== false) {\n            if (onBeforeNodeAddedResult) {\n              curToNodeChild = onBeforeNodeAddedResult;\n            }\n\n            if (curToNodeChild.actualize) {\n              curToNodeChild = curToNodeChild.actualize(fromEl.ownerDocument || doc);\n            }\n            addChild(fromEl, curToNodeChild);\n            handleNodeAdded(curToNodeChild);\n          }\n        }\n\n        curToNodeChild = toNextSibling;\n        curFromNodeChild = fromNextSibling;\n      }\n\n      cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey);\n\n      var specialElHandler = specialElHandlers[fromEl.nodeName];\n      if (specialElHandler) {\n        specialElHandler(fromEl, toEl);\n      }\n    } // END: morphChildren(...)\n\n    var morphedNode = fromNode;\n    var morphedNodeType = morphedNode.nodeType;\n    var toNodeType = toNode.nodeType;\n\n    if (!childrenOnly) {\n      // Handle the case where we are given two DOM nodes that are not\n      // compatible (e.g. <div> --> <span> or <div> --> TEXT)\n      if (morphedNodeType === ELEMENT_NODE) {\n        if (toNodeType === ELEMENT_NODE) {\n          if (!compareNodeNames(fromNode, toNode)) {\n            onNodeDiscarded(fromNode);\n            morphedNode = moveChildren(fromNode, createElementNS(toNode.nodeName, toNode.namespaceURI));\n          }\n        } else {\n          // Going from an element node to a text node\n          morphedNode = toNode;\n        }\n      } else if (morphedNodeType === TEXT_NODE || morphedNodeType === COMMENT_NODE) { // Text or comment node\n        if (toNodeType === morphedNodeType) {\n          if (morphedNode.nodeValue !== toNode.nodeValue) {\n            morphedNode.nodeValue = toNode.nodeValue;\n          }\n\n          return morphedNode;\n        } else {\n          // Text node to something else\n          morphedNode = toNode;\n        }\n      }\n    }\n\n    if (morphedNode === toNode) {\n      // The \"to node\" was not compatible with the \"from node\" so we had to\n      // toss out the \"from node\" and use the \"to node\"\n      onNodeDiscarded(fromNode);\n    } else {\n      if (toNode.isSameNode && toNode.isSameNode(morphedNode)) {\n        return;\n      }\n\n      morphEl(morphedNode, toNode, childrenOnly);\n\n      // We now need to loop over any keyed nodes that might need to be\n      // removed. We only do the removal if we know that the keyed node\n      // never found a match. When a keyed node is matched up we remove\n      // it out of fromNodesLookup and we use fromNodesLookup to determine\n      // if a keyed node has been matched up or not\n      if (keyedRemovalList) {\n        for (var i=0, len=keyedRemovalList.length; i<len; i++) {\n          var elToRemove = fromNodesLookup[keyedRemovalList[i]];\n          if (elToRemove) {\n            removeNode(elToRemove, elToRemove.parentNode, false);\n          }\n        }\n      }\n    }\n\n    if (!childrenOnly && morphedNode !== fromNode && fromNode.parentNode) {\n      if (morphedNode.actualize) {\n        morphedNode = morphedNode.actualize(fromNode.ownerDocument || doc);\n      }\n      // If we had to swap out the from node with a new node because the old\n      // node was not compatible with the target node then we need to\n      // replace the old DOM node in the original DOM tree. This is only\n      // possible if the original DOM node was part of a DOM tree which\n      // we know is the case if it has a parent node.\n      fromNode.parentNode.replaceChild(morphedNode, fromNode);\n    }\n\n    return morphedNode;\n  };\n}\n\nvar morphdom = morphdomFactory(morphAttrs);\n\nexport default morphdom;\n","let textarea\n\nexport const g = {\n\tscope: {}\n}\n\nexport const decodeHTML = (text) => {\n\ttextarea = textarea || document.createElement('textarea')\n\ttextarea.innerHTML = text\n\treturn textarea.value\n}\n\nexport const rAF = (fn) => {\n\tif (requestAnimationFrame)\n\t\treturn requestAnimationFrame(fn)\n\telse\n\t\treturn setTimeout(fn, 1000 / 60)\n}\n\nexport const uuid = () => {\n\treturn Math.random().toString(36).substring(2, 9)\n}\n\nexport const dup = (o) => {\n\treturn JSON.parse(JSON.stringify(o))\n}\n\nexport const safe = (execute, val) => {\n\ttry{\n\t\tconst value = execute()\n\t\treturn value !== undefined && value !== null ? value : val || ''\n\t}catch(err){\n\t\treturn val || ''\n\t}\n}\n","\nconst topics: any = {}\nconst _async: any = {}\n\nexport const publish = (name, params) => {\n\n\t_async[name] = isObject(params)? Object.assign({}, _async[name], params): params\n\n\tif (topics[name]) {\n\t\ttopics[name].forEach(topic => topic(params))\n\t}\n}\n\nexport const subscribe = (name, method) => {\n\ttopics[name] = topics[name] || []\n\ttopics[name].push(method)\n\tif (name in _async) {\n\t\tmethod(_async[name])\n\t}\n\treturn () => {\n\t\ttopics[name] = topics[name].filter( fn => fn != method )\n\t}\n}\n\nconst isObject = (value) => {\n\treturn (typeof value === 'object' && value !== null && !Array.isArray(value))\n}\n","import morphdom from 'morphdom'\nimport { safe, g, dup } from './utils'\nimport { publish, subscribe } from './utils/pubsub'\n\nexport const Component = ({ name, module, dependencies, node, templates, signal, register }) => {\n\n\tlet tick\n\tlet preserve\t\t= []\n\tlet observer \t\t= null\n\tlet observables \t= []\n\tlet effect \t\t\t= null\n\n\tconst _model \t\t= module.model || {}\n\tconst initialState \t= (new Function( `return ${node.getAttribute('html-model') || '{}'}`))()\n\tconst tplid \t\t= node.getAttribute('tplid')\n\tconst scopeid \t\t= node.getAttribute('html-scopeid')\n\tconst tpl \t\t\t= templates[ tplid ]\n\tconst scope \t\t= g.scope[ scopeid ]\n\tconst model  \t\t= dup(module?.model?.apply ? _model({ elm:node, initialState, dependencies }) : _model)\n\tconst state \t\t= Object.assign({}, scope, model, initialState)\n\tconst view \t\t\t= module.view? module.view : (data) => data\n\n\tconst base = {\n\t\tname,\n\t\tmodel,\n\t\telm: node,\n\t\ttemplate: tpl.template,\n\t\tdependencies,\n\t\tpublish,\n\t\tsubscribe,\n\n\t\tmain(fn) {\n\t\t\tnode.addEventListener(':mount', fn)\n\t\t},\n\n\t\teffect(fn) {\n\t\t\tif( fn ) {\n\t\t\t\teffect = fn\n\t\t\t} else {\n\t\t\t\treturn effect\n\t\t\t}\n\t\t},\n\n\t\tquery( selector) {\n\t\t\tconst elements = Array.from(node.querySelectorAll(selector))\n\t\t\treturn elements.map( (element: HTMLElement) => {\n\t\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\t\tif (document.body.contains(element)) {\n\t\t\t\t\t\telement.addEventListener(':mount', () => resolve(element))\n\t\t\t\t\t} else {\n\t\t\t\t\t\treject(element)\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t})\n\t\t},\n\n\t\t/**\n\t\t * @State\n\t\t */\n\t\tstate : {\n\n\t\t\tprotected( list ) {\n\t\t\t\tif( list ) {\n\t\t\t\t\tpreserve = list\n\t\t\t\t} else {\n\t\t\t\t\treturn preserve\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tsave(data) {\n\t\t\t\tif( data.constructor === Function ) {\n\t\t\t\t\tdata( state )\n\t\t\t\t} else {\n\t\t\t\t\tObject.assign(state, data)\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tset( data ) {\n\n\t\t\t\tif (!document.body.contains(node)) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif( data.constructor === Function ) {\n\t\t\t\t\tdata(state)\n\t\t\t\t} else {\n\t\t\t\t\tObject.assign(state, data)\n\t\t\t\t}\n\n\t\t\t\tconst newstate = Object.assign({}, state)\n\n\t\t\t\treturn new Promise((resolve) => {\n\t\t\t\t\trender(newstate, () => resolve(newstate))\n\t\t\t\t})\n\t\t\t},\n\n\t\t\tget() {\n\t\t\t\treturn Object.assign({}, state)\n\t\t\t}\n\t\t},\n\n\t\tdataset( target, name ) {\n\n\t\t\tconst el = name? target : node\n\t\t\tconst key = name? name : target\n\t\t\tconst value = el.dataset[key]\n\n\t\t\tif (value === 'true') return true\n\t\t\tif (value === 'false') return false\n\t\t\tif (!isNaN(value) && value.trim() !== '') return Number(value)\n\n\t\t\ttry {\n\t\t\t\treturn new Function('return (' + value + ')')()\n\t\t\t} catch {}\n\n\t\t\ttry {\n\t\t\t\treturn JSON.parse(value)\n\t\t\t} catch {}\n\n\t\t\treturn value\n\t\t},\n\n\t\t/**\n\t\t * @Events\n\t\t */\n\t\ton( ev, selectorOrCallback, callback ) {\n\n\t\t\tconst attribute = ev.match(/\\[(.*)\\]/)\n\n\t\t\tif( attribute ) {\n\t\t\t\tobservables.push({\n\t\t\t\t\ttarget: callback? selectorOrCallback : null,\n\t\t\t\t\tcallback: callback || selectorOrCallback\n\t\t\t\t})\n\n\t\t\t\tif( !observer ) {\n\t\t\t\t\tobserver = new MutationObserver((mutationsList) => {\n\t\t\t\t\t\tfor (const mutation of mutationsList) {\n\t\t\t\t\t\t\tif (mutation.type === 'attributes') {\n\t\t\t\t\t\t\t\tconst attrname = mutation.attributeName\n\t\t\t\t\t\t\t\tif( attrname === attribute[1] ) {\n\t\t\t\t\t\t\t\t\tobservables.forEach( item => {\n\t\t\t\t\t\t\t\t\t\tconst target = item.target? node.querySelectorAll(item.target): [node]\n\t\t\t\t\t\t\t\t\t\ttarget.forEach( target => {\n\t\t\t\t\t\t\t\t\t\t\tif( target == mutation.target ) {\n\t\t\t\t\t\t\t\t\t\t\t\titem.callback({\n\t\t\t\t\t\t\t\t\t\t\t\t\ttarget: mutation.target,\n\t\t\t\t\t\t\t\t\t\t\t\t\tattribute: attrname,\n\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: mutation.target.getAttribute(attrname)\n\t\t\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\n\t\t\t\t\tobserver.observe(node, {\n\t\t\t\t\t\tattributes: true,\n\t\t\t\t\t\tsubtree: true\n\t\t\t\t\t})\n\n\t\t\t\t\tnode.addEventListener(':unmount', () => {\n\t\t\t\t\t\tobservables = []\n\t\t\t\t\t\tobserver.disconnect()\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif( callback ) {\n\t\t\t\tcallback.handler = (e) => {\n\t\t\t\t\tconst detail = e.detail || {}\n\t\t\t\t\tlet parent = e.target\n\t\t\t\t\twhile (parent) {\n\t\t\t\t\t\tif (parent.matches(selectorOrCallback)) {\n\t\t\t\t\t\t\te.delegateTarget = parent\n\t\t\t\t\t\t\tcallback.apply(node, [e].concat(detail.args))\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (parent === node) break\n\t\t\t\t\t\tparent = parent.parentNode\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnode.addEventListener(ev, callback.handler, {\n\t\t\t\t\tsignal,\n\t\t\t\t\tcapture: (ev == 'focus' || ev == 'blur' || ev == 'mouseenter' || ev == 'mouseleave')\n\t\t\t\t})\n\n\t\t\t} else {\n\t\t\t\tselectorOrCallback.handler = (e) => {\n\t\t\t\t\te.delegateTarget = node\n\t\t\t\t\tselectorOrCallback.apply(node, [e].concat(e.detail.args))\n\t\t\t\t}\n\t\t\t\tnode.addEventListener(ev, selectorOrCallback.handler, { signal })\n\t\t\t}\n\n\t\t},\n\n\t\toff( ev, callback ) {\n\t\t\tif( callback.handler ) {\n\t\t\t\tnode.removeEventListener(ev, callback.handler)\n\t\t\t}\n\t\t},\n\n\t\ttrigger(ev, selectorOrCallback, data = {}) {\n\t\t\tif( selectorOrCallback.constructor === String ) {\n\t\t\t\tArray\n\t\t\t\t\t.from(node.querySelectorAll(selectorOrCallback))\n\t\t\t\t\t.forEach( children => {\n\t\t\t\t\t\tchildren.dispatchEvent(new CustomEvent(ev, { bubbles: true, detail: { args: data } }) )\n\t\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tnode.dispatchEvent(new CustomEvent(ev, { bubbles: true, detail:{ args: data } }))\n\t\t\t}\n\t\t},\n\n\t\temit(ev, data) {\n\t\t\tnode.dispatchEvent(new CustomEvent(ev, { bubbles: true, detail: { args: data } }))\n\t\t},\n\n\t\tunmount( fn ) {\n\t\t\tnode.addEventListener(':unmount', fn)\n\t\t},\n\n\t\tinnerHTML ( target, html_ ) {\n\t\t\tconst element = html_? target : node\n\t\t\tconst clone = element.cloneNode()\n\t\t\tconst html = html_? html_ : target\n\t\t\tclone.innerHTML = html\n\t\t\tmorphdom(element, clone)\n\t\t}\n\t}\n\n\tconst render = ( data, callback = (() => {}) ) => {\n\t\tclearTimeout( tick )\n\t\ttick = setTimeout(() => {\n\t\t\tconst html = tpl.render.call({...data, ...view(data)}, node, safe, g )\n\t\t\tmorphdom(node, html, morphOptions(node, register, data) )\n\t\t\tPromise.resolve().then(() => {\n\t\t\t\tnode.querySelectorAll('[tplid]')\n\t\t\t\t\t.forEach((element) => {\n\t\t\t\t\t\tconst child = register.get(element)\n\t\t\t\t\t\tconst scope = { ...child.__scope__ }\n\t\t\t\t\t\tif(!child) return\n\t\t\t\t\t\tchild.state.protected().forEach( key => delete data[key] )\n\t\t\t\t\t\tconst useEffect = child.effect()\n\t\t\t\t\t\tif( useEffect ) {\n\t\t\t\t\t\t\tconst promise = useEffect(data)\n\t\t\t\t\t\t\tif( promise && promise.then ) {\n\t\t\t\t\t\t\t\tpromise.then(() => child.state.set({...data, ...scope }))\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tchild.state.set({...data, ...scope })\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tchild.state.set({...data, ...scope })\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\tPromise.resolve().then(() => {\n\t\t\t\t\tg.scope = {}\n\t\t\t\t\tcallback()\n\t\t\t\t})\n\t\t\t})\n\t\t})\n\t}\n\n\trender( state )\n\tregister.set( node, base )\n\treturn module.default( base )\n}\n\nconst morphOptions = ( parent, register, data ) => {\n\n\treturn {\n\t\tgetNodeKey(node) {\n\t\t\tif( node.nodeType === 1 ) {\n\t\t\t\treturn node.id || node.getAttribute('key')\n\t\t\t}\n\t\t},\n\t\tonBeforeElUpdated: update(parent, register, data),\n\t\tonBeforeChildElUpdated: update(parent, register, data),\n\t}\n}\n\nconst update = (parent, register, data) => (node, newnode) => {\n\tif( node.nodeType === 1 ) {\n\t\tif( 'html-static' in node.attributes ) {\n\t\t\treturn false\n\t\t}\n\t\tif( register.get(node) && node !== parent ) {\n\t\t\tconst scopeid \t\t= newnode.getAttribute('html-scopeid')\n\t\t\tconst scope \t\t= g.scope[ scopeid ]\n\t\t\tconst base = register.get(node)\n\t\t\tbase.__scope__ = scope\n\t\t\treturn false\n\t\t}\n\t}\n}\n","import { Component } from './component'\n\nconst register = new WeakMap()\n\nexport const Element = ({ component, templates, start }) => {\n\n\tconst { name, module, dependencies } = component\n\n\treturn class extends HTMLElement {\n\n\t\tconstructor() {\n\t\t\tsuper()\n\t\t}\n\n\t\tconnectedCallback() {\n\n\t\t\tthis.abortController = new AbortController()\n\n\t\t\tif( !this.getAttribute('tplid') ) {\n\t\t\t\tstart( this.parentNode )\n\t\t\t}\n\n\t\t\tconst rtrn = Component({\n\t\t\t\tnode:this,\n\t\t\t\tname,\n\t\t\t\tmodule,\n\t\t\t\tdependencies,\n\t\t\t\ttemplates,\n\t\t\t\tsignal: this.abortController.signal,\n\t\t\t\tregister\n\t\t\t})\n\n\t\t\tif ( rtrn && rtrn.constructor === Promise ) {\n\t\t\t\trtrn.then(() => {\n\t\t\t\t\tthis.dispatchEvent( new CustomEvent(':mount') )\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tthis.dispatchEvent( new CustomEvent(':mount') )\n\t\t\t}\n\t\t}\n\n\t\tdisconnectedCallback() {\n\t\t\tthis.dispatchEvent( new CustomEvent(':unmount') )\n\t\t\tthis.abortController.abort()\n\t\t}\n\t}\n}\n","import { uuid, decodeHTML } from './utils'\n\nconst config = {\n\ttags: ['{{', '}}']\n}\n\nconst templates  = {}\nconst booleanAttrs = /html-(allowfullscreen|async|autofocus|autoplay|checked|controls|default|defer|disabled|formnovalidate|inert|ismap|itemscope|loop|multiple|muted|nomodule|novalidate|open|playsinline|readonly|required|reversed|selected)=\"(.*?)\"/g\nconst htmlAttr = /html-([^\\s]*?)=\"(.*?)\"/g\nconst tagExpr = () => new RegExp(`\\\\${config.tags[0]}(.+?)\\\\${config.tags[1]}`, 'g')\n\nexport const templateConfig = (newconfig) => {\n\tObject.assign( config, newconfig )\n}\n\nexport const template = ( target, { components }) => {\n\n\ttagElements( target, [...Object.keys( components ), '[html-if]', 'template'], components )\n\tconst clone = target.cloneNode( true )\n\n\ttransformTemplate( clone )\n\tremoveTemplateTagsRecursively( clone )\n\tsetTemplates( clone, components )\n\n\treturn templates\n}\n\nexport const compile = ( html ) => {\n\n\tconst parsedHtml = JSON.stringify( html )\n\n\treturn new Function('$element', 'safe', '$g',`\n\t\tvar $data = this;\n\t\twith( $data ){\n\t\t\tvar output=${parsedHtml\n\t\t\t\t.replace(/%%_=(.+?)_%%/g, function(_, variable){\n\t\t\t\t\treturn '\"+safe(function(){return '+ decodeHTML(variable) +';})+\"'\n\t\t\t\t})\n\t\t\t\t.replace(/%%_(.+?)_%%/g, function(_, variable){\n\t\t\t\t\treturn '\";' + decodeHTML(variable) +'\\noutput+=\"'\n\t\t\t\t})};return output;\n\t\t}\n\t`)\n}\n\nconst tagElements = (target, keys, components) => {\n\tconst isComponent = key => key in components\n\tconst selector = keys.join(',')\n\n\ttarget.querySelectorAll(selector).forEach(node => {\n\t\tif (node.localName === 'template') {\n\t\t\ttagElements(node.content, keys, components)\n\t\t\treturn\n\t\t}\n\t\tif (isComponent(node.localName)) {\n\t\t\tnode.setAttribute('tplid', uuid())\n\t\t}\n\t})\n}\n\nconst transformAttributes = (html) => {\n\treturn html\n\t\t.replace(/jails___scope-id/g, '%%_=$scopeid_%%')\n\t\t.replace(tagExpr(), '%%_=$1_%%')\n\t\t.replace(booleanAttrs, `%%_if(safe(function(){ return $2 })){_%%$1%%_}_%%`)\n\t\t.replace(htmlAttr, (all, key, value) => {\n\t\t\tif (['model', 'scopeid'].includes(key)) return all\n\t\t\tif (value) {\n\t\t\t\tvalue = value.replace(/^{|}$/g, '')\n\t\t\t\treturn `${key}=\"%%_=safe(function(){ return ${value} })_%%\"`\n\t\t\t}\n\t\t\treturn all\n\t\t})\n}\n\nconst transformTemplate = ( clone ) => {\n\n\tclone.querySelectorAll('template, [html-for], [html-if], [html-inner], [html-class]')\n\t\t.forEach(( element ) => {\n\n\t\t\tconst htmlFor \t= element.getAttribute('html-for')\n\t\t\tconst htmlIf \t= element.getAttribute('html-if')\n\t\t\tconst htmlInner = element.getAttribute('html-inner')\n\t\t\tconst htmlClass = element.getAttribute('html-class')\n\n\t\t\tif ( htmlFor ) {\n\n\t\t\t\telement.removeAttribute('html-for')\n\n\t\t\t\tconst split \t = htmlFor.match(/(.*)\\sin\\s(.*)/) || ''\n\t\t\t\tconst varname \t = split[1]\n\t\t\t\tconst object \t = split[2]\n\t\t\t\tconst objectname = object.split(/\\./).shift()\n\t\t\t\tconst open \t\t = document.createTextNode(`%%_ ;(function(){ var $index = 0; for(var $key in safe(function(){ return ${object} }) ){ var $scopeid = Math.random().toString(36).substring(2, 9); var ${varname} = ${object}[$key]; $g.scope[$scopeid] = Object.assign({}, { ${objectname}: ${objectname} }, { ${varname} :${varname}, $index: $index, $key: $key }); _%%`)\n\t\t\t\tconst close \t = document.createTextNode(`%%_ $index++; } })() _%%`)\n\n\t\t\t\twrap(open, element, close)\n\t\t\t}\n\n\t\t\tif (htmlIf) {\n\t\t\t\telement.removeAttribute('html-if')\n\t\t\t\tconst open = document.createTextNode(`%%_ if ( safe(function(){ return ${htmlIf} }) ){ _%%`)\n\t\t\t\tconst close = document.createTextNode(`%%_ }  _%%`)\n\t\t\t\twrap(open, element, close)\n\t\t\t}\n\n\t\t\tif (htmlInner) {\n\t\t\t\telement.removeAttribute('html-inner')\n\t\t\t\telement.innerHTML = `%%_=${htmlInner}_%%`\n\t\t\t}\n\n\t\t\tif (htmlClass) {\n\t\t\t\telement.removeAttribute('html-class')\n\t\t\t\telement.className = (element.className + ` %%_=${htmlClass}_%%`).trim()\n\t\t\t}\n\n\t\t\tif( element.localName === 'template' ) {\n\t\t\t\ttransformTemplate(element.content)\n\t\t\t}\n\t\t})\n}\n\nconst setTemplates = ( clone, components ) => {\n\n\tArray.from(clone.querySelectorAll('[tplid]'))\n\t\t.reverse()\n\t\t.forEach((node) => {\n\n\t\t\tconst tplid = node.getAttribute('tplid')\n\t\t\tconst name  = node.localName\n\t\t\tnode.setAttribute('html-scopeid', 'jails___scope-id')\n\n\t\t\tif( name in components && components[name].module.template ) {\n\t\t\t\tconst children = node.innerHTML\n\t\t\t\tconst html = components[name].module.template({ elm:node, children })\n\t\t\t\tnode.innerHTML = html\n\t\t\t\ttransformTemplate(node)\n\t\t\t\tremoveTemplateTagsRecursively(node)\n\t\t\t}\n\n\t\t\tconst html = transformAttributes(node.outerHTML)\n\n\t\t\ttemplates[ tplid ] = {\n\t\t\t\ttemplate: html,\n\t\t\t\trender\t: compile(html)\n\t\t\t}\n\t\t})\n}\n\nconst removeTemplateTagsRecursively = (node) => {\n\n\t// Get all <template> elements within the node\n\tconst templates = node.querySelectorAll('template')\n\n\ttemplates.forEach((template) => {\n\n\t\tif( template.getAttribute('html-if') || template.getAttribute('html-inner') ) {\n\t\t\treturn\n\t\t}\n\n\t\t// Process any nested <template> tags within this <template> first\n\t\tremoveTemplateTagsRecursively(template.content)\n\n\t\t// Get the parent of the <template> tag\n\t\tconst parent = template.parentNode\n\n\t\tif (parent) {\n\t\t\t// Move all child nodes from the <template>'s content to its parent\n\t\t\tconst content = template.content\n\t\t\twhile (content.firstChild) {\n\t\t\t\tparent.insertBefore(content.firstChild, template)\n\t\t\t}\n\t\t\t// Remove the <template> tag itself\n\t\t\tparent.removeChild(template)\n\t\t}\n\t})\n}\n\n\nconst wrap = (open, node, close) => {\n\tnode.parentNode?.insertBefore(open, node)\n\tnode.parentNode?.insertBefore(close, node.nextSibling)\n}\n","\nimport { Element } from './element'\nimport { template, templateConfig as config } from './template-system'\n\nexport { publish, subscribe } from './utils/pubsub'\n\nexport const templateConfig = (options) => {\n\tconfig( options )\n}\n\nglobalThis.__jails__ = globalThis.__jails__ || { components: {} }\n\nexport const register = ( name, module, dependencies ) => {\n\tconst { components } = globalThis.__jails__\n\tcomponents[ name ] = { name, module, dependencies }\n}\n\nexport const start = ( target ) => {\n\n\t// If the code is running in a Node.js environment, do nothing\n\tif( typeof window === 'undefined' ) {\n\t\treturn;\n\t}\n\n\ttarget = target || document.body\n\tconst { components } = globalThis.__jails__\n\tconst templates = template( target, { components } )\n\n\tObject\n\t\t.values( components )\n\t\t.forEach(({ name, module, dependencies }) => {\n\t\t\tif( !customElements.get(name) ) {\n\t\t\t\tcustomElements.define( name, Element({ component: { name, module, dependencies }, templates, start }))\n\t\t\t}\n\t})\n}\n"],"names":["range","doc","document","HAS_TEMPLATE_SUPPORT","createElement","HAS_RANGE_SUPPORT","createRange","toElement","str","trim","template","innerHTML","content","childNodes","createFragmentFromTemplate","selectNode","body","createContextualFragment","createFragmentFromRange","fragment","createFragmentFromWrap","compareNodeNames","fromEl","toEl","fromCodeStart","toCodeStart","fromNodeName","nodeName","toNodeName","charCodeAt","toUpperCase","syncBooleanAttrProp","name","setAttribute","removeAttribute","specialElHandlers","OPTION","parentNode","parentName","hasAttribute","selected","selectedIndex","INPUT","value","TEXTAREA","newValue","firstChild","oldValue","nodeValue","placeholder","SELECT","optgroup","i","curChild","nextSibling","noop","defaultGetNodeKey","node","getAttribute","id","morphAttrs","morphdom","fromNode","toNode","attr","attrName","attrNamespaceURI","attrValue","toNodeAttrs","attributes","nodeType","length","namespaceURI","localName","getAttributeNS","prefix","setAttributeNS","fromNodeAttrs","d","hasAttributeNS","removeAttributeNS","options","toNodeHtml","firstElementChild","getNodeKey","onBeforeNodeAdded","onNodeAdded","onBeforeElUpdated","onElUpdated","onBeforeNodeDiscarded","onNodeDiscarded","onBeforeElChildrenUpdated","skipFromChildren","addChild","parent","child","appendChild","childrenOnly","fromNodesLookup","Object","create","keyedRemovalList","addKeyedRemoval","key","push","walkDiscardedChildNodes","skipKeyedNodes","removeNode","removeChild","indexTree","handleNodeAdded","el","unmatchedFromEl","replaceChild","morphEl","toElKey","beforeUpdateResult","HTMLElement","curToNodeKey","curFromNodeKey","fromNextSibling","toNextSibling","matchingFromEl","skipFrom","curToNodeChild","curFromNodeChild","outer","isSameNode","curFromNodeType","isCompatible","insertBefore","onBeforeNodeAddedResult","actualize","ownerDocument","cleanupFromEl","specialElHandler","morphChildren","morphedNode","morphedNodeType","toNodeType","nextChild","moveChildren","createElementNS","len","elToRemove","textarea","g","scope","decodeHTML","text","safe","execute","val","err","topics","_async","publish","params","isObject","assign","forEach","topic","subscribe","method","filter","fn","Array","isArray","Component","module","dependencies","templates","signal","register","tick","preserve","observer","observables","effect","_model","model","initialState","Function","tplid","scopeid","tpl","o","_a","apply","elm","JSON","parse","stringify","state","view","data","base","main","addEventListener","query","selector","from","querySelectorAll","map","element","Promise","resolve","reject","contains","protected","list","save","constructor","set","newstate","render","get","dataset","target","isNaN","Number","e","on","ev","selectorOrCallback","callback","attribute","match","MutationObserver","mutationsList","mutation","type","attrname","attributeName","item","observe","subtree","disconnect","handler","detail","matches","delegateTarget","concat","args","capture","off","removeEventListener","trigger","String","children","dispatchEvent","CustomEvent","bubbles","emit","unmount","html_","clone","cloneNode","html","clearTimeout","setTimeout","call","__spreadValues","morphOptions","then","__scope__","useEffect","promise","default","update","onBeforeChildElUpdated","newnode","WeakMap","Element","component","start","super","connectedCallback","this","abortController","AbortController","rtrn","disconnectedCallback","abort","config","tags","booleanAttrs","htmlAttr","compile","parsedHtml","replace","_","variable","tagElements","keys","components","join","Math","random","toString","substring","transformAttributes","RegExp","all","includes","transformTemplate","htmlFor","htmlIf","htmlInner","htmlClass","split","varname","object","objectname","shift","open","createTextNode","close","wrap","className","setTemplates","reverse","removeTemplateTagsRecursively","outerHTML","_b","globalThis","__jails__","window","values","customElements","define","newconfig"],"mappings":"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","x_google_ignoreList":[0]}