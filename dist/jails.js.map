{"version":3,"file":"jails.js","sources":["../src/utils/index.ts","../node_modules/idiomorph/dist/idiomorph.esm.js","../src/utils/pubsub.ts","../src/component.ts","../src/element.ts","../src/template-system.ts","../src/index.ts"],"sourcesContent":["let textarea\n\nexport const g = {\n\tscope: {}\n}\n\nexport const decodeHTML = (text) => {\n\ttextarea = textarea || document.createElement('textarea')\n\ttextarea.innerHTML = text\n\treturn textarea.value\n}\n\nexport const rAF = (fn) => {\n\tif (requestAnimationFrame)\n\t\treturn requestAnimationFrame(fn)\n\telse\n\t\treturn setTimeout(fn, 1000 / 60)\n}\n\nexport const uuid = () => {\n\treturn Math.random().toString(36).substring(2, 9)\n}\n\nexport const dup = (o) => {\n\treturn JSON.parse(JSON.stringify(o))\n}\n\nexport const safe = (execute, val) => {\n\ttry{\n\t\tconst value = execute()\n\t\treturn value !== undefined && value !== null ? value : val || ''\n\t}catch(err){\n\t\treturn val || ''\n\t}\n}\n","/**\n * @typedef {object} ConfigHead\n *\n * @property {'merge' | 'append' | 'morph' | 'none'} [style]\n * @property {boolean} [block]\n * @property {boolean} [ignore]\n * @property {function(Element): boolean} [shouldPreserve]\n * @property {function(Element): boolean} [shouldReAppend]\n * @property {function(Element): boolean} [shouldRemove]\n * @property {function(Element, {added: Node[], kept: Element[], removed: Element[]}): void} [afterHeadMorphed]\n */\n\n/**\n * @typedef {object} ConfigCallbacks\n *\n * @property {function(Node): boolean} [beforeNodeAdded]\n * @property {function(Node): void} [afterNodeAdded]\n * @property {function(Element, Node): boolean} [beforeNodeMorphed]\n * @property {function(Element, Node): void} [afterNodeMorphed]\n * @property {function(Element): boolean} [beforeNodeRemoved]\n * @property {function(Element): void} [afterNodeRemoved]\n * @property {function(string, Element, \"update\" | \"remove\"): boolean} [beforeAttributeUpdated]\n */\n\n/**\n * @typedef {object} Config\n *\n * @property {'outerHTML' | 'innerHTML'} [morphStyle]\n * @property {boolean} [ignoreActive]\n * @property {boolean} [ignoreActiveValue]\n * @property {boolean} [restoreFocus]\n * @property {ConfigCallbacks} [callbacks]\n * @property {ConfigHead} [head]\n */\n\n/**\n * @typedef {function} NoOp\n *\n * @returns {void}\n */\n\n/**\n * @typedef {object} ConfigHeadInternal\n *\n * @property {'merge' | 'append' | 'morph' | 'none'} style\n * @property {boolean} [block]\n * @property {boolean} [ignore]\n * @property {(function(Element): boolean) | NoOp} shouldPreserve\n * @property {(function(Element): boolean) | NoOp} shouldReAppend\n * @property {(function(Element): boolean) | NoOp} shouldRemove\n * @property {(function(Element, {added: Node[], kept: Element[], removed: Element[]}): void) | NoOp} afterHeadMorphed\n */\n\n/**\n * @typedef {object} ConfigCallbacksInternal\n *\n * @property {(function(Node): boolean) | NoOp} beforeNodeAdded\n * @property {(function(Node): void) | NoOp} afterNodeAdded\n * @property {(function(Node, Node): boolean) | NoOp} beforeNodeMorphed\n * @property {(function(Node, Node): void) | NoOp} afterNodeMorphed\n * @property {(function(Node): boolean) | NoOp} beforeNodeRemoved\n * @property {(function(Node): void) | NoOp} afterNodeRemoved\n * @property {(function(string, Element, \"update\" | \"remove\"): boolean) | NoOp} beforeAttributeUpdated\n */\n\n/**\n * @typedef {object} ConfigInternal\n *\n * @property {'outerHTML' | 'innerHTML'} morphStyle\n * @property {boolean} [ignoreActive]\n * @property {boolean} [ignoreActiveValue]\n * @property {boolean} [restoreFocus]\n * @property {ConfigCallbacksInternal} callbacks\n * @property {ConfigHeadInternal} head\n */\n\n/**\n * @typedef {Object} IdSets\n * @property {Set<string>} persistentIds\n * @property {Map<Node, Set<string>>} idMap\n */\n\n/**\n * @typedef {Function} Morph\n *\n * @param {Element | Document} oldNode\n * @param {Element | Node | HTMLCollection | Node[] | string | null} newContent\n * @param {Config} [config]\n * @returns {undefined | Node[]}\n */\n\n// base IIFE to define idiomorph\n/**\n *\n * @type {{defaults: ConfigInternal, morph: Morph}}\n */\nvar Idiomorph = (function () {\n  \"use strict\";\n\n  /**\n   * @typedef {object} MorphContext\n   *\n   * @property {Element} target\n   * @property {Element} newContent\n   * @property {ConfigInternal} config\n   * @property {ConfigInternal['morphStyle']} morphStyle\n   * @property {ConfigInternal['ignoreActive']} ignoreActive\n   * @property {ConfigInternal['ignoreActiveValue']} ignoreActiveValue\n   * @property {ConfigInternal['restoreFocus']} restoreFocus\n   * @property {Map<Node, Set<string>>} idMap\n   * @property {Set<string>} persistentIds\n   * @property {ConfigInternal['callbacks']} callbacks\n   * @property {ConfigInternal['head']} head\n   * @property {HTMLDivElement} pantry\n   * @property {Element[]} activeElementAndParents\n   */\n\n  //=============================================================================\n  // AND NOW IT BEGINS...\n  //=============================================================================\n\n  const noOp = () => {};\n  /**\n   * Default configuration values, updatable by users now\n   * @type {ConfigInternal}\n   */\n  const defaults = {\n    morphStyle: \"outerHTML\",\n    callbacks: {\n      beforeNodeAdded: noOp,\n      afterNodeAdded: noOp,\n      beforeNodeMorphed: noOp,\n      afterNodeMorphed: noOp,\n      beforeNodeRemoved: noOp,\n      afterNodeRemoved: noOp,\n      beforeAttributeUpdated: noOp,\n    },\n    head: {\n      style: \"merge\",\n      shouldPreserve: (elt) => elt.getAttribute(\"im-preserve\") === \"true\",\n      shouldReAppend: (elt) => elt.getAttribute(\"im-re-append\") === \"true\",\n      shouldRemove: noOp,\n      afterHeadMorphed: noOp,\n    },\n    restoreFocus: true,\n  };\n\n  /**\n   * Core idiomorph function for morphing one DOM tree to another\n   *\n   * @param {Element | Document} oldNode\n   * @param {Element | Node | HTMLCollection | Node[] | string | null} newContent\n   * @param {Config} [config]\n   * @returns {Promise<Node[]> | Node[]}\n   */\n  function morph(oldNode, newContent, config = {}) {\n    oldNode = normalizeElement(oldNode);\n    const newNode = normalizeParent(newContent);\n    const ctx = createMorphContext(oldNode, newNode, config);\n\n    const morphedNodes = saveAndRestoreFocus(ctx, () => {\n      return withHeadBlocking(\n        ctx,\n        oldNode,\n        newNode,\n        /** @param {MorphContext} ctx */ (ctx) => {\n          if (ctx.morphStyle === \"innerHTML\") {\n            morphChildren(ctx, oldNode, newNode);\n            return Array.from(oldNode.childNodes);\n          } else {\n            return morphOuterHTML(ctx, oldNode, newNode);\n          }\n        },\n      );\n    });\n\n    ctx.pantry.remove();\n    return morphedNodes;\n  }\n\n  /**\n   * Morph just the outerHTML of the oldNode to the newContent\n   * We have to be careful because the oldNode could have siblings which need to be untouched\n   * @param {MorphContext} ctx\n   * @param {Element} oldNode\n   * @param {Element} newNode\n   * @returns {Node[]}\n   */\n  function morphOuterHTML(ctx, oldNode, newNode) {\n    const oldParent = normalizeParent(oldNode);\n    morphChildren(\n      ctx,\n      oldParent,\n      newNode,\n      // these two optional params are the secret sauce\n      oldNode, // start point for iteration\n      oldNode.nextSibling, // end point for iteration\n    );\n    // this is safe even with siblings, because normalizeParent returns a SlicedParentNode if needed.\n    return Array.from(oldParent.childNodes);\n  }\n\n  /**\n   * @param {MorphContext} ctx\n   * @param {Function} fn\n   * @returns {Promise<Node[]> | Node[]}\n   */\n  function saveAndRestoreFocus(ctx, fn) {\n    if (!ctx.config.restoreFocus) return fn();\n    let activeElement =\n      /** @type {HTMLInputElement|HTMLTextAreaElement|null} */ (\n        document.activeElement\n      );\n\n    // don't bother if the active element is not an input or textarea\n    if (\n      !(\n        activeElement instanceof HTMLInputElement ||\n        activeElement instanceof HTMLTextAreaElement\n      )\n    ) {\n      return fn();\n    }\n\n    const { id: activeElementId, selectionStart, selectionEnd } = activeElement;\n\n    const results = fn();\n\n    if (\n      activeElementId &&\n      activeElementId !== document.activeElement?.getAttribute(\"id\")\n    ) {\n      activeElement = ctx.target.querySelector(`[id=\"${activeElementId}\"]`);\n      activeElement?.focus();\n    }\n    if (activeElement && !activeElement.selectionEnd && selectionEnd) {\n      activeElement.setSelectionRange(selectionStart, selectionEnd);\n    }\n\n    return results;\n  }\n\n  const morphChildren = (function () {\n    /**\n     * This is the core algorithm for matching up children.  The idea is to use id sets to try to match up\n     * nodes as faithfully as possible.  We greedily match, which allows us to keep the algorithm fast, but\n     * by using id sets, we are able to better match up with content deeper in the DOM.\n     *\n     * Basic algorithm:\n     * - for each node in the new content:\n     *   - search self and siblings for an id set match, falling back to a soft match\n     *   - if match found\n     *     - remove any nodes up to the match:\n     *       - pantry persistent nodes\n     *       - delete the rest\n     *     - morph the match\n     *   - elsif no match found, and node is persistent\n     *     - find its match by querying the old root (future) and pantry (past)\n     *     - move it and its children here\n     *     - morph it\n     *   - else\n     *     - create a new node from scratch as a last result\n     *\n     * @param {MorphContext} ctx the merge context\n     * @param {Element} oldParent the old content that we are merging the new content into\n     * @param {Element} newParent the parent element of the new content\n     * @param {Node|null} [insertionPoint] the point in the DOM we start morphing at (defaults to first child)\n     * @param {Node|null} [endPoint] the point in the DOM we stop morphing at (defaults to after last child)\n     */\n    function morphChildren(\n      ctx,\n      oldParent,\n      newParent,\n      insertionPoint = null,\n      endPoint = null,\n    ) {\n      // normalize\n      if (\n        oldParent instanceof HTMLTemplateElement &&\n        newParent instanceof HTMLTemplateElement\n      ) {\n        // @ts-ignore we can pretend the DocumentFragment is an Element\n        oldParent = oldParent.content;\n        // @ts-ignore ditto\n        newParent = newParent.content;\n      }\n      insertionPoint ||= oldParent.firstChild;\n\n      // run through all the new content\n      for (const newChild of newParent.childNodes) {\n        // once we reach the end of the old parent content skip to the end and insert the rest\n        if (insertionPoint && insertionPoint != endPoint) {\n          const bestMatch = findBestMatch(\n            ctx,\n            newChild,\n            insertionPoint,\n            endPoint,\n          );\n          if (bestMatch) {\n            // if the node to morph is not at the insertion point then remove/move up to it\n            if (bestMatch !== insertionPoint) {\n              removeNodesBetween(ctx, insertionPoint, bestMatch);\n            }\n            morphNode(bestMatch, newChild, ctx);\n            insertionPoint = bestMatch.nextSibling;\n            continue;\n          }\n        }\n\n        // if the matching node is elsewhere in the original content\n        if (newChild instanceof Element) {\n          // we can pretend the id is non-null because the next `.has` line will reject it if not\n          const newChildId = /** @type {String} */ (\n            newChild.getAttribute(\"id\")\n          );\n          if (ctx.persistentIds.has(newChildId)) {\n            // move it and all its children here and morph\n            const movedChild = moveBeforeById(\n              oldParent,\n              newChildId,\n              insertionPoint,\n              ctx,\n            );\n            morphNode(movedChild, newChild, ctx);\n            insertionPoint = movedChild.nextSibling;\n            continue;\n          }\n        }\n\n        // last resort: insert the new node from scratch\n        const insertedNode = createNode(\n          oldParent,\n          newChild,\n          insertionPoint,\n          ctx,\n        );\n        // could be null if beforeNodeAdded prevented insertion\n        if (insertedNode) {\n          insertionPoint = insertedNode.nextSibling;\n        }\n      }\n\n      // remove any remaining old nodes that didn't match up with new content\n      while (insertionPoint && insertionPoint != endPoint) {\n        const tempNode = insertionPoint;\n        insertionPoint = insertionPoint.nextSibling;\n        removeNode(ctx, tempNode);\n      }\n    }\n\n    /**\n     * This performs the action of inserting a new node while handling situations where the node contains\n     * elements with persistent ids and possible state info we can still preserve by moving in and then morphing\n     *\n     * @param {Element} oldParent\n     * @param {Node} newChild\n     * @param {Node|null} insertionPoint\n     * @param {MorphContext} ctx\n     * @returns {Node|null}\n     */\n    function createNode(oldParent, newChild, insertionPoint, ctx) {\n      if (ctx.callbacks.beforeNodeAdded(newChild) === false) return null;\n      if (ctx.idMap.has(newChild)) {\n        // node has children with ids with possible state so create a dummy elt of same type and apply full morph algorithm\n        const newEmptyChild = document.createElement(\n          /** @type {Element} */ (newChild).tagName,\n        );\n        oldParent.insertBefore(newEmptyChild, insertionPoint);\n        morphNode(newEmptyChild, newChild, ctx);\n        ctx.callbacks.afterNodeAdded(newEmptyChild);\n        return newEmptyChild;\n      } else {\n        // optimisation: no id state to preserve so we can just insert a clone of the newChild and its descendants\n        const newClonedChild = document.importNode(newChild, true); // importNode to not mutate newParent\n        oldParent.insertBefore(newClonedChild, insertionPoint);\n        ctx.callbacks.afterNodeAdded(newClonedChild);\n        return newClonedChild;\n      }\n    }\n\n    //=============================================================================\n    // Matching Functions\n    //=============================================================================\n    const findBestMatch = (function () {\n      /**\n       * Scans forward from the startPoint to the endPoint looking for a match\n       * for the node. It looks for an id set match first, then a soft match.\n       * We abort softmatching if we find two future soft matches, to reduce churn.\n       * @param {Node} node\n       * @param {MorphContext} ctx\n       * @param {Node | null} startPoint\n       * @param {Node | null} endPoint\n       * @returns {Node | null}\n       */\n      function findBestMatch(ctx, node, startPoint, endPoint) {\n        let softMatch = null;\n        let nextSibling = node.nextSibling;\n        let siblingSoftMatchCount = 0;\n\n        let cursor = startPoint;\n        while (cursor && cursor != endPoint) {\n          // soft matching is a prerequisite for id set matching\n          if (isSoftMatch(cursor, node)) {\n            if (isIdSetMatch(ctx, cursor, node)) {\n              return cursor; // found an id set match, we're done!\n            }\n\n            // we haven't yet saved a soft match fallback\n            if (softMatch === null) {\n              // the current soft match will hard match something else in the future, leave it\n              if (!ctx.idMap.has(cursor)) {\n                // save this as the fallback if we get through the loop without finding a hard match\n                softMatch = cursor;\n              }\n            }\n          }\n          if (\n            softMatch === null &&\n            nextSibling &&\n            isSoftMatch(cursor, nextSibling)\n          ) {\n            // The next new node has a soft match with this node, so\n            // increment the count of future soft matches\n            siblingSoftMatchCount++;\n            nextSibling = nextSibling.nextSibling;\n\n            // If there are two future soft matches, block soft matching for this node to allow\n            // future siblings to soft match. This is to reduce churn in the DOM when an element\n            // is prepended.\n            if (siblingSoftMatchCount >= 2) {\n              softMatch = undefined;\n            }\n          }\n\n          // if the current node contains active element, stop looking for better future matches,\n          // because if one is found, this node will be moved to the pantry, reparenting it and thus losing focus\n          // @ts-ignore pretend cursor is Element rather than Node, we're just testing for array inclusion\n          if (ctx.activeElementAndParents.includes(cursor)) break;\n\n          cursor = cursor.nextSibling;\n        }\n\n        return softMatch || null;\n      }\n\n      /**\n       *\n       * @param {MorphContext} ctx\n       * @param {Node} oldNode\n       * @param {Node} newNode\n       * @returns {boolean}\n       */\n      function isIdSetMatch(ctx, oldNode, newNode) {\n        let oldSet = ctx.idMap.get(oldNode);\n        let newSet = ctx.idMap.get(newNode);\n\n        if (!newSet || !oldSet) return false;\n\n        for (const id of oldSet) {\n          // a potential match is an id in the new and old nodes that\n          // has not already been merged into the DOM\n          // But the newNode content we call this on has not been\n          // merged yet and we don't allow duplicate IDs so it is simple\n          if (newSet.has(id)) {\n            return true;\n          }\n        }\n        return false;\n      }\n\n      /**\n       *\n       * @param {Node} oldNode\n       * @param {Node} newNode\n       * @returns {boolean}\n       */\n      function isSoftMatch(oldNode, newNode) {\n        // ok to cast: if one is not element, `id` and `tagName` will be undefined and we'll just compare that.\n        const oldElt = /** @type {Element} */ (oldNode);\n        const newElt = /** @type {Element} */ (newNode);\n\n        return (\n          oldElt.nodeType === newElt.nodeType &&\n          oldElt.tagName === newElt.tagName &&\n          // If oldElt has an `id` with possible state and it doesn't match newElt.id then avoid morphing.\n          // We'll still match an anonymous node with an IDed newElt, though, because if it got this far,\n          // its not persistent, and new nodes can't have any hidden state.\n          // We can't use .id because of form input shadowing, and we can't count on .getAttribute's presence because it could be a document-fragment\n          (!oldElt.getAttribute?.(\"id\") ||\n            oldElt.getAttribute?.(\"id\") === newElt.getAttribute?.(\"id\"))\n        );\n      }\n\n      return findBestMatch;\n    })();\n\n    //=============================================================================\n    // DOM Manipulation Functions\n    //=============================================================================\n\n    /**\n     * Gets rid of an unwanted DOM node; strategy depends on nature of its reuse:\n     * - Persistent nodes will be moved to the pantry for later reuse\n     * - Other nodes will have their hooks called, and then are removed\n     * @param {MorphContext} ctx\n     * @param {Node} node\n     */\n    function removeNode(ctx, node) {\n      // are we going to id set match this later?\n      if (ctx.idMap.has(node)) {\n        // skip callbacks and move to pantry\n        moveBefore(ctx.pantry, node, null);\n      } else {\n        // remove for realsies\n        if (ctx.callbacks.beforeNodeRemoved(node) === false) return;\n        node.parentNode?.removeChild(node);\n        ctx.callbacks.afterNodeRemoved(node);\n      }\n    }\n\n    /**\n     * Remove nodes between the start and end nodes\n     * @param {MorphContext} ctx\n     * @param {Node} startInclusive\n     * @param {Node} endExclusive\n     * @returns {Node|null}\n     */\n    function removeNodesBetween(ctx, startInclusive, endExclusive) {\n      /** @type {Node | null} */\n      let cursor = startInclusive;\n      // remove nodes until the endExclusive node\n      while (cursor && cursor !== endExclusive) {\n        let tempNode = /** @type {Node} */ (cursor);\n        cursor = cursor.nextSibling;\n        removeNode(ctx, tempNode);\n      }\n      return cursor;\n    }\n\n    /**\n     * Search for an element by id within the document and pantry, and move it using moveBefore.\n     *\n     * @param {Element} parentNode - The parent node to which the element will be moved.\n     * @param {string} id - The ID of the element to be moved.\n     * @param {Node | null} after - The reference node to insert the element before.\n     *                              If `null`, the element is appended as the last child.\n     * @param {MorphContext} ctx\n     * @returns {Element} The found element\n     */\n    function moveBeforeById(parentNode, id, after, ctx) {\n      const target =\n        /** @type {Element} - will always be found */\n        (\n          // ctx.target.id unsafe because of form input shadowing\n          // ctx.target could be a document fragment which doesn't have `getAttribute`\n          (ctx.target.getAttribute?.(\"id\") === id && ctx.target) ||\n            ctx.target.querySelector(`[id=\"${id}\"]`) ||\n            ctx.pantry.querySelector(`[id=\"${id}\"]`)\n        );\n      removeElementFromAncestorsIdMaps(target, ctx);\n      moveBefore(parentNode, target, after);\n      return target;\n    }\n\n    /**\n     * Removes an element from its ancestors' id maps. This is needed when an element is moved from the\n     * \"future\" via `moveBeforeId`. Otherwise, its erstwhile ancestors could be mistakenly moved to the\n     * pantry rather than being deleted, preventing their removal hooks from being called.\n     *\n     * @param {Element} element - element to remove from its ancestors' id maps\n     * @param {MorphContext} ctx\n     */\n    function removeElementFromAncestorsIdMaps(element, ctx) {\n      // we know id is non-null String, because this function is only called on elements with ids\n      const id = /** @type {String} */ (element.getAttribute(\"id\"));\n      /** @ts-ignore - safe to loop in this way **/\n      while ((element = element.parentNode)) {\n        let idSet = ctx.idMap.get(element);\n        if (idSet) {\n          idSet.delete(id);\n          if (!idSet.size) {\n            ctx.idMap.delete(element);\n          }\n        }\n      }\n    }\n\n    /**\n     * Moves an element before another element within the same parent.\n     * Uses the proposed `moveBefore` API if available (and working), otherwise falls back to `insertBefore`.\n     * This is essentialy a forward-compat wrapper.\n     *\n     * @param {Element} parentNode - The parent node containing the after element.\n     * @param {Node} element - The element to be moved.\n     * @param {Node | null} after - The reference node to insert `element` before.\n     *                              If `null`, `element` is appended as the last child.\n     */\n    function moveBefore(parentNode, element, after) {\n      // @ts-ignore - use proposed moveBefore feature\n      if (parentNode.moveBefore) {\n        try {\n          // @ts-ignore - use proposed moveBefore feature\n          parentNode.moveBefore(element, after);\n        } catch (e) {\n          // fall back to insertBefore as some browsers may fail on moveBefore when trying to move Dom disconnected nodes to pantry\n          parentNode.insertBefore(element, after);\n        }\n      } else {\n        parentNode.insertBefore(element, after);\n      }\n    }\n\n    return morphChildren;\n  })();\n\n  //=============================================================================\n  // Single Node Morphing Code\n  //=============================================================================\n  const morphNode = (function () {\n    /**\n     * @param {Node} oldNode root node to merge content into\n     * @param {Node} newContent new content to merge\n     * @param {MorphContext} ctx the merge context\n     * @returns {Node | null} the element that ended up in the DOM\n     */\n    function morphNode(oldNode, newContent, ctx) {\n      if (ctx.ignoreActive && oldNode === document.activeElement) {\n        // don't morph focused element\n        return null;\n      }\n\n      if (ctx.callbacks.beforeNodeMorphed(oldNode, newContent) === false) {\n        return oldNode;\n      }\n\n      if (oldNode instanceof HTMLHeadElement && ctx.head.ignore) {\n        // ignore the head element\n      } else if (\n        oldNode instanceof HTMLHeadElement &&\n        ctx.head.style !== \"morph\"\n      ) {\n        // ok to cast: if newContent wasn't also a <head>, it would've got caught in the `!isSoftMatch` branch above\n        handleHeadElement(\n          oldNode,\n          /** @type {HTMLHeadElement} */ (newContent),\n          ctx,\n        );\n      } else {\n        morphAttributes(oldNode, newContent, ctx);\n        if (!ignoreValueOfActiveElement(oldNode, ctx)) {\n          // @ts-ignore newContent can be a node here because .firstChild will be null\n          morphChildren(ctx, oldNode, newContent);\n        }\n      }\n      ctx.callbacks.afterNodeMorphed(oldNode, newContent);\n      return oldNode;\n    }\n\n    /**\n     * syncs the oldNode to the newNode, copying over all attributes and\n     * inner element state from the newNode to the oldNode\n     *\n     * @param {Node} oldNode the node to copy attributes & state to\n     * @param {Node} newNode the node to copy attributes & state from\n     * @param {MorphContext} ctx the merge context\n     */\n    function morphAttributes(oldNode, newNode, ctx) {\n      let type = newNode.nodeType;\n\n      // if is an element type, sync the attributes from the\n      // new node into the new node\n      if (type === 1 /* element type */) {\n        const oldElt = /** @type {Element} */ (oldNode);\n        const newElt = /** @type {Element} */ (newNode);\n\n        const oldAttributes = oldElt.attributes;\n        const newAttributes = newElt.attributes;\n        for (const newAttribute of newAttributes) {\n          if (ignoreAttribute(newAttribute.name, oldElt, \"update\", ctx)) {\n            continue;\n          }\n          if (oldElt.getAttribute(newAttribute.name) !== newAttribute.value) {\n            oldElt.setAttribute(newAttribute.name, newAttribute.value);\n          }\n        }\n        // iterate backwards to avoid skipping over items when a delete occurs\n        for (let i = oldAttributes.length - 1; 0 <= i; i--) {\n          const oldAttribute = oldAttributes[i];\n\n          // toAttributes is a live NamedNodeMap, so iteration+mutation is unsafe\n          // e.g. custom element attribute callbacks can remove other attributes\n          if (!oldAttribute) continue;\n\n          if (!newElt.hasAttribute(oldAttribute.name)) {\n            if (ignoreAttribute(oldAttribute.name, oldElt, \"remove\", ctx)) {\n              continue;\n            }\n            oldElt.removeAttribute(oldAttribute.name);\n          }\n        }\n\n        if (!ignoreValueOfActiveElement(oldElt, ctx)) {\n          syncInputValue(oldElt, newElt, ctx);\n        }\n      }\n\n      // sync text nodes\n      if (type === 8 /* comment */ || type === 3 /* text */) {\n        if (oldNode.nodeValue !== newNode.nodeValue) {\n          oldNode.nodeValue = newNode.nodeValue;\n        }\n      }\n    }\n\n    /**\n     * NB: many bothans died to bring us information:\n     *\n     *  https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n     *  https://github.com/choojs/nanomorph/blob/master/lib/morph.jsL113\n     *\n     * @param {Element} oldElement the element to sync the input value to\n     * @param {Element} newElement the element to sync the input value from\n     * @param {MorphContext} ctx the merge context\n     */\n    function syncInputValue(oldElement, newElement, ctx) {\n      if (\n        oldElement instanceof HTMLInputElement &&\n        newElement instanceof HTMLInputElement &&\n        newElement.type !== \"file\"\n      ) {\n        let newValue = newElement.value;\n        let oldValue = oldElement.value;\n\n        // sync boolean attributes\n        syncBooleanAttribute(oldElement, newElement, \"checked\", ctx);\n        syncBooleanAttribute(oldElement, newElement, \"disabled\", ctx);\n\n        if (!newElement.hasAttribute(\"value\")) {\n          if (!ignoreAttribute(\"value\", oldElement, \"remove\", ctx)) {\n            oldElement.value = \"\";\n            oldElement.removeAttribute(\"value\");\n          }\n        } else if (oldValue !== newValue) {\n          if (!ignoreAttribute(\"value\", oldElement, \"update\", ctx)) {\n            oldElement.setAttribute(\"value\", newValue);\n            oldElement.value = newValue;\n          }\n        }\n        // TODO: QUESTION(1cg): this used to only check `newElement` unlike the other branches -- why?\n        // did I break something?\n      } else if (\n        oldElement instanceof HTMLOptionElement &&\n        newElement instanceof HTMLOptionElement\n      ) {\n        syncBooleanAttribute(oldElement, newElement, \"selected\", ctx);\n      } else if (\n        oldElement instanceof HTMLTextAreaElement &&\n        newElement instanceof HTMLTextAreaElement\n      ) {\n        let newValue = newElement.value;\n        let oldValue = oldElement.value;\n        if (ignoreAttribute(\"value\", oldElement, \"update\", ctx)) {\n          return;\n        }\n        if (newValue !== oldValue) {\n          oldElement.value = newValue;\n        }\n        if (\n          oldElement.firstChild &&\n          oldElement.firstChild.nodeValue !== newValue\n        ) {\n          oldElement.firstChild.nodeValue = newValue;\n        }\n      }\n    }\n\n    /**\n     * @param {Element} oldElement element to write the value to\n     * @param {Element} newElement element to read the value from\n     * @param {string} attributeName the attribute name\n     * @param {MorphContext} ctx the merge context\n     */\n    function syncBooleanAttribute(oldElement, newElement, attributeName, ctx) {\n      // @ts-ignore this function is only used on boolean attrs that are reflected as dom properties\n      const newLiveValue = newElement[attributeName],\n        // @ts-ignore ditto\n        oldLiveValue = oldElement[attributeName];\n      if (newLiveValue !== oldLiveValue) {\n        const ignoreUpdate = ignoreAttribute(\n          attributeName,\n          oldElement,\n          \"update\",\n          ctx,\n        );\n        if (!ignoreUpdate) {\n          // update attribute's associated DOM property\n          // @ts-ignore this function is only used on boolean attrs that are reflected as dom properties\n          oldElement[attributeName] = newElement[attributeName];\n        }\n        if (newLiveValue) {\n          if (!ignoreUpdate) {\n            // https://developer.mozilla.org/en-US/docs/Glossary/Boolean/HTML\n            // this is the correct way to set a boolean attribute to \"true\"\n            oldElement.setAttribute(attributeName, \"\");\n          }\n        } else {\n          if (!ignoreAttribute(attributeName, oldElement, \"remove\", ctx)) {\n            oldElement.removeAttribute(attributeName);\n          }\n        }\n      }\n    }\n\n    /**\n     * @param {string} attr the attribute to be mutated\n     * @param {Element} element the element that is going to be updated\n     * @param {\"update\" | \"remove\"} updateType\n     * @param {MorphContext} ctx the merge context\n     * @returns {boolean} true if the attribute should be ignored, false otherwise\n     */\n    function ignoreAttribute(attr, element, updateType, ctx) {\n      if (\n        attr === \"value\" &&\n        ctx.ignoreActiveValue &&\n        element === document.activeElement\n      ) {\n        return true;\n      }\n      return (\n        ctx.callbacks.beforeAttributeUpdated(attr, element, updateType) ===\n        false\n      );\n    }\n\n    /**\n     * @param {Node} possibleActiveElement\n     * @param {MorphContext} ctx\n     * @returns {boolean}\n     */\n    function ignoreValueOfActiveElement(possibleActiveElement, ctx) {\n      return (\n        !!ctx.ignoreActiveValue &&\n        possibleActiveElement === document.activeElement &&\n        possibleActiveElement !== document.body\n      );\n    }\n\n    return morphNode;\n  })();\n\n  //=============================================================================\n  // Head Management Functions\n  //=============================================================================\n  /**\n   * @param {MorphContext} ctx\n   * @param {Element} oldNode\n   * @param {Element} newNode\n   * @param {function} callback\n   * @returns {Node[] | Promise<Node[]>}\n   */\n  function withHeadBlocking(ctx, oldNode, newNode, callback) {\n    if (ctx.head.block) {\n      const oldHead = oldNode.querySelector(\"head\");\n      const newHead = newNode.querySelector(\"head\");\n      if (oldHead && newHead) {\n        const promises = handleHeadElement(oldHead, newHead, ctx);\n        // when head promises resolve, proceed ignoring the head tag\n        return Promise.all(promises).then(() => {\n          const newCtx = Object.assign(ctx, {\n            head: {\n              block: false,\n              ignore: true,\n            },\n          });\n          return callback(newCtx);\n        });\n      }\n    }\n    // just proceed if we not head blocking\n    return callback(ctx);\n  }\n\n  /**\n   *  The HEAD tag can be handled specially, either w/ a 'merge' or 'append' style\n   *\n   * @param {Element} oldHead\n   * @param {Element} newHead\n   * @param {MorphContext} ctx\n   * @returns {Promise<void>[]}\n   */\n  function handleHeadElement(oldHead, newHead, ctx) {\n    let added = [];\n    let removed = [];\n    let preserved = [];\n    let nodesToAppend = [];\n\n    // put all new head elements into a Map, by their outerHTML\n    let srcToNewHeadNodes = new Map();\n    for (const newHeadChild of newHead.children) {\n      srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild);\n    }\n\n    // for each elt in the current head\n    for (const currentHeadElt of oldHead.children) {\n      // If the current head element is in the map\n      let inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML);\n      let isReAppended = ctx.head.shouldReAppend(currentHeadElt);\n      let isPreserved = ctx.head.shouldPreserve(currentHeadElt);\n      if (inNewContent || isPreserved) {\n        if (isReAppended) {\n          // remove the current version and let the new version replace it and re-execute\n          removed.push(currentHeadElt);\n        } else {\n          // this element already exists and should not be re-appended, so remove it from\n          // the new content map, preserving it in the DOM\n          srcToNewHeadNodes.delete(currentHeadElt.outerHTML);\n          preserved.push(currentHeadElt);\n        }\n      } else {\n        if (ctx.head.style === \"append\") {\n          // we are appending and this existing element is not new content\n          // so if and only if it is marked for re-append do we do anything\n          if (isReAppended) {\n            removed.push(currentHeadElt);\n            nodesToAppend.push(currentHeadElt);\n          }\n        } else {\n          // if this is a merge, we remove this content since it is not in the new head\n          if (ctx.head.shouldRemove(currentHeadElt) !== false) {\n            removed.push(currentHeadElt);\n          }\n        }\n      }\n    }\n\n    // Push the remaining new head elements in the Map into the\n    // nodes to append to the head tag\n    nodesToAppend.push(...srcToNewHeadNodes.values());\n\n    let promises = [];\n    for (const newNode of nodesToAppend) {\n      // TODO: This could theoretically be null, based on type\n      let newElt = /** @type {ChildNode} */ (\n        document.createRange().createContextualFragment(newNode.outerHTML)\n          .firstChild\n      );\n      if (ctx.callbacks.beforeNodeAdded(newElt) !== false) {\n        if (\n          (\"href\" in newElt && newElt.href) ||\n          (\"src\" in newElt && newElt.src)\n        ) {\n          /** @type {(result?: any) => void} */ let resolve;\n          let promise = new Promise(function (_resolve) {\n            resolve = _resolve;\n          });\n          newElt.addEventListener(\"load\", function () {\n            resolve();\n          });\n          promises.push(promise);\n        }\n        oldHead.appendChild(newElt);\n        ctx.callbacks.afterNodeAdded(newElt);\n        added.push(newElt);\n      }\n    }\n\n    // remove all removed elements, after we have appended the new elements to avoid\n    // additional network requests for things like style sheets\n    for (const removedElement of removed) {\n      if (ctx.callbacks.beforeNodeRemoved(removedElement) !== false) {\n        oldHead.removeChild(removedElement);\n        ctx.callbacks.afterNodeRemoved(removedElement);\n      }\n    }\n\n    ctx.head.afterHeadMorphed(oldHead, {\n      added: added,\n      kept: preserved,\n      removed: removed,\n    });\n    return promises;\n  }\n\n  //=============================================================================\n  // Create Morph Context Functions\n  //=============================================================================\n  const createMorphContext = (function () {\n    /**\n     *\n     * @param {Element} oldNode\n     * @param {Element} newContent\n     * @param {Config} config\n     * @returns {MorphContext}\n     */\n    function createMorphContext(oldNode, newContent, config) {\n      const { persistentIds, idMap } = createIdMaps(oldNode, newContent);\n\n      const mergedConfig = mergeDefaults(config);\n      const morphStyle = mergedConfig.morphStyle || \"outerHTML\";\n      if (![\"innerHTML\", \"outerHTML\"].includes(morphStyle)) {\n        throw `Do not understand how to morph style ${morphStyle}`;\n      }\n\n      return {\n        target: oldNode,\n        newContent: newContent,\n        config: mergedConfig,\n        morphStyle: morphStyle,\n        ignoreActive: mergedConfig.ignoreActive,\n        ignoreActiveValue: mergedConfig.ignoreActiveValue,\n        restoreFocus: mergedConfig.restoreFocus,\n        idMap: idMap,\n        persistentIds: persistentIds,\n        pantry: createPantry(),\n        activeElementAndParents: createActiveElementAndParents(oldNode),\n        callbacks: mergedConfig.callbacks,\n        head: mergedConfig.head,\n      };\n    }\n\n    /**\n     * Deep merges the config object and the Idiomorph.defaults object to\n     * produce a final configuration object\n     * @param {Config} config\n     * @returns {ConfigInternal}\n     */\n    function mergeDefaults(config) {\n      let finalConfig = Object.assign({}, defaults);\n\n      // copy top level stuff into final config\n      Object.assign(finalConfig, config);\n\n      // copy callbacks into final config (do this to deep merge the callbacks)\n      finalConfig.callbacks = Object.assign(\n        {},\n        defaults.callbacks,\n        config.callbacks,\n      );\n\n      // copy head config into final config  (do this to deep merge the head)\n      finalConfig.head = Object.assign({}, defaults.head, config.head);\n\n      return finalConfig;\n    }\n\n    /**\n     * @returns {HTMLDivElement}\n     */\n    function createPantry() {\n      const pantry = document.createElement(\"div\");\n      pantry.hidden = true;\n      document.body.insertAdjacentElement(\"afterend\", pantry);\n      return pantry;\n    }\n\n    /**\n     * @param {Element} oldNode\n     * @returns {Element[]}\n     */\n    function createActiveElementAndParents(oldNode) {\n      /** @type {Element[]} */\n      let activeElementAndParents = [];\n      let elt = document.activeElement;\n      if (elt?.tagName !== \"BODY\" && oldNode.contains(elt)) {\n        while (elt) {\n          activeElementAndParents.push(elt);\n          if (elt === oldNode) break;\n          elt = elt.parentElement;\n        }\n      }\n      return activeElementAndParents;\n    }\n\n    /**\n     * Returns all elements with an ID contained within the root element and its descendants\n     *\n     * @param {Element} root\n     * @returns {Element[]}\n     */\n    function findIdElements(root) {\n      let elements = Array.from(root.querySelectorAll(\"[id]\"));\n      // root could be a document fragment which doesn't have `getAttribute`\n      if (root.getAttribute?.(\"id\")) {\n        elements.push(root);\n      }\n      return elements;\n    }\n\n    /**\n     * A bottom-up algorithm that populates a map of Element -> IdSet.\n     * The idSet for a given element is the set of all IDs contained within its subtree.\n     * As an optimzation, we filter these IDs through the given list of persistent IDs,\n     * because we don't need to bother considering IDed elements that won't be in the new content.\n     *\n     * @param {Map<Node, Set<string>>} idMap\n     * @param {Set<string>} persistentIds\n     * @param {Element} root\n     * @param {Element[]} elements\n     */\n    function populateIdMapWithTree(idMap, persistentIds, root, elements) {\n      for (const elt of elements) {\n        // we can pretend id is non-null String, because the .has line will reject it immediately if not\n        const id = /** @type {String} */ (elt.getAttribute(\"id\"));\n        if (persistentIds.has(id)) {\n          /** @type {Element|null} */\n          let current = elt;\n          // walk up the parent hierarchy of that element, adding the id\n          // of element to the parent's id set\n          while (current) {\n            let idSet = idMap.get(current);\n            // if the id set doesn't exist, create it and insert it in the map\n            if (idSet == null) {\n              idSet = new Set();\n              idMap.set(current, idSet);\n            }\n            idSet.add(id);\n\n            if (current === root) break;\n            current = current.parentElement;\n          }\n        }\n      }\n    }\n\n    /**\n     * This function computes a map of nodes to all ids contained within that node (inclusive of the\n     * node).  This map can be used to ask if two nodes have intersecting sets of ids, which allows\n     * for a looser definition of \"matching\" than tradition id matching, and allows child nodes\n     * to contribute to a parent nodes matching.\n     *\n     * @param {Element} oldContent  the old content that will be morphed\n     * @param {Element} newContent  the new content to morph to\n     * @returns {IdSets}\n     */\n    function createIdMaps(oldContent, newContent) {\n      const oldIdElements = findIdElements(oldContent);\n      const newIdElements = findIdElements(newContent);\n\n      const persistentIds = createPersistentIds(oldIdElements, newIdElements);\n\n      /** @type {Map<Node, Set<string>>} */\n      let idMap = new Map();\n      populateIdMapWithTree(idMap, persistentIds, oldContent, oldIdElements);\n\n      /** @ts-ignore - if newContent is a duck-typed parent, pass its single child node as the root to halt upwards iteration */\n      const newRoot = newContent.__idiomorphRoot || newContent;\n      populateIdMapWithTree(idMap, persistentIds, newRoot, newIdElements);\n\n      return { persistentIds, idMap };\n    }\n\n    /**\n     * This function computes the set of ids that persist between the two contents excluding duplicates\n     *\n     * @param {Element[]} oldIdElements\n     * @param {Element[]} newIdElements\n     * @returns {Set<string>}\n     */\n    function createPersistentIds(oldIdElements, newIdElements) {\n      let duplicateIds = new Set();\n\n      /** @type {Map<string, string>} */\n      let oldIdTagNameMap = new Map();\n      for (const { id, tagName } of oldIdElements) {\n        if (oldIdTagNameMap.has(id)) {\n          duplicateIds.add(id);\n        } else {\n          oldIdTagNameMap.set(id, tagName);\n        }\n      }\n\n      let persistentIds = new Set();\n      for (const { id, tagName } of newIdElements) {\n        if (persistentIds.has(id)) {\n          duplicateIds.add(id);\n        } else if (oldIdTagNameMap.get(id) === tagName) {\n          persistentIds.add(id);\n        }\n        // skip if tag types mismatch because its not possible to morph one tag into another\n      }\n\n      for (const id of duplicateIds) {\n        persistentIds.delete(id);\n      }\n      return persistentIds;\n    }\n\n    return createMorphContext;\n  })();\n\n  //=============================================================================\n  // HTML Normalization Functions\n  //=============================================================================\n  const { normalizeElement, normalizeParent } = (function () {\n    /** @type {WeakSet<Node>} */\n    const generatedByIdiomorph = new WeakSet();\n\n    /**\n     *\n     * @param {Element | Document} content\n     * @returns {Element}\n     */\n    function normalizeElement(content) {\n      if (content instanceof Document) {\n        return content.documentElement;\n      } else {\n        return content;\n      }\n    }\n\n    /**\n     *\n     * @param {null | string | Node | HTMLCollection | Node[] | Document & {generatedByIdiomorph:boolean}} newContent\n     * @returns {Element}\n     */\n    function normalizeParent(newContent) {\n      if (newContent == null) {\n        return document.createElement(\"div\"); // dummy parent element\n      } else if (typeof newContent === \"string\") {\n        return normalizeParent(parseContent(newContent));\n      } else if (\n        generatedByIdiomorph.has(/** @type {Element} */ (newContent))\n      ) {\n        // the template tag created by idiomorph parsing can serve as a dummy parent\n        return /** @type {Element} */ (newContent);\n      } else if (newContent instanceof Node) {\n        if (newContent.parentNode) {\n          // we can't use the parent directly because newContent may have siblings\n          // that we don't want in the morph, and reparenting might be expensive (TODO is it?),\n          // so instead we create a fake parent node that only sees a slice of its children.\n          /** @type {Element} */\n          return /** @type {any} */ (new SlicedParentNode(newContent));\n        } else {\n          // a single node is added as a child to a dummy parent\n          const dummyParent = document.createElement(\"div\");\n          dummyParent.append(newContent);\n          return dummyParent;\n        }\n      } else {\n        // all nodes in the array or HTMLElement collection are consolidated under\n        // a single dummy parent element\n        const dummyParent = document.createElement(\"div\");\n        for (const elt of [...newContent]) {\n          dummyParent.append(elt);\n        }\n        return dummyParent;\n      }\n    }\n\n    /**\n     * A fake duck-typed parent element to wrap a single node, without actually reparenting it.\n     * This is useful because the node may have siblings that we don't want in the morph, and it may also be moved\n     * or replaced with one or more elements during the morph. This class effectively allows us a window into\n     * a slice of a node's children.\n     * \"If it walks like a duck, and quacks like a duck, then it must be a duck!\" -- James Whitcomb Riley (1849â€“1916)\n     */\n    class SlicedParentNode {\n      /** @param {Node} node */\n      constructor(node) {\n        this.originalNode = node;\n        this.realParentNode = /** @type {Element} */ (node.parentNode);\n        this.previousSibling = node.previousSibling;\n        this.nextSibling = node.nextSibling;\n      }\n\n      /** @returns {Node[]} */\n      get childNodes() {\n        // return slice of realParent's current childNodes, based on previousSibling and nextSibling\n        const nodes = [];\n        let cursor = this.previousSibling\n          ? this.previousSibling.nextSibling\n          : this.realParentNode.firstChild;\n        while (cursor && cursor != this.nextSibling) {\n          nodes.push(cursor);\n          cursor = cursor.nextSibling;\n        }\n        return nodes;\n      }\n\n      /**\n       * @param {string} selector\n       * @returns {Element[]}\n       */\n      querySelectorAll(selector) {\n        return this.childNodes.reduce((results, node) => {\n          if (node instanceof Element) {\n            if (node.matches(selector)) results.push(node);\n            const nodeList = node.querySelectorAll(selector);\n            for (let i = 0; i < nodeList.length; i++) {\n              results.push(nodeList[i]);\n            }\n          }\n          return results;\n        }, /** @type {Element[]} */ ([]));\n      }\n\n      /**\n       * @param {Node} node\n       * @param {Node} referenceNode\n       * @returns {Node}\n       */\n      insertBefore(node, referenceNode) {\n        return this.realParentNode.insertBefore(node, referenceNode);\n      }\n\n      /**\n       * @param {Node} node\n       * @param {Node} referenceNode\n       * @returns {Node}\n       */\n      moveBefore(node, referenceNode) {\n        // @ts-ignore - use new moveBefore feature\n        return this.realParentNode.moveBefore(node, referenceNode);\n      }\n\n      /**\n       * for later use with populateIdMapWithTree to halt upwards iteration\n       * @returns {Node}\n       */\n      get __idiomorphRoot() {\n        return this.originalNode;\n      }\n    }\n\n    /**\n     *\n     * @param {string} newContent\n     * @returns {Node | null | DocumentFragment}\n     */\n    function parseContent(newContent) {\n      let parser = new DOMParser();\n\n      // remove svgs to avoid false-positive matches on head, etc.\n      let contentWithSvgsRemoved = newContent.replace(\n        /<svg(\\s[^>]*>|>)([\\s\\S]*?)<\\/svg>/gim,\n        \"\",\n      );\n\n      // if the newContent contains a html, head or body tag, we can simply parse it w/o wrapping\n      if (\n        contentWithSvgsRemoved.match(/<\\/html>/) ||\n        contentWithSvgsRemoved.match(/<\\/head>/) ||\n        contentWithSvgsRemoved.match(/<\\/body>/)\n      ) {\n        let content = parser.parseFromString(newContent, \"text/html\");\n        // if it is a full HTML document, return the document itself as the parent container\n        if (contentWithSvgsRemoved.match(/<\\/html>/)) {\n          generatedByIdiomorph.add(content);\n          return content;\n        } else {\n          // otherwise return the html element as the parent container\n          let htmlElement = content.firstChild;\n          if (htmlElement) {\n            generatedByIdiomorph.add(htmlElement);\n          }\n          return htmlElement;\n        }\n      } else {\n        // if it is partial HTML, wrap it in a template tag to provide a parent element and also to help\n        // deal with touchy tags like tr, tbody, etc.\n        let responseDoc = parser.parseFromString(\n          \"<body><template>\" + newContent + \"</template></body>\",\n          \"text/html\",\n        );\n        let content = /** @type {HTMLTemplateElement} */ (\n          responseDoc.body.querySelector(\"template\")\n        ).content;\n        generatedByIdiomorph.add(content);\n        return content;\n      }\n    }\n\n    return { normalizeElement, normalizeParent };\n  })();\n\n  //=============================================================================\n  // This is what ends up becoming the Idiomorph global object\n  //=============================================================================\n  return {\n    morph,\n    defaults,\n  };\n})();\n\nexport {Idiomorph};\n","\nconst topics: any = {}\nconst _async: any = {}\n\nexport const publish = (name, params) => {\n\n\t_async[name] = isObject(params)? Object.assign({}, _async[name], params): params\n\n\tif (topics[name]) {\n\t\ttopics[name].forEach(topic => topic(params))\n\t}\n}\n\nexport const subscribe = (name, method) => {\n\ttopics[name] = topics[name] || []\n\ttopics[name].push(method)\n\tif (name in _async) {\n\t\tmethod(_async[name])\n\t}\n\treturn () => {\n\t\ttopics[name] = topics[name].filter( fn => fn != method )\n\t}\n}\n\nconst isObject = (value) => {\n\treturn (typeof value === 'object' && value !== null && !Array.isArray(value))\n}\n","import { safe, g, dup } from './utils'\nimport { Idiomorph } from 'idiomorph/dist/idiomorph.esm'\nimport { publish, subscribe } from './utils/pubsub'\n\nexport const Component = ({ name, module, dependencies, node, templates, signal, register }) => {\n\n\tlet tick\n\tlet preserve\t\t= []\n\tlet observer \t\t= null\n\tlet observables \t= []\n\tlet effect \t\t\t= null\n\n\tconst _model \t\t= module.model || {}\n\tconst initialState \t= (new Function( `return ${node.getAttribute('html-model') || '{}'}`))()\n\tconst tplid \t\t= node.getAttribute('tplid')\n\tconst scopeid \t\t= node.getAttribute('html-scopeid')\n\tconst tpl \t\t\t= templates[ tplid ]\n\tconst scope \t\t= g.scope[ scopeid ]\n\tconst model  \t\t= dup(module?.model?.apply ? _model({ elm:node, initialState, dependencies }) : _model)\n\tconst state \t\t= Object.assign({}, scope, model, initialState)\n\tconst view \t\t\t= module.view? module.view : (data) => data\n\n\tconst base = {\n\t\tname,\n\t\tmodel,\n\t\telm: node,\n\t\ttemplate: tpl.template,\n\t\tdependencies,\n\t\tpublish,\n\t\tsubscribe,\n\n\t\tmain(fn) {\n\t\t\tnode.addEventListener(':mount', fn)\n\t\t},\n\n\t\teffect(fn) {\n\t\t\tif( fn ) {\n\t\t\t\teffect = fn\n\t\t\t} else {\n\t\t\t\treturn effect\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @State\n\t\t */\n\t\tstate : {\n\n\t\t\tprotected( list ) {\n\t\t\t\tif( list ) {\n\t\t\t\t\tpreserve = list\n\t\t\t\t} else {\n\t\t\t\t\treturn preserve\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tsave(data) {\n\t\t\t\tif( data.constructor === Function ) {\n\t\t\t\t\tdata( state )\n\t\t\t\t} else {\n\t\t\t\t\tObject.assign(state, data)\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tset( data ) {\n\n\t\t\t\tif (!document.body.contains(node)) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif( data.constructor === Function ) {\n\t\t\t\t\tdata(state)\n\t\t\t\t} else {\n\t\t\t\t\tObject.assign(state, data)\n\t\t\t\t}\n\n\t\t\t\tconst newstate = Object.assign({}, state, scope)\n\n\t\t\t\treturn new Promise((resolve) => {\n\t\t\t\t\trender(newstate, () => resolve(newstate))\n\t\t\t\t})\n\t\t\t},\n\n\t\t\tget() {\n\t\t\t\treturn Object.assign({}, state)\n\t\t\t}\n\t\t},\n\n\t\tdataset( target, name ) {\n\n\t\t\tconst el = name? target : node\n\t\t\tconst key = name? name : target\n\t\t\tconst value = el.dataset[key]\n\n\t\t\tif (value === 'true') return true\n\t\t\tif (value === 'false') return false\n\t\t\tif (!isNaN(value) && value.trim() !== '') return Number(value)\n\n\t\t\ttry {\n\t\t\t\treturn new Function('return (' + value + ')')()\n\t\t\t} catch {}\n\n\t\t\ttry {\n\t\t\t\treturn JSON.parse(value)\n\t\t\t} catch {}\n\n\t\t\treturn value\n\t\t},\n\n\t\t/**\n\t\t * @Events\n\t\t */\n\t\ton( ev, selectorOrCallback, callback ) {\n\n\t\t\tconst attribute = ev.match(/\\[(.*)\\]/)\n\n\t\t\tif( attribute ) {\n\t\t\t\tobservables.push({\n\t\t\t\t\ttarget: callback? selectorOrCallback : null,\n\t\t\t\t\tcallback: callback || selectorOrCallback\n\t\t\t\t})\n\n\t\t\t\tif( !observer ) {\n\t\t\t\t\tobserver = new MutationObserver((mutationsList) => {\n\t\t\t\t\t\tfor (const mutation of mutationsList) {\n\t\t\t\t\t\t\tif (mutation.type === 'attributes') {\n\t\t\t\t\t\t\t\tconst attrname = mutation.attributeName\n\t\t\t\t\t\t\t\tif( attrname === attribute[1] ) {\n\t\t\t\t\t\t\t\t\tobservables.forEach( item => {\n\t\t\t\t\t\t\t\t\t\tconst target = item.target? node.querySelectorAll(item.target): [node]\n\t\t\t\t\t\t\t\t\t\ttarget.forEach( target => {\n\t\t\t\t\t\t\t\t\t\t\tif( target == mutation.target ) {\n\t\t\t\t\t\t\t\t\t\t\t\titem.callback({\n\t\t\t\t\t\t\t\t\t\t\t\t\ttarget: mutation.target,\n\t\t\t\t\t\t\t\t\t\t\t\t\tattribute: attrname,\n\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: mutation.target.getAttribute(attrname)\n\t\t\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\n\t\t\t\t\tobserver.observe(node, {\n\t\t\t\t\t\tattributes: true,\n\t\t\t\t\t\tsubtree: true\n\t\t\t\t\t})\n\n\t\t\t\t\tnode.addEventListener(':unmount', () => {\n\t\t\t\t\t\tobservables = []\n\t\t\t\t\t\tobserver.disconnect()\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif( callback ) {\n\t\t\t\tcallback.handler = (e) => {\n\t\t\t\t\tconst detail = e.detail || {}\n\t\t\t\t\tlet parent = e.target\n\t\t\t\t\twhile (parent) {\n\t\t\t\t\t\tif (parent.matches(selectorOrCallback)) {\n\t\t\t\t\t\t\te.delegateTarget = parent\n\t\t\t\t\t\t\tcallback.apply(node, [e].concat(detail.args))\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (parent === node) break\n\t\t\t\t\t\tparent = parent.parentNode\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnode.addEventListener(ev, callback.handler, {\n\t\t\t\t\tsignal,\n\t\t\t\t\tcapture: (ev == 'focus' || ev == 'blur' || ev == 'mouseenter' || ev == 'mouseleave')\n\t\t\t\t})\n\n\t\t\t} else {\n\t\t\t\tselectorOrCallback.handler = (e) => {\n\t\t\t\t\te.delegateTarget = node\n\t\t\t\t\tselectorOrCallback.apply(node, [e].concat(e.detail.args))\n\t\t\t\t}\n\t\t\t\tnode.addEventListener(ev, selectorOrCallback.handler, { signal })\n\t\t\t}\n\n\t\t},\n\n\t\toff( ev, callback ) {\n\t\t\tif( callback.handler ) {\n\t\t\t\tnode.removeEventListener(ev, callback.handler)\n\t\t\t}\n\t\t},\n\n\t\ttrigger(ev, selectorOrCallback, data) {\n\t\t\tif( selectorOrCallback.constructor === String ) {\n\t\t\t\tArray\n\t\t\t\t\t.from(node.querySelectorAll(selectorOrCallback))\n\t\t\t\t\t.forEach( children => {\n\t\t\t\t\t\tchildren.dispatchEvent(new CustomEvent(ev, { bubbles: true, detail: { args: data } }) )\n\t\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tnode.dispatchEvent(new CustomEvent(ev, { bubbles: true, detail:{ args: data } }))\n\t\t\t}\n\t\t},\n\n\t\temit(ev, data) {\n\t\t\tnode.dispatchEvent(new CustomEvent(ev, { bubbles: true, detail: { args: data } }))\n\t\t},\n\n\t\tunmount( fn ) {\n\t\t\tnode.addEventListener(':unmount', fn)\n\t\t},\n\n\t\tinnerHTML ( target, html_ ) {\n\t\t\tconst element = html_? target : node\n\t\t\tconst clone = element.cloneNode()\n\t\t\tconst html = html_? html_ : target\n\t\t\tclone.innerHTML = html\n\t\t\tIdiomorph.morph(element, clone)\n\t\t}\n\t}\n\n\tconst render = ( data, callback = (() => {}) ) => {\n\t\tclearTimeout( tick )\n\t\ttick = setTimeout(() => {\n\t\t\tconst html = tpl.render.call({...data, ...view(data)}, node, safe, g )\n\t\t\tIdiomorph.morph( node, html, IdiomorphOptions(node, register, data) )\n\t\t\tPromise.resolve().then(() => {\n\t\t\t\tnode.querySelectorAll('[tplid]')\n\t\t\t\t\t.forEach((element) => {\n\t\t\t\t\t\tconst child = register.get(element)\n\t\t\t\t\t\tconst scope = { ...child.__scope__ }\n\t\t\t\t\t\tif(!child) return\n\t\t\t\t\t\tchild.state.protected().forEach( key => delete data[key] )\n\t\t\t\t\t\tconst useEffect = child.effect()\n\t\t\t\t\t\tif( useEffect ) {\n\t\t\t\t\t\t\tconst promise = useEffect(data)\n\t\t\t\t\t\t\tif( promise && promise.then ) {\n\t\t\t\t\t\t\t\tpromise.then(() => child.state.set({...data, ...scope }))\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tchild.state.set({...data, ...scope })\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tchild.state.set({...data, ...scope })\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\tPromise.resolve().then(() => {\n\t\t\t\t\tg.scope = {}\n\t\t\t\t\tcallback()\n\t\t\t\t})\n\t\t\t})\n\t\t})\n\t}\n\n\trender( state )\n\tregister.set( node, base )\n\treturn module.default( base )\n}\n\nconst IdiomorphOptions = ( parent, register, data ) => ({\n\tcallbacks: {\n\t\tbeforeNodeMorphed( node, newnode ) {\n\t\t\tif( node.nodeType === 1 ) {\n\t\t\t\tif( 'html-static' in node.attributes ) {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\tif( register.get(node) && node !== parent ) {\n\t\t\t\t\tconst scopeid \t\t= newnode.getAttribute('html-scopeid')\n\t\t\t\t\tconst scope \t\t= g.scope[ scopeid ]\n\t\t\t\t\tconst base = register.get(node)\n\t\t\t\t\tbase.__scope__ = scope\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n})\n","import { Component } from './component'\n\nconst register = new WeakMap()\n\nexport const Element = ({ component, templates, start }) => {\n\n\tconst { name, module, dependencies } = component\n\n\treturn class extends HTMLElement {\n\n\t\tconstructor() {\n\t\t\tsuper()\n\t\t}\n\n\t\tconnectedCallback() {\n\n\t\t\tthis.abortController = new AbortController()\n\n\t\t\tif( !this.getAttribute('tplid') ) {\n\t\t\t\tstart( this.parentNode )\n\t\t\t}\n\n\t\t\tconst rtrn = Component({\n\t\t\t\tnode:this,\n\t\t\t\tname,\n\t\t\t\tmodule,\n\t\t\t\tdependencies,\n\t\t\t\ttemplates,\n\t\t\t\tsignal: this.abortController.signal,\n\t\t\t\tregister\n\t\t\t})\n\n\t\t\tif ( rtrn && rtrn.constructor === Promise ) {\n\t\t\t\trtrn.then(() => {\n\t\t\t\t\tthis.dispatchEvent( new CustomEvent(':mount') )\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tthis.dispatchEvent( new CustomEvent(':mount') )\n\t\t\t}\n\t\t}\n\n\t\tdisconnectedCallback() {\n\t\t\tthis.dispatchEvent( new CustomEvent(':unmount') )\n\t\t\tthis.abortController.abort()\n\t\t}\n\t}\n}\n","import { uuid, decodeHTML } from './utils'\n\nconst config = {\n\ttags: ['{{', '}}']\n}\n\nconst templates  = {}\nconst booleanAttrs = /html-(allowfullscreen|async|autofocus|autoplay|checked|controls|default|defer|disabled|formnovalidate|inert|ismap|itemscope|loop|multiple|muted|nomodule|novalidate|open|playsinline|readonly|required|reversed|selected)=\"(.*?)\"/g\nconst htmlAttr = /html-([^\\s]*?)=\"(.*?)\"/g\nconst tagExpr = () => new RegExp(`\\\\${config.tags[0]}(.+?)\\\\${config.tags[1]}`, 'g')\n\nexport const templateConfig = (newconfig) => {\n\tObject.assign( config, newconfig )\n}\n\nexport const template = ( target, { components }) => {\n\n\ttagElements( target, [...Object.keys( components ), '[html-if]', 'template'], components )\n\tconst clone = target.cloneNode( true )\n\n\ttransformTemplate( clone )\n\tremoveTemplateTagsRecursively( clone )\n\tsetTemplates( clone, components )\n\n\treturn templates\n}\n\nexport const compile = ( html ) => {\n\n\tconst parsedHtml = JSON.stringify( html )\n\n\treturn new Function('$element', 'safe', '$g',`\n\t\tvar $data = this;\n\t\twith( $data ){\n\t\t\tvar output=${parsedHtml\n\t\t\t\t.replace(/%%_=(.+?)_%%/g, function(_, variable){\n\t\t\t\t\treturn '\"+safe(function(){return '+ decodeHTML(variable) +';})+\"'\n\t\t\t\t})\n\t\t\t\t.replace(/%%_(.+?)_%%/g, function(_, variable){\n\t\t\t\t\treturn '\";' + decodeHTML(variable) +'\\noutput+=\"'\n\t\t\t\t})};return output;\n\t\t}\n\t`)\n}\n\nconst tagElements = (target, keys, components) => {\n\tconst isComponent = key => key in components\n\tconst selector = keys.join(',')\n\n\ttarget.querySelectorAll(selector).forEach(node => {\n\t\tif (node.localName === 'template') {\n\t\t\ttagElements(node.content, keys, components)\n\t\t\treturn\n\t\t}\n\t\tif (node.hasAttribute('html-if') && !node.id) {\n\t\t\tnode.id = uuid()\n\t\t}\n\t\tif (isComponent(node.localName)) {\n\t\t\tnode.setAttribute('tplid', uuid())\n\t\t}\n\t})\n}\n\nconst transformAttributes = (html) => {\n\treturn html\n\t\t.replace(/jails___scope-id/g, '%%_=$scopeid_%%')\n\t\t.replace(tagExpr(), '%%_=$1_%%')\n\t\t.replace(booleanAttrs, `%%_if(safe(function(){ return $2 })){_%%$1%%_}_%%`)\n\t\t.replace(htmlAttr, (all, key, value) => {\n\t\t\tif (['key', 'model', 'scopeid'].includes(key)) return all\n\t\t\tif (value) {\n\t\t\t\tvalue = value.replace(/^{|}$/g, '')\n\t\t\t\treturn `${key}=\"%%_=safe(function(){ return ${value} })_%%\"`\n\t\t\t}\n\t\t\treturn all\n\t\t})\n}\n\nconst transformTemplate = ( clone ) => {\n\n\tclone.querySelectorAll('template, [html-for], [html-if], [html-inner], [html-class]')\n\t\t.forEach(( element ) => {\n\n\t\t\tconst htmlFor \t= element.getAttribute('html-for')\n\t\t\tconst htmlIf \t= element.getAttribute('html-if')\n\t\t\tconst htmlInner = element.getAttribute('html-inner')\n\t\t\tconst htmlClass = element.getAttribute('html-class')\n\n\t\t\tif ( htmlFor ) {\n\n\t\t\t\telement.removeAttribute('html-for')\n\n\t\t\t\tconst split \t = htmlFor.match(/(.*)\\sin\\s(.*)/) || ''\n\t\t\t\tconst varname \t = split[1]\n\t\t\t\tconst object \t = split[2]\n\t\t\t\tconst objectname = object.split(/\\./).shift()\n\t\t\t\tconst open \t\t = document.createTextNode(`%%_ ;(function(){ var $index = 0; for(var $key in safe(function(){ return ${object} }) ){ var $scopeid = Math.random().toString(36).substring(2, 9); var ${varname} = ${object}[$key]; $g.scope[$scopeid] = Object.assign({}, { ${objectname}: ${objectname} }, { ${varname} :${varname}, $index: $index, $key: $key }); _%%`)\n\t\t\t\tconst close \t = document.createTextNode(`%%_ $index++; } })() _%%`)\n\n\t\t\t\twrap(open, element, close)\n\t\t\t}\n\n\t\t\tif (htmlIf) {\n\t\t\t\telement.removeAttribute('html-if')\n\t\t\t\tconst open = document.createTextNode(`%%_ if ( safe(function(){ return ${htmlIf} }) ){ _%%`)\n\t\t\t\tconst close = document.createTextNode(`%%_ }  _%%`)\n\t\t\t\twrap(open, element, close)\n\t\t\t}\n\n\t\t\tif (htmlInner) {\n\t\t\t\telement.removeAttribute('html-inner')\n\t\t\t\telement.innerHTML = `%%_=${htmlInner}_%%`\n\t\t\t}\n\n\t\t\tif (htmlClass) {\n\t\t\t\telement.removeAttribute('html-class')\n\t\t\t\telement.className = (element.className + ` %%_=${htmlClass}_%%`).trim()\n\t\t\t}\n\n\t\t\tif( element.localName === 'template' ) {\n\t\t\t\ttransformTemplate(element.content)\n\t\t\t}\n\t\t})\n}\n\nconst setTemplates = ( clone, components ) => {\n\n\tArray.from(clone.querySelectorAll('[tplid]'))\n\t\t.reverse()\n\t\t.forEach((node) => {\n\n\t\t\tconst tplid = node.getAttribute('tplid')\n\t\t\tconst name  = node.localName\n\t\t\tnode.setAttribute('html-scopeid', 'jails___scope-id')\n\n\t\t\tif( name in components && components[name].module.template ) {\n\t\t\t\tconst children = node.innerHTML\n\t\t\t\tconst html = components[name].module.template({ elm:node, children })\n\t\t\t\tnode.innerHTML = html\n\t\t\t\ttransformTemplate(node)\n\t\t\t\tremoveTemplateTagsRecursively(node)\n\t\t\t}\n\n\t\t\tconst html = transformAttributes(node.outerHTML)\n\n\t\t\ttemplates[ tplid ] = {\n\t\t\t\ttemplate: html,\n\t\t\t\trender\t: compile(html)\n\t\t\t}\n\t\t})\n}\n\nconst removeTemplateTagsRecursively = (node) => {\n\n\t// Get all <template> elements within the node\n\tconst templates = node.querySelectorAll('template')\n\n\ttemplates.forEach((template) => {\n\n\t\tif( template.getAttribute('html-if') || template.getAttribute('html-inner') ) {\n\t\t\treturn\n\t\t}\n\n\t\t// Process any nested <template> tags within this <template> first\n\t\tremoveTemplateTagsRecursively(template.content)\n\n\t\t// Get the parent of the <template> tag\n\t\tconst parent = template.parentNode\n\n\t\tif (parent) {\n\t\t\t// Move all child nodes from the <template>'s content to its parent\n\t\t\tconst content = template.content\n\t\t\twhile (content.firstChild) {\n\t\t\t\tparent.insertBefore(content.firstChild, template)\n\t\t\t}\n\t\t\t// Remove the <template> tag itself\n\t\t\tparent.removeChild(template)\n\t\t}\n\t})\n}\n\n\nconst wrap = (open, node, close) => {\n\tnode.parentNode?.insertBefore(open, node)\n\tnode.parentNode?.insertBefore(close, node.nextSibling)\n}\n","\nimport { Element } from './element'\nimport { template, templateConfig as config } from './template-system'\n\nexport { publish, subscribe } from './utils/pubsub'\n\nexport const templateConfig = (options) => {\n\tconfig( options )\n}\n\nglobalThis.__jails__ = globalThis.__jails__ || { components: {} }\n\nexport const register = ( name, module, dependencies ) => {\n\tconst { components } = globalThis.__jails__\n\tcomponents[ name ] = { name, module, dependencies }\n}\n\nexport const start = ( target ) => {\n\n\t// If the code is running in a Node.js environment, do nothing\n\tif( typeof window === 'undefined' ) {\n\t\treturn;\n\t}\n\n\ttarget = target || document.body\n\tconst { components } = globalThis.__jails__\n\tconst templates = template( target, { components } )\n\n\tObject\n\t\t.values( components )\n\t\t.forEach(({ name, module, dependencies }) => {\n\t\t\tif( !customElements.get(name) ) {\n\t\t\t\tcustomElements.define( name, Element({ component: { name, module, dependencies }, templates, start }))\n\t\t\t}\n\t})\n}\n"],"names":["textarea","g","scope","decodeHTML","text","document","createElement","innerHTML","value","uuid","Math","random","toString","substring","safe","execute","val","err","Idiomorph","noOp","defaults","morphStyle","callbacks","beforeNodeAdded","afterNodeAdded","beforeNodeMorphed","afterNodeMorphed","beforeNodeRemoved","afterNodeRemoved","beforeAttributeUpdated","head","style","shouldPreserve","elt","getAttribute","shouldReAppend","shouldRemove","afterHeadMorphed","restoreFocus","morphChildren","createNode","oldParent","newChild","insertionPoint","ctx","idMap","has","newEmptyChild","tagName","insertBefore","morphNode","newClonedChild","importNode","findBestMatch","isIdSetMatch","oldNode","newNode","oldSet","get","newSet","id","isSoftMatch","oldElt","newElt","nodeType","_a","call","_b","_c","node","startPoint","endPoint","softMatch","nextSibling","siblingSoftMatchCount","cursor","activeElementAndParents","includes","removeNode","moveBefore","pantry","parentNode","removeChild","removeNodesBetween","startInclusive","endExclusive","tempNode","moveBeforeById","after","target","querySelector","element","idSet","delete","size","removeElementFromAncestorsIdMaps","e","newParent","HTMLTemplateElement","content","firstChild","childNodes","bestMatch","Element","newChildId","persistentIds","movedChild","insertedNode","syncBooleanAttribute","oldElement","newElement","attributeName","newLiveValue","ignoreUpdate","ignoreAttribute","setAttribute","removeAttribute","attr","updateType","ignoreActiveValue","activeElement","ignoreValueOfActiveElement","possibleActiveElement","body","newContent","ignoreActive","HTMLHeadElement","ignore","handleHeadElement","type","oldAttributes","attributes","newAttributes","newAttribute","name","i","length","oldAttribute","hasAttribute","HTMLInputElement","newValue","oldValue","HTMLOptionElement","HTMLTextAreaElement","nodeValue","syncInputValue","morphAttributes","oldHead","newHead","added","removed","preserved","nodesToAppend","srcToNewHeadNodes","Map","newHeadChild","children","set","outerHTML","currentHeadElt","inNewContent","isReAppended","isPreserved","push","values","promises","createRange","createContextualFragment","href","src","resolve","promise","Promise","_resolve","addEventListener","appendChild","removedElement","kept","createMorphContext","createPantry","hidden","insertAdjacentElement","createActiveElementAndParents","contains","parentElement","findIdElements","root","elements","Array","from","querySelectorAll","populateIdMapWithTree","current","Set","add","config","oldContent","oldIdElements","newIdElements","duplicateIds","oldIdTagNameMap","createPersistentIds","newRoot","__idiomorphRoot","createIdMaps","mergedConfig","finalConfig","Object","assign","mergeDefaults","normalizeElement","normalizeParent","generatedByIdiomorph","WeakSet","SlicedParentNode","constructor","this","originalNode","realParentNode","previousSibling","nodes","selector","reduce","results","matches","nodeList","referenceNode","Document","documentElement","parser","DOMParser","contentWithSvgsRemoved","replace","match","parseFromString","htmlElement","parseContent","Node","dummyParent","append","morph","morphedNodes","fn","activeElementId","selectionStart","selectionEnd","focus","setSelectionRange","saveAndRestoreFocus","callback","block","all","then","newCtx","withHeadBlocking","morphOuterHTML","remove","topics","_async","publish","params","isObject","forEach","topic","subscribe","method","filter","isArray","Component","module","dependencies","templates","signal","register","tick","preserve","observer","observables","effect","_model","model","initialState","Function","tplid","scopeid","tpl","o","apply","elm","JSON","parse","stringify","state","view","data","base","template","main","protected","list","save","newstate","render","dataset","key","isNaN","trim","Number","on","ev","selectorOrCallback","attribute","MutationObserver","mutationsList","mutation","attrname","item","observe","subtree","disconnect","handler","detail","parent","delegateTarget","concat","args","capture","off","removeEventListener","trigger","String","dispatchEvent","CustomEvent","bubbles","emit","unmount","html_","clone","cloneNode","html","clearTimeout","setTimeout","__spreadValues","IdiomorphOptions","child","__scope__","useEffect","default","newnode","WeakMap","component","start","HTMLElement","super","connectedCallback","abortController","AbortController","rtrn","disconnectedCallback","abort","tags","booleanAttrs","htmlAttr","compile","parsedHtml","_","variable","tagElements","keys","components","join","localName","transformAttributes","RegExp","transformTemplate","htmlFor","htmlIf","htmlInner","htmlClass","split","varname","object","objectname","shift","open","createTextNode","close","wrap","className","setTemplates","reverse","removeTemplateTagsRecursively","globalThis","__jails__","window","customElements","define","options","newconfig"],"mappings":"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","x_google_ignoreList":[1]}