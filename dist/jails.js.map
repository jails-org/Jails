{"version":3,"file":"jails.js","sources":["../src/transpile.ts","../src/utils/index.ts","../src/template-system.ts","../src/utils/pubsub.ts","../node_modules/idiomorph/dist/idiomorph.esm.js","../src/utils/events.ts","../src/component.ts","../src/element.ts","../src/index.ts","../html.ts"],"sourcesContent":["import { uuid } from './utils'\n\nconst parser = new DOMParser()\n\nexport default function Transpile(html, config) {\n\n\tconst regexTags = new RegExp(`\\\\${config.tags[0]}(.+?)\\\\${config.tags[1]}`, 'g')\n\tconst virtual = parser.parseFromString(html.replace(/<\\/?template[^>]*>/g, ''), 'text/html')\n\n\tvirtual.querySelectorAll('[html-for], [html-if], [html-inner], [html-class], [html-model]').forEach((element) => {\n\n\t\tconst htmlForeach = element.getAttribute('html-foreach')\n\t\tconst htmlFor \t= element.getAttribute('html-for')\n\t\tconst htmlIf \t= element.getAttribute('html-if')\n\t\tconst htmlInner = element.getAttribute('html-inner')\n\t\tconst htmlClass = element.getAttribute('html-class')\n\t\tconst forEachInstruction = htmlFor || htmlForeach\n\n\t\tif ( forEachInstruction ) {\n\t\t\tconst selector = htmlFor? 'html-for': 'html-foreach'\n\t\t\tconst split = forEachInstruction.match(/(.*)\\sin\\s(.*)/) || ''\n\t\t\tconst varname = split[1]\n\t\t\tconst object = split[2]\n\n\t\t\telement.removeAttribute(selector)\n\t\t\telement.setAttribute('scope', '')\n\t\t\tconst script = document.createElement('script')\n\n\t\t\tscript.dataset.scope = ''\n\t\t\tscript.type = 'text/html'\n\t\t\tscript.text = `%%_= $scope _%%`\n\n\t\t\telement.appendChild( script )\n\n\t\t\tconst open = document.createTextNode(`%%_(function(){ var $index = 0; for(var $key in safe(function(){ return ${object} }) ){ var ${varname} = ${object}[$key]; var $scope = JSON.stringify({ '${varname}':${varname}, $index: $index, $key:$key }); _%%`)\n\t\t\tconst close = document.createTextNode(`%%_ $index++; } })() _%%`)\n\t\t\twrap(open, element, close)\n\t\t}\n\t\tif (htmlIf) {\n\t\t\telement.removeAttribute('html-if')\n\t\t\tconst open = document.createTextNode(`%%_ if ( safe(function(){ return ${htmlIf} }) ){ _%%`)\n\t\t\tconst close = document.createTextNode(`%%_ } _%%`)\n\t\t\twrap(open, element, close)\n\t\t}\n\t\tif (htmlInner) {\n\t\t\telement.removeAttribute('html-inner')\n\t\t\telement.innerHTML = `%%_=${htmlInner}_%%`\n\t\t}\n\t\tif (htmlClass) {\n\t\t\telement.removeAttribute('html-class')\n\t\t\telement.className = (element.className + ` %%_=${htmlClass}_%%`).trim()\n\t\t}\n\t})\n\n\treturn (\n\t\tvirtual.body.innerHTML\n\t\t\t.replace(regexTags, '%%_=$1_%%')\n\t\t\t// Booleans\n\t\t\t// https://meiert.com/en/blog/boolean-attributes-of-html/\n\t\t\t.replace(/html-(allowfullscreen|async|autofocus|autoplay|checked|controls|default|defer|disabled|formnovalidate|inert|ismap|itemscope|loop|multiple|muted|nomodule|novalidate|open|playsinline|readonly|required|reversed|selected)=\\\"(.*?)\\\"/g, `%%_if(safe(function(){ return $2 })){_%%$1%%_}_%%`)\n\t\t\t// The rest\n\t\t\t.replace(/html-(.*?)=\\\"(.*?)\\\"/g, (all, key, value) => {\n\t\t\t\tif (key === 'key' || key === 'model' || key == 'scope') {\n\t\t\t\t\treturn all\n\t\t\t\t}\n\t\t\t\tif (value) {\n\t\t\t\t\tvalue = value.replace(/^{|}$/g, '')\n\t\t\t\t\treturn `${key}=\"%%_=safe(function(){ return ${value} })_%%\"`\n\t\t\t\t} else {\n\t\t\t\t\treturn all\n\t\t\t\t}\n\t\t\t})\n\t)\n}\n\nconst wrap = (open, node, close) => {\n\tnode.parentNode?.insertBefore(open, node)\n\tnode.parentNode?.insertBefore(close, node.nextSibling)\n}\n","const textarea = document.createElement('textarea')\n\nexport const decodeHTML = (text) => {\n\ttextarea.innerHTML = text\n\treturn textarea.value\n}\n\nexport const rAF = (fn) => {\n\tif (requestAnimationFrame)\n\t\treturn requestAnimationFrame(fn)\n\telse\n\t\treturn setTimeout(fn, 1000 / 60)\n}\n\nexport const uuid = () => {\n\treturn 'xxxxxxxx'.replace(/[xy]/g, (c) => {\n\t\tconst r = Math.random() * 8 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8)\n\t\treturn v.toString(8)\n\t})\n}\n\nexport const dup = (o) => {\n\treturn JSON.parse(JSON.stringify(o))\n}\n\n// http://crockford.com/javascript/memory/leak.html\nexport const purge = (d) => {\n\tvar a = d.attributes, i, l, n\n\tif (a) {\n\t\tfor (i = a.length - 1; i >= 0; i -= 1) {\n\t\t\tn = a[i].name\n\t\t\tif (typeof d[n] === 'function') {\n\t\t\t\td[n] = null\n\t\t\t}\n\t\t}\n\t}\n\ta = d.childNodes\n\tif (a) {\n\t\tl = a.length\n\t\tfor (i = 0; i < l; i += 1) {\n\t\t\tpurge(d.childNodes[i])\n\t\t}\n\t}\n}\n\nexport const safe = (execute, val) => {\n\ttry{return execute()}catch(err){return val || ''}\n}\n","import Transpile from './transpile'\nimport { uuid, decodeHTML } from './utils'\n\nconst config = {\n\ttags: ['${', '}']\n}\n\nexport const templateConfig = (newconfig) => {\n\tObject.assign(config, newconfig)\n}\n\nexport default function Template(element) {\n\n\tfixDIffIf(element)\n\tconst html = Transpile(element.outerHTML, config)\n\tconst decodedHTML  = JSON.stringify(html)\n\n\treturn new Function('$element', 'safe',`\n\t\tvar $data = this;\n\t\twith( $data ){\n\t\t\tvar output=${decodedHTML\n\t\t\t\t.replace(/%%_=(.+?)_%%/g, function(_, variable){\n\t\t\t\t\treturn '\"+safe(function(){return '+decodeHTML(variable)+';})+\"'\n\t\t\t\t})\n\t\t\t\t.replace(/%%_(.+?)_%%/g, function(_, variable){\n\t\t\t\t\treturn '\";' + decodeHTML(variable) +'\\noutput+=\"'\n\t\t\t\t})};return output;\n\t\t}\n\t`)\n}\n\nexport const buildtemplates = ( target, selector, templates, components ) => {\n\t[]\n\t\t.concat( target.matches? (target.matches(selector)? target : []) : [] )\n\t\t.concat( Array.from(target.querySelectorAll( selector )) )\n\t\t.reverse()\n\t\t.forEach( (node:HTMLElement) => {\n\t\t\tnode.querySelectorAll('template').forEach( template => buildtemplates(template.content, selector, templates, components ))\n\t\t\tcreateTemplateId(node, templates, components)\n\t\t})\n}\n\nconst createTemplateId = (element, templates, components ) => {\n\n\tconst tplid = element.getAttribute('tplid')\n\n\tif (!tplid) {\n\t\tconst id = uuid()\n\t\telement.setAttribute('tplid', id)\n\t\tconst name = element.localName\n\n\t\tif( name in components && components[name].module.template ) {\n\t\t\tconst children = element.innerHTML\n\t\t\tconst html = components[name].module.template({ children })\n\t\t\tif( html.constructor === Promise ) {\n\t\t\t\telement.__template = html\n\t\t\t\thtml.then( htmlstring => {\n\t\t\t\t\telement.innerHTML = htmlstring\n\t\t\t\t\ttemplates[id] = Template(element)\n\t\t\t\t})\n\t\t\t}else {\n\t\t\t\telement.innerHTML = html\n\t\t\t}\n\t\t}\n\t\ttemplates[id] = Template(element)\n\t}\n}\n\n// Sometimes we don't know why something works, especially when using third party code like Idiomorph.\n// So just letting anyone knows that this part has to be improved some time.\nconst fixDIffIf = (node) => {\n\tconst _if = node.querySelector( '[html-if]')\n\tif( _if ) {\n\t\t_if.parentNode.insertBefore(document.createComment('[html-if]'), _if.nextSibling)\n\t}\n}\n","const topics: any = {}\nconst _async: any = {}\n\nexport const publish = (name, params) => {\n\t_async[name] = Object.assign({}, _async[name], params)\n\tif (topics[name])\n\t\ttopics[name].forEach(topic => topic(params))\n}\n\nexport const subscribe = (name, method) => {\n\ttopics[name] = topics[name] || []\n\ttopics[name].push(method)\n\tif (name in _async) {\n\t\tmethod(_async[name])\n\t}\n\treturn () => {\n\t\ttopics[name] = topics[name].filter( fn => fn != method )\n\t}\n}\n\n","/**\n * @typedef {object} ConfigHead\n *\n * @property {'merge' | 'append' | 'morph' | 'none'} [style]\n * @property {boolean} [block]\n * @property {boolean} [ignore]\n * @property {function(Element): boolean} [shouldPreserve]\n * @property {function(Element): boolean} [shouldReAppend]\n * @property {function(Element): boolean} [shouldRemove]\n * @property {function(Element, {added: Node[], kept: Element[], removed: Element[]}): void} [afterHeadMorphed]\n */\n\n/**\n * @typedef {object} ConfigCallbacks\n *\n * @property {function(Node): boolean} [beforeNodeAdded]\n * @property {function(Node): void} [afterNodeAdded]\n * @property {function(Element, Node): boolean} [beforeNodeMorphed]\n * @property {function(Element, Node): void} [afterNodeMorphed]\n * @property {function(Element): boolean} [beforeNodeRemoved]\n * @property {function(Element): void} [afterNodeRemoved]\n * @property {function(string, Element, \"update\" | \"remove\"): boolean} [beforeAttributeUpdated]\n * @property {function(Element): boolean} [beforeNodePantried]\n */\n\n/**\n * @typedef {object} Config\n *\n * @property {'outerHTML' | 'innerHTML'} [morphStyle]\n * @property {boolean} [ignoreActive]\n * @property {boolean} [ignoreActiveValue]\n * @property {ConfigCallbacks} [callbacks]\n * @property {ConfigHead} [head]\n */\n\n/**\n * @typedef {function} NoOp\n *\n * @returns {void}\n */\n\n/**\n * @typedef {object} ConfigHeadInternal\n *\n * @property {'merge' | 'append' | 'morph' | 'none'} style\n * @property {boolean} [block]\n * @property {boolean} [ignore]\n * @property {(function(Element): boolean) | NoOp} shouldPreserve\n * @property {(function(Element): boolean) | NoOp} shouldReAppend\n * @property {(function(Element): boolean) | NoOp} shouldRemove\n * @property {(function(Element, {added: Node[], kept: Element[], removed: Element[]}): void) | NoOp} afterHeadMorphed\n */\n\n/**\n * @typedef {object} ConfigCallbacksInternal\n *\n * @property {(function(Node): boolean) | NoOp} beforeNodeAdded\n * @property {(function(Node): void) | NoOp} afterNodeAdded\n * @property {(function(Node, Node): boolean) | NoOp} beforeNodeMorphed\n * @property {(function(Node, Node): void) | NoOp} afterNodeMorphed\n * @property {(function(Node): boolean) | NoOp} beforeNodeRemoved\n * @property {(function(Node): void) | NoOp} afterNodeRemoved\n * @property {(function(string, Element, \"update\" | \"remove\"): boolean) | NoOp} beforeAttributeUpdated\n * @property {(function(Node): boolean) | NoOp} beforeNodePantried\n */\n\n/**\n * @typedef {object} ConfigInternal\n *\n * @property {'outerHTML' | 'innerHTML'} morphStyle\n * @property {boolean} [ignoreActive]\n * @property {boolean} [ignoreActiveValue]\n * @property {ConfigCallbacksInternal} callbacks\n * @property {ConfigHeadInternal} head\n * @property {boolean} [twoPass]\n */\n\n/**\n * @typedef {Function} Morph\n *\n * @param {Element | Document} oldNode\n * @param {Element | Node | HTMLCollection | Node[] | string | null} newContent\n * @param {Config} [config]\n * @returns {undefined | Node[]}\n */\n\n// base IIFE to define idiomorph\n/**\n *\n * @type {{defaults: ConfigInternal, morph: Morph}}\n */\nvar Idiomorph = (function () {\n  \"use strict\";\n\n  /**\n   * @typedef {object} MorphContext\n   *\n   * @property {Node} target\n   * @property {Node} newContent\n   * @property {ConfigInternal} config\n   * @property {ConfigInternal['morphStyle']} morphStyle\n   * @property {ConfigInternal['ignoreActive']} ignoreActive\n   * @property {ConfigInternal['ignoreActiveValue']} ignoreActiveValue\n   * @property {Map<Node, Set<string>>} idMap\n   * @property {Set<string>} persistentIds\n   * @property {Set<string>} deadIds\n   * @property {ConfigInternal['callbacks']} callbacks\n   * @property {ConfigInternal['head']} head\n   * @property {HTMLDivElement} pantry\n   */\n\n  //=============================================================================\n  // AND NOW IT BEGINS...\n  //=============================================================================\n\n  /**\n   *\n   * @type {Set<string>}\n   */\n  let EMPTY_SET = new Set();\n\n  /**\n   * Default configuration values, updatable by users now\n   * @type {ConfigInternal}\n   */\n  let defaults = {\n    morphStyle: \"outerHTML\",\n    callbacks: {\n      beforeNodeAdded: noOp,\n      afterNodeAdded: noOp,\n      beforeNodeMorphed: noOp,\n      afterNodeMorphed: noOp,\n      beforeNodeRemoved: noOp,\n      afterNodeRemoved: noOp,\n      beforeAttributeUpdated: noOp,\n      beforeNodePantried: noOp,\n    },\n    head: {\n      style: \"merge\",\n      shouldPreserve: function (elt) {\n        return elt.getAttribute(\"im-preserve\") === \"true\";\n      },\n      shouldReAppend: function (elt) {\n        return elt.getAttribute(\"im-re-append\") === \"true\";\n      },\n      shouldRemove: noOp,\n      afterHeadMorphed: noOp,\n    },\n  };\n\n  /**\n   * =============================================================================\n   * Core Morphing Algorithm - morph, morphNormalizedContent, morphOldNodeTo, morphChildren\n   * =============================================================================\n   *\n   * @param {Element | Document} oldNode\n   * @param {Element | Node | HTMLCollection | Node[] | string | null} newContent\n   * @param {Config} [config]\n   * @returns {undefined | Node[]}\n   */\n  function morph(oldNode, newContent, config = {}) {\n    if (oldNode instanceof Document) {\n      oldNode = oldNode.documentElement;\n    }\n\n    if (typeof newContent === \"string\") {\n      newContent = parseContent(newContent);\n    }\n\n    let normalizedContent = normalizeContent(newContent);\n\n    let ctx = createMorphContext(oldNode, normalizedContent, config);\n\n    return morphNormalizedContent(oldNode, normalizedContent, ctx);\n  }\n\n  /**\n   *\n   * @param {Element} oldNode\n   * @param {Element} normalizedNewContent\n   * @param {MorphContext} ctx\n   * @returns {undefined | Node[]}\n   */\n  function morphNormalizedContent(oldNode, normalizedNewContent, ctx) {\n    if (ctx.head.block) {\n      let oldHead = oldNode.querySelector(\"head\");\n      let newHead = normalizedNewContent.querySelector(\"head\");\n      if (oldHead && newHead) {\n        let promises = handleHeadElement(newHead, oldHead, ctx);\n        // when head promises resolve, call morph again, ignoring the head tag\n        Promise.all(promises).then(function () {\n          morphNormalizedContent(\n            oldNode,\n            normalizedNewContent,\n            Object.assign(ctx, {\n              head: {\n                block: false,\n                ignore: true,\n              },\n            }),\n          );\n        });\n        return;\n      }\n    }\n\n    if (ctx.morphStyle === \"innerHTML\") {\n      // innerHTML, so we are only updating the children\n      morphChildren(normalizedNewContent, oldNode, ctx);\n      if (ctx.config.twoPass) {\n        restoreFromPantry(oldNode, ctx);\n      }\n      return Array.from(oldNode.children);\n    } else if (ctx.morphStyle === \"outerHTML\" || ctx.morphStyle == null) {\n      // otherwise find the best element match in the new content, morph that, and merge its siblings\n      // into either side of the best match\n      let bestMatch = findBestNodeMatch(normalizedNewContent, oldNode, ctx);\n\n      // stash the siblings that will need to be inserted on either side of the best match\n      let previousSibling = bestMatch?.previousSibling ?? null;\n      let nextSibling = bestMatch?.nextSibling ?? null;\n\n      // morph it\n      let morphedNode = morphOldNodeTo(oldNode, bestMatch, ctx);\n\n      if (bestMatch) {\n        // if there was a best match, merge the siblings in too and return the\n        // whole bunch\n        if (morphedNode) {\n          const elements = insertSiblings(\n            previousSibling,\n            morphedNode,\n            nextSibling,\n          );\n          if (ctx.config.twoPass) {\n            restoreFromPantry(morphedNode.parentNode, ctx);\n          }\n          return elements;\n        }\n      } else {\n        // otherwise nothing was added to the DOM\n        return [];\n      }\n    } else {\n      throw \"Do not understand how to morph style \" + ctx.morphStyle;\n    }\n  }\n\n  /**\n   * @param {Node} possibleActiveElement\n   * @param {MorphContext} ctx\n   * @returns {boolean}\n   */\n  // TODO: ignoreActive and ignoreActiveValue are marked as optional since they are not\n  //   initialised in the default config object. As a result the && in the function body may\n  //   return undefined instead of boolean. Either expand the type of the return value to\n  //   include undefined or wrap the ctx.ignoreActiveValue into a Boolean()\n  function ignoreValueOfActiveElement(possibleActiveElement, ctx) {\n    return (\n      !!ctx.ignoreActiveValue &&\n      possibleActiveElement === document.activeElement &&\n      possibleActiveElement !== document.body\n    );\n  }\n\n  /**\n   * @param {Node} oldNode root node to merge content into\n   * @param {Node | null} newContent new content to merge\n   * @param {MorphContext} ctx the merge context\n   * @returns {Node | null} the element that ended up in the DOM\n   */\n  function morphOldNodeTo(oldNode, newContent, ctx) {\n    if (ctx.ignoreActive && oldNode === document.activeElement) {\n      // don't morph focused element\n    } else if (newContent == null) {\n      if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return oldNode;\n\n      oldNode.parentNode?.removeChild(oldNode);\n      ctx.callbacks.afterNodeRemoved(oldNode);\n      return null;\n    } else if (!isSoftMatch(oldNode, newContent)) {\n      if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return oldNode;\n      if (ctx.callbacks.beforeNodeAdded(newContent) === false) return oldNode;\n\n      oldNode.parentNode?.replaceChild(newContent, oldNode);\n      ctx.callbacks.afterNodeAdded(newContent);\n      ctx.callbacks.afterNodeRemoved(oldNode);\n      return newContent;\n    } else {\n      if (ctx.callbacks.beforeNodeMorphed(oldNode, newContent) === false)\n        return oldNode;\n\n      if (oldNode instanceof HTMLHeadElement && ctx.head.ignore) {\n        // ignore the head element\n      } else if (\n        oldNode instanceof HTMLHeadElement &&\n        ctx.head.style !== \"morph\"\n      ) {\n        // ok to cast: if newContent wasn't also a <head>, it would've got caught in the `!isSoftMatch` branch above\n        handleHeadElement(\n          /** @type {HTMLHeadElement} */ (newContent),\n          oldNode,\n          ctx,\n        );\n      } else {\n        syncNodeFrom(newContent, oldNode, ctx);\n        if (!ignoreValueOfActiveElement(oldNode, ctx)) {\n          morphChildren(newContent, oldNode, ctx);\n        }\n      }\n      ctx.callbacks.afterNodeMorphed(oldNode, newContent);\n      return oldNode;\n    }\n    return null;\n  }\n\n  /**\n   * This is the core algorithm for matching up children.  The idea is to use id sets to try to match up\n   * nodes as faithfully as possible.  We greedily match, which allows us to keep the algorithm fast, but\n   * by using id sets, we are able to better match up with content deeper in the DOM.\n   *\n   * Basic algorithm is, for each node in the new content:\n   *\n   * - if we have reached the end of the old parent, append the new content\n   * - if the new content has an id set match with the current insertion point, morph\n   * - search for an id set match\n   * - if id set match found, morph\n   * - otherwise search for a \"soft\" match\n   * - if a soft match is found, morph\n   * - otherwise, prepend the new node before the current insertion point\n   *\n   * The two search algorithms terminate if competing node matches appear to outweigh what can be achieved\n   * with the current node.  See findIdSetMatch() and findSoftMatch() for details.\n   *\n   * @param {Node} newParent the parent element of the new content\n   * @param {Node} oldParent the old content that we are merging the new content into\n   * @param {MorphContext} ctx the merge context\n   * @returns {void}\n   */\n  function morphChildren(newParent, oldParent, ctx) {\n    if (\n      newParent instanceof HTMLTemplateElement &&\n      oldParent instanceof HTMLTemplateElement\n    ) {\n      newParent = newParent.content;\n      oldParent = oldParent.content;\n    }\n\n    /**\n     *\n     * @type {Node | null}\n     */\n    let nextNewChild = newParent.firstChild;\n    /**\n     *\n     * @type {Node | null}\n     */\n    let insertionPoint = oldParent.firstChild;\n    let newChild;\n\n    // run through all the new content\n    while (nextNewChild) {\n      newChild = nextNewChild;\n      nextNewChild = newChild.nextSibling;\n\n      // if we are at the end of the exiting parent's children, just append\n      if (insertionPoint == null) {\n        // skip add callbacks when we're going to be restoring this from the pantry in the second pass\n        if (\n          ctx.config.twoPass &&\n          ctx.persistentIds.has(/** @type {Element} */ (newChild).id)\n        ) {\n          oldParent.appendChild(newChild);\n        } else {\n          if (ctx.callbacks.beforeNodeAdded(newChild) === false) continue;\n          oldParent.appendChild(newChild);\n          ctx.callbacks.afterNodeAdded(newChild);\n        }\n        removeIdsFromConsideration(ctx, newChild);\n        continue;\n      }\n\n      // if the current node has an id set match then morph\n      if (isIdSetMatch(newChild, insertionPoint, ctx)) {\n        morphOldNodeTo(insertionPoint, newChild, ctx);\n        insertionPoint = insertionPoint.nextSibling;\n        removeIdsFromConsideration(ctx, newChild);\n        continue;\n      }\n\n      // otherwise search forward in the existing old children for an id set match\n      let idSetMatch = findIdSetMatch(\n        newParent,\n        oldParent,\n        newChild,\n        insertionPoint,\n        ctx,\n      );\n\n      // if we found a potential match, remove the nodes until that point and morph\n      if (idSetMatch) {\n        insertionPoint = removeNodesBetween(insertionPoint, idSetMatch, ctx);\n        morphOldNodeTo(idSetMatch, newChild, ctx);\n        removeIdsFromConsideration(ctx, newChild);\n        continue;\n      }\n\n      // no id set match found, so scan forward for a soft match for the current node\n      let softMatch = findSoftMatch(\n        newParent,\n        oldParent,\n        newChild,\n        insertionPoint,\n        ctx,\n      );\n\n      // if we found a soft match for the current node, morph\n      if (softMatch) {\n        insertionPoint = removeNodesBetween(insertionPoint, softMatch, ctx);\n        morphOldNodeTo(softMatch, newChild, ctx);\n        removeIdsFromConsideration(ctx, newChild);\n        continue;\n      }\n\n      // abandon all hope of morphing, just insert the new child before the insertion point\n      // and move on\n\n      // skip add callbacks when we're going to be restoring this from the pantry in the second pass\n      if (\n        ctx.config.twoPass &&\n        ctx.persistentIds.has(/** @type {Element} */ (newChild).id)\n      ) {\n        oldParent.insertBefore(newChild, insertionPoint);\n      } else {\n        if (ctx.callbacks.beforeNodeAdded(newChild) === false) continue;\n        oldParent.insertBefore(newChild, insertionPoint);\n        ctx.callbacks.afterNodeAdded(newChild);\n      }\n      removeIdsFromConsideration(ctx, newChild);\n    }\n\n    // remove any remaining old nodes that didn't match up with new content\n    while (insertionPoint !== null) {\n      let tempNode = insertionPoint;\n      insertionPoint = insertionPoint.nextSibling;\n      removeNode(tempNode, ctx);\n    }\n  }\n\n  //=============================================================================\n  // Attribute Syncing Code\n  //=============================================================================\n\n  /**\n   * @param {string} attr the attribute to be mutated\n   * @param {Element} to the element that is going to be updated\n   * @param {\"update\" | \"remove\"} updateType\n   * @param {MorphContext} ctx the merge context\n   * @returns {boolean} true if the attribute should be ignored, false otherwise\n   */\n  function ignoreAttribute(attr, to, updateType, ctx) {\n    if (\n      attr === \"value\" &&\n      ctx.ignoreActiveValue &&\n      to === document.activeElement\n    ) {\n      return true;\n    }\n    return ctx.callbacks.beforeAttributeUpdated(attr, to, updateType) === false;\n  }\n\n  /**\n   * syncs a given node with another node, copying over all attributes and\n   * inner element state from the 'from' node to the 'to' node\n   *\n   * @param {Node} from the element to copy attributes & state from\n   * @param {Node} to the element to copy attributes & state to\n   * @param {MorphContext} ctx the merge context\n   */\n  function syncNodeFrom(from, to, ctx) {\n    let type = from.nodeType;\n\n    // if is an element type, sync the attributes from the\n    // new node into the new node\n    if (type === 1 /* element type */) {\n      const fromEl = /** @type {Element} */ (from);\n      const toEl = /** @type {Element} */ (to);\n      const fromAttributes = fromEl.attributes;\n      const toAttributes = toEl.attributes;\n      for (const fromAttribute of fromAttributes) {\n        if (ignoreAttribute(fromAttribute.name, toEl, \"update\", ctx)) {\n          continue;\n        }\n        if (toEl.getAttribute(fromAttribute.name) !== fromAttribute.value) {\n          toEl.setAttribute(fromAttribute.name, fromAttribute.value);\n        }\n      }\n      // iterate backwards to avoid skipping over items when a delete occurs\n      for (let i = toAttributes.length - 1; 0 <= i; i--) {\n        const toAttribute = toAttributes[i];\n\n        // toAttributes is a live NamedNodeMap, so iteration+mutation is unsafe\n        // e.g. custom element attribute callbacks can remove other attributes\n        if (!toAttribute) continue;\n\n        if (!fromEl.hasAttribute(toAttribute.name)) {\n          if (ignoreAttribute(toAttribute.name, toEl, \"remove\", ctx)) {\n            continue;\n          }\n          toEl.removeAttribute(toAttribute.name);\n        }\n      }\n    }\n\n    // sync text nodes\n    if (type === 8 /* comment */ || type === 3 /* text */) {\n      if (to.nodeValue !== from.nodeValue) {\n        to.nodeValue = from.nodeValue;\n      }\n    }\n\n    if (!ignoreValueOfActiveElement(to, ctx)) {\n      // sync input values\n      syncInputValue(from, to, ctx);\n    }\n  }\n\n  /**\n   * @param {Element} from element to sync the value from\n   * @param {Element} to element to sync the value to\n   * @param {string} attributeName the attribute name\n   * @param {MorphContext} ctx the merge context\n   */\n  function syncBooleanAttribute(from, to, attributeName, ctx) {\n    // TODO: prefer set/getAttribute here\n    if (!(from instanceof Element && to instanceof Element)) return;\n    // @ts-ignore this function is only used on boolean attrs that are reflected as dom properties\n    const fromLiveValue = from[attributeName],\n      toLiveValue = to[attributeName];\n    if (fromLiveValue !== toLiveValue) {\n      let ignoreUpdate = ignoreAttribute(attributeName, to, \"update\", ctx);\n      if (!ignoreUpdate) {\n        // update attribute's associated DOM property\n        // @ts-ignore this function is only used on boolean attrs that are reflected as dom properties\n        to[attributeName] = from[attributeName];\n      }\n      if (fromLiveValue) {\n        if (!ignoreUpdate) {\n          // TODO: do we really want this? tests say so but it feels wrong\n          to.setAttribute(attributeName, fromLiveValue);\n        }\n      } else {\n        if (!ignoreAttribute(attributeName, to, \"remove\", ctx)) {\n          to.removeAttribute(attributeName);\n        }\n      }\n    }\n  }\n\n  /**\n   * NB: many bothans died to bring us information:\n   *\n   *  https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n   *  https://github.com/choojs/nanomorph/blob/master/lib/morph.jsL113\n   *\n   * @param {Node} from the element to sync the input value from\n   * @param {Node} to the element to sync the input value to\n   * @param {MorphContext} ctx the merge context\n   */\n  function syncInputValue(from, to, ctx) {\n    if (\n      from instanceof HTMLInputElement &&\n      to instanceof HTMLInputElement &&\n      from.type !== \"file\"\n    ) {\n      let fromValue = from.value;\n      let toValue = to.value;\n\n      // sync boolean attributes\n      syncBooleanAttribute(from, to, \"checked\", ctx);\n      syncBooleanAttribute(from, to, \"disabled\", ctx);\n\n      if (!from.hasAttribute(\"value\")) {\n        if (!ignoreAttribute(\"value\", to, \"remove\", ctx)) {\n          to.value = \"\";\n          to.removeAttribute(\"value\");\n        }\n      } else if (fromValue !== toValue) {\n        if (!ignoreAttribute(\"value\", to, \"update\", ctx)) {\n          to.setAttribute(\"value\", fromValue);\n          to.value = fromValue;\n        }\n      }\n      // TODO: QUESTION(1cg): this used to only check `from` unlike the other branches -- why?\n      // did I break something?\n    } else if (\n      from instanceof HTMLOptionElement &&\n      to instanceof HTMLOptionElement\n    ) {\n      syncBooleanAttribute(from, to, \"selected\", ctx);\n    } else if (\n      from instanceof HTMLTextAreaElement &&\n      to instanceof HTMLTextAreaElement\n    ) {\n      let fromValue = from.value;\n      let toValue = to.value;\n      if (ignoreAttribute(\"value\", to, \"update\", ctx)) {\n        return;\n      }\n      if (fromValue !== toValue) {\n        to.value = fromValue;\n      }\n      if (to.firstChild && to.firstChild.nodeValue !== fromValue) {\n        to.firstChild.nodeValue = fromValue;\n      }\n    }\n  }\n\n  /**\n   * =============================================================================\n   *  The HEAD tag can be handled specially, either w/ a 'merge' or 'append' style\n   * =============================================================================\n   * @param {Element} newHeadTag\n   * @param {Element} currentHead\n   * @param {MorphContext} ctx\n   * @returns {Promise<void>[]}\n   */\n  function handleHeadElement(newHeadTag, currentHead, ctx) {\n    /**\n     * @type {Node[]}\n     */\n    let added = [];\n    /**\n     * @type {Element[]}\n     */\n    let removed = [];\n    /**\n     * @type {Element[]}\n     */\n    let preserved = [];\n    /**\n     * @type {Element[]}\n     */\n    let nodesToAppend = [];\n\n    let headMergeStyle = ctx.head.style;\n\n    // put all new head elements into a Map, by their outerHTML\n    let srcToNewHeadNodes = new Map();\n    for (const newHeadChild of newHeadTag.children) {\n      srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild);\n    }\n\n    // for each elt in the current head\n    for (const currentHeadElt of currentHead.children) {\n      // If the current head element is in the map\n      let inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML);\n      let isReAppended = ctx.head.shouldReAppend(currentHeadElt);\n      let isPreserved = ctx.head.shouldPreserve(currentHeadElt);\n      if (inNewContent || isPreserved) {\n        if (isReAppended) {\n          // remove the current version and let the new version replace it and re-execute\n          removed.push(currentHeadElt);\n        } else {\n          // this element already exists and should not be re-appended, so remove it from\n          // the new content map, preserving it in the DOM\n          srcToNewHeadNodes.delete(currentHeadElt.outerHTML);\n          preserved.push(currentHeadElt);\n        }\n      } else {\n        if (headMergeStyle === \"append\") {\n          // we are appending and this existing element is not new content\n          // so if and only if it is marked for re-append do we do anything\n          if (isReAppended) {\n            removed.push(currentHeadElt);\n            nodesToAppend.push(currentHeadElt);\n          }\n        } else {\n          // if this is a merge, we remove this content since it is not in the new head\n          if (ctx.head.shouldRemove(currentHeadElt) !== false) {\n            removed.push(currentHeadElt);\n          }\n        }\n      }\n    }\n\n    // Push the remaining new head elements in the Map into the\n    // nodes to append to the head tag\n    nodesToAppend.push(...srcToNewHeadNodes.values());\n    log(\"to append: \", nodesToAppend);\n\n    let promises = [];\n    for (const newNode of nodesToAppend) {\n      log(\"adding: \", newNode);\n      // TODO: This could theoretically be null, based on type\n      let newElt = /** @type {ChildNode} */ (\n        document.createRange().createContextualFragment(newNode.outerHTML)\n          .firstChild\n      );\n      log(newElt);\n      if (ctx.callbacks.beforeNodeAdded(newElt) !== false) {\n        if (\n          (\"href\" in newElt && newElt.href) ||\n          (\"src\" in newElt && newElt.src)\n        ) {\n          /** @type {(result?: any) => void} */ let resolve;\n          let promise = new Promise(function (_resolve) {\n            resolve = _resolve;\n          });\n          newElt.addEventListener(\"load\", function () {\n            resolve();\n          });\n          promises.push(promise);\n        }\n        currentHead.appendChild(newElt);\n        ctx.callbacks.afterNodeAdded(newElt);\n        added.push(newElt);\n      }\n    }\n\n    // remove all removed elements, after we have appended the new elements to avoid\n    // additional network requests for things like style sheets\n    for (const removedElement of removed) {\n      if (ctx.callbacks.beforeNodeRemoved(removedElement) !== false) {\n        currentHead.removeChild(removedElement);\n        ctx.callbacks.afterNodeRemoved(removedElement);\n      }\n    }\n\n    ctx.head.afterHeadMorphed(currentHead, {\n      added: added,\n      kept: preserved,\n      removed: removed,\n    });\n    return promises;\n  }\n\n  //=============================================================================\n  // Misc\n  //=============================================================================\n\n  /**\n   * @param {any[]} _args\n   */\n  function log(..._args) {\n    //console.log(args);\n  }\n\n  function noOp() {}\n\n  /**\n   * Deep merges the config object and the Idiomoroph.defaults object to\n   * produce a final configuration object\n   * @param {Config} config\n   * @returns {ConfigInternal}\n   */\n  function mergeDefaults(config) {\n    /**\n     * @type {ConfigInternal}\n     */\n    let finalConfig = Object.assign({}, defaults);\n\n    // copy top level stuff into final config\n    Object.assign(finalConfig, config);\n\n    // copy callbacks into final config (do this to deep merge the callbacks)\n    finalConfig.callbacks = Object.assign(\n      {},\n      defaults.callbacks,\n      config.callbacks,\n    );\n\n    // copy head config into final config  (do this to deep merge the head)\n    finalConfig.head = Object.assign({}, defaults.head, config.head);\n\n    return finalConfig;\n  }\n\n  /**\n   *\n   * @param {Element} oldNode\n   * @param {Element} newContent\n   * @param {Config} config\n   * @returns {MorphContext}\n   */\n  function createMorphContext(oldNode, newContent, config) {\n    const mergedConfig = mergeDefaults(config);\n    return {\n      target: oldNode,\n      newContent: newContent,\n      config: mergedConfig,\n      morphStyle: mergedConfig.morphStyle,\n      ignoreActive: mergedConfig.ignoreActive,\n      ignoreActiveValue: mergedConfig.ignoreActiveValue,\n      idMap: createIdMap(oldNode, newContent),\n      deadIds: new Set(),\n      persistentIds: mergedConfig.twoPass\n        ? createPersistentIds(oldNode, newContent)\n        : new Set(),\n      pantry: mergedConfig.twoPass\n        ? createPantry()\n        : document.createElement(\"div\"),\n      callbacks: mergedConfig.callbacks,\n      head: mergedConfig.head,\n    };\n  }\n\n  function createPantry() {\n    const pantry = document.createElement(\"div\");\n    pantry.hidden = true;\n    document.body.insertAdjacentElement(\"afterend\", pantry);\n    return pantry;\n  }\n\n  /**\n   *\n   * @param {Node | null} node1\n   * @param {Node | null} node2\n   * @param {MorphContext} ctx\n   * @returns {boolean}\n   */\n  // TODO: The function handles this as if it's Element or null, but the function is called in\n  //   places where the arguments may be just a Node, not an Element\n  function isIdSetMatch(node1, node2, ctx) {\n    if (node1 == null || node2 == null) {\n      return false;\n    }\n    if (\n      node1 instanceof Element &&\n      node2 instanceof Element &&\n      node1.tagName === node2.tagName\n    ) {\n      if (node1.id !== \"\" && node1.id === node2.id) {\n        return true;\n      } else {\n        return getIdIntersectionCount(ctx, node1, node2) > 0;\n      }\n    }\n    return false;\n  }\n\n  /**\n   *\n   * @param {Node | null} oldNode\n   * @param {Node | null} newNode\n   * @returns {boolean}\n   */\n  function isSoftMatch(oldNode, newNode) {\n    if (oldNode == null || newNode == null) {\n      return false;\n    }\n    // ok to cast: if one is not element, `id` or `tagName` will be undefined and we'll compare that\n    // If oldNode has an `id` with possible state and it doesn't match newNode.id then avoid morphing\n    if (\n      /** @type {Element} */ (oldNode).id &&\n      /** @type {Element} */ (oldNode).id !==\n        /** @type {Element} */ (newNode).id\n    ) {\n      return false;\n    }\n    return (\n      oldNode.nodeType === newNode.nodeType &&\n      /** @type {Element} */ (oldNode).tagName ===\n        /** @type {Element} */ (newNode).tagName\n    );\n  }\n\n  /**\n   *\n   * @param {Node} startInclusive\n   * @param {Node} endExclusive\n   * @param {MorphContext} ctx\n   * @returns {Node | null}\n   */\n  function removeNodesBetween(startInclusive, endExclusive, ctx) {\n    /** @type {Node | null} */ let cursor = startInclusive;\n    while (cursor !== endExclusive) {\n      let tempNode = /** @type {Node} */ (cursor);\n      // TODO: Prefer assigning to a new variable here or expand the type of startInclusive\n      //  to be Node | null\n      cursor = tempNode.nextSibling;\n      removeNode(tempNode, ctx);\n    }\n    removeIdsFromConsideration(ctx, endExclusive);\n    return endExclusive.nextSibling;\n  }\n\n  /**\n   * =============================================================================\n   *  Scans forward from the insertionPoint in the old parent looking for a potential id match\n   *  for the newChild.  We stop if we find a potential id match for the new child OR\n   *  if the number of potential id matches we are discarding is greater than the\n   *  potential id matches for the new child\n   * =============================================================================\n   * @param {Node} newContent\n   * @param {Node} oldParent\n   * @param {Node} newChild\n   * @param {Node} insertionPoint\n   * @param {MorphContext} ctx\n   * @returns {null | Node}\n   */\n  function findIdSetMatch(\n    newContent,\n    oldParent,\n    newChild,\n    insertionPoint,\n    ctx,\n  ) {\n    // max id matches we are willing to discard in our search\n    let newChildPotentialIdCount = getIdIntersectionCount(\n      ctx,\n      newChild,\n      oldParent,\n    );\n\n    /**\n     * @type {Node | null}\n     */\n    let potentialMatch = null;\n\n    // only search forward if there is a possibility of an id match\n    if (newChildPotentialIdCount > 0) {\n      // TODO: This is ghosting the potentialMatch variable outside of this block.\n      //   Probably an error\n      potentialMatch = insertionPoint;\n      // if there is a possibility of an id match, scan forward\n      // keep track of the potential id match count we are discarding (the\n      // newChildPotentialIdCount must be greater than this to make it likely\n      // worth it)\n      let otherMatchCount = 0;\n      while (potentialMatch != null) {\n        // If we have an id match, return the current potential match\n        if (isIdSetMatch(newChild, potentialMatch, ctx)) {\n          return potentialMatch;\n        }\n\n        // computer the other potential matches of this new content\n        otherMatchCount += getIdIntersectionCount(\n          ctx,\n          potentialMatch,\n          newContent,\n        );\n        if (otherMatchCount > newChildPotentialIdCount) {\n          // if we have more potential id matches in _other_ content, we\n          // do not have a good candidate for an id match, so return null\n          return null;\n        }\n\n        // advanced to the next old content child\n        potentialMatch = potentialMatch.nextSibling;\n      }\n    }\n    return potentialMatch;\n  }\n\n  /**\n   * =============================================================================\n   *  Scans forward from the insertionPoint in the old parent looking for a potential soft match\n   *  for the newChild.  We stop if we find a potential soft match for the new child OR\n   *  if we find a potential id match in the old parents children OR if we find two\n   *  potential soft matches for the next two pieces of new content\n   * =============================================================================\n   * @param {Node} newContent\n   * @param {Node} oldParent\n   * @param {Node} newChild\n   * @param {Node} insertionPoint\n   * @param {MorphContext} ctx\n   * @returns {null | Node}\n   */\n  function findSoftMatch(newContent, oldParent, newChild, insertionPoint, ctx) {\n    /**\n     * @type {Node | null}\n     */\n    let potentialSoftMatch = insertionPoint;\n    /**\n     * @type {Node | null}\n     */\n    let nextSibling = newChild.nextSibling;\n    let siblingSoftMatchCount = 0;\n\n    while (potentialSoftMatch != null) {\n      if (getIdIntersectionCount(ctx, potentialSoftMatch, newContent) > 0) {\n        // the current potential soft match has a potential id set match with the remaining new\n        // content so bail out of looking\n        return null;\n      }\n\n      // if we have a soft match with the current node, return it\n      if (isSoftMatch(potentialSoftMatch, newChild)) {\n        return potentialSoftMatch;\n      }\n\n      if (isSoftMatch(potentialSoftMatch, nextSibling)) {\n        // the next new node has a soft match with this node, so\n        // increment the count of future soft matches\n        siblingSoftMatchCount++;\n        // ok to cast: if it was null it couldn't be a soft match\n        nextSibling = /** @type {Node} */ (nextSibling).nextSibling;\n\n        // If there are two future soft matches, bail to allow the siblings to soft match\n        // so that we don't consume future soft matches for the sake of the current node\n        if (siblingSoftMatchCount >= 2) {\n          return null;\n        }\n      }\n\n      // advanced to the next old content child\n      potentialSoftMatch = potentialSoftMatch.nextSibling;\n    }\n\n    return potentialSoftMatch;\n  }\n\n  /** @type {WeakSet<Node>} */\n  const generatedByIdiomorph = new WeakSet();\n\n  /**\n   *\n   * @param {string} newContent\n   * @returns {Node | null | DocumentFragment}\n   */\n  function parseContent(newContent) {\n    let parser = new DOMParser();\n\n    // remove svgs to avoid false-positive matches on head, etc.\n    let contentWithSvgsRemoved = newContent.replace(\n      /<svg(\\s[^>]*>|>)([\\s\\S]*?)<\\/svg>/gim,\n      \"\",\n    );\n\n    // if the newContent contains a html, head or body tag, we can simply parse it w/o wrapping\n    if (\n      contentWithSvgsRemoved.match(/<\\/html>/) ||\n      contentWithSvgsRemoved.match(/<\\/head>/) ||\n      contentWithSvgsRemoved.match(/<\\/body>/)\n    ) {\n      let content = parser.parseFromString(newContent, \"text/html\");\n      // if it is a full HTML document, return the document itself as the parent container\n      if (contentWithSvgsRemoved.match(/<\\/html>/)) {\n        generatedByIdiomorph.add(content);\n        return content;\n      } else {\n        // otherwise return the html element as the parent container\n        let htmlElement = content.firstChild;\n        if (htmlElement) {\n          generatedByIdiomorph.add(htmlElement);\n          return htmlElement;\n        } else {\n          return null;\n        }\n      }\n    } else {\n      // if it is partial HTML, wrap it in a template tag to provide a parent element and also to help\n      // deal with touchy tags like tr, tbody, etc.\n      let responseDoc = parser.parseFromString(\n        \"<body><template>\" + newContent + \"</template></body>\",\n        \"text/html\",\n      );\n      let content = /** @type {HTMLTemplateElement} */ (\n        responseDoc.body.querySelector(\"template\")\n      ).content;\n      generatedByIdiomorph.add(content);\n      return content;\n    }\n  }\n\n  /**\n   *\n   * @param {null | Node | HTMLCollection | Node[] | Document & {generatedByIdiomorph:boolean}} newContent\n   * @returns {Element}\n   */\n  function normalizeContent(newContent) {\n    if (newContent == null) {\n      // noinspection UnnecessaryLocalVariableJS\n      const dummyParent = document.createElement(\"div\");\n      return dummyParent;\n    } else if (generatedByIdiomorph.has(/** @type {Element} */ (newContent))) {\n      // the template tag created by idiomorph parsing can serve as a dummy parent\n      return /** @type {Element} */ (newContent);\n    } else if (newContent instanceof Node) {\n      // a single node is added as a child to a dummy parent\n      const dummyParent = document.createElement(\"div\");\n      dummyParent.append(newContent);\n      return dummyParent;\n    } else {\n      // all nodes in the array or HTMLElement collection are consolidated under\n      // a single dummy parent element\n      const dummyParent = document.createElement(\"div\");\n      for (const elt of [...newContent]) {\n        dummyParent.append(elt);\n      }\n      return dummyParent;\n    }\n  }\n\n  /**\n   *\n   * @param {Node | null} previousSibling\n   * @param {Node} morphedNode\n   * @param {Node | null} nextSibling\n   * @returns {Node[]}\n   */\n  function insertSiblings(previousSibling, morphedNode, nextSibling) {\n    /**\n     * @type {Node[]}\n     */\n    let stack = [];\n    /**\n     * @type {Node[]}\n     */\n    let added = [];\n    while (previousSibling != null) {\n      stack.push(previousSibling);\n      previousSibling = previousSibling.previousSibling;\n    }\n    // Base the loop on the node variable, so that you do not need runtime checks for\n    // undefined value inside the loop\n    let node = stack.pop();\n    while (node !== undefined) {\n      added.push(node); // push added preceding siblings on in order and insert\n      morphedNode.parentElement?.insertBefore(node, morphedNode);\n      node = stack.pop();\n    }\n    added.push(morphedNode);\n    while (nextSibling != null) {\n      stack.push(nextSibling);\n      added.push(nextSibling); // here we are going in order, so push on as we scan, rather than add\n      nextSibling = nextSibling.nextSibling;\n    }\n    while (stack.length > 0) {\n      const node = /** @type {Node} */ (stack.pop());\n      morphedNode.parentElement?.insertBefore(node, morphedNode.nextSibling);\n    }\n    return added;\n  }\n\n  /**\n   *\n   * @param {Element} newContent\n   * @param {Element} oldNode\n   * @param {MorphContext} ctx\n   * @returns {Node | null}\n   */\n  function findBestNodeMatch(newContent, oldNode, ctx) {\n    /**\n     * @type {Node | null}\n     */\n    let currentElement;\n    currentElement = newContent.firstChild;\n    /**\n     * @type {Node | null}\n     */\n    let bestElement = currentElement;\n    let score = 0;\n    while (currentElement) {\n      let newScore = scoreElement(currentElement, oldNode, ctx);\n      if (newScore > score) {\n        bestElement = currentElement;\n        score = newScore;\n      }\n      currentElement = currentElement.nextSibling;\n    }\n    return bestElement;\n  }\n\n  /**\n   *\n   * @param {Node | null} node1\n   * @param {Element} node2\n   * @param {MorphContext} ctx\n   * @returns {number}\n   */\n  // TODO: The function handles node1 and node2 as if they are Elements but the function is\n  //   called in places where node1 and node2 may be just Nodes, not Elements\n  function scoreElement(node1, node2, ctx) {\n    if (isSoftMatch(node2, node1)) {\n      // ok to cast: isSoftMatch performs a null check\n      return (\n        0.5 + getIdIntersectionCount(ctx, /** @type {Node} */ (node1), node2)\n      );\n    }\n    return 0;\n  }\n\n  /**\n   *\n   * @param {Node} tempNode\n   * @param {MorphContext} ctx\n   */\n  // TODO: The function handles tempNode as if it's Element but the function is called in\n  //   places where tempNode may be just a Node, not an Element\n  function removeNode(tempNode, ctx) {\n    removeIdsFromConsideration(ctx, tempNode);\n    // skip remove callbacks when we're going to be restoring this from the pantry in the second pass\n    if (\n      ctx.config.twoPass &&\n      hasPersistentIdNodes(ctx, tempNode) &&\n      tempNode instanceof Element\n    ) {\n      moveToPantry(tempNode, ctx);\n    } else {\n      if (ctx.callbacks.beforeNodeRemoved(tempNode) === false) return;\n      tempNode.parentNode?.removeChild(tempNode);\n      ctx.callbacks.afterNodeRemoved(tempNode);\n    }\n  }\n\n  /**\n   *\n   * @param {Node} node\n   * @param {MorphContext} ctx\n   */\n  function moveToPantry(node, ctx) {\n    if (ctx.callbacks.beforeNodePantried(node) === false) return;\n\n    Array.from(node.childNodes).forEach((child) => {\n      moveToPantry(child, ctx);\n    });\n\n    // After processing children, process the current node\n    if (ctx.persistentIds.has(/** @type {Element} */ (node).id)) {\n      // @ts-ignore - use proposed moveBefore feature\n      if (ctx.pantry.moveBefore) {\n        // @ts-ignore - use proposed moveBefore feature\n        ctx.pantry.moveBefore(node, null);\n      } else {\n        ctx.pantry.insertBefore(node, null);\n      }\n    } else {\n      if (ctx.callbacks.beforeNodeRemoved(node) === false) return;\n      node.parentNode?.removeChild(node);\n      ctx.callbacks.afterNodeRemoved(node);\n    }\n  }\n\n  /**\n   *\n   * @param {Node | null} root\n   * @param {MorphContext} ctx\n   */\n  function restoreFromPantry(root, ctx) {\n    if (root instanceof Element) {\n      Array.from(ctx.pantry.children)\n        .reverse()\n        .forEach((element) => {\n          const matchElement = root.querySelector(`#${element.id}`);\n          if (matchElement) {\n            // @ts-ignore - use proposed moveBefore feature\n            if (matchElement.parentElement?.moveBefore) {\n              // @ts-ignore - use proposed moveBefore feature\n              matchElement.parentElement.moveBefore(element, matchElement);\n              while (matchElement.hasChildNodes()) {\n                // @ts-ignore - use proposed moveBefore feature\n                element.moveBefore(matchElement.firstChild, null);\n              }\n            } else {\n              matchElement.before(element);\n              while (matchElement.firstChild) {\n                element.insertBefore(matchElement.firstChild, null);\n              }\n            }\n            if (\n              ctx.callbacks.beforeNodeMorphed(element, matchElement) !== false\n            ) {\n              syncNodeFrom(matchElement, element, ctx);\n              ctx.callbacks.afterNodeMorphed(element, matchElement);\n            }\n            matchElement.remove();\n          }\n        });\n      ctx.pantry.remove();\n    }\n  }\n\n  //=============================================================================\n  // ID Set Functions\n  //=============================================================================\n\n  /**\n   *\n   * @param {MorphContext} ctx\n   * @param {string} id\n   * @returns {boolean}\n   */\n  function isIdInConsideration(ctx, id) {\n    return !ctx.deadIds.has(id);\n  }\n\n  /**\n   *\n   * @param {MorphContext} ctx\n   * @param {string} id\n   * @param {Node} targetNode\n   * @returns {boolean}\n   */\n  function idIsWithinNode(ctx, id, targetNode) {\n    let idSet = ctx.idMap.get(targetNode) || EMPTY_SET;\n    return idSet.has(id);\n  }\n\n  /**\n   *\n   * @param {MorphContext} ctx\n   * @param {Node} node\n   * @returns {void}\n   */\n  function removeIdsFromConsideration(ctx, node) {\n    let idSet = ctx.idMap.get(node) || EMPTY_SET;\n    for (const id of idSet) {\n      ctx.deadIds.add(id);\n    }\n  }\n\n  /**\n   *\n   * @param {MorphContext} ctx\n   * @param {Node} node\n   * @returns {boolean}\n   */\n  function hasPersistentIdNodes(ctx, node) {\n    for (const id of ctx.idMap.get(node) || EMPTY_SET) {\n      if (ctx.persistentIds.has(id)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   *\n   * @param {MorphContext} ctx\n   * @param {Node} node1\n   * @param {Node} node2\n   * @returns {number}\n   */\n  function getIdIntersectionCount(ctx, node1, node2) {\n    let sourceSet = ctx.idMap.get(node1) || EMPTY_SET;\n    let matchCount = 0;\n    for (const id of sourceSet) {\n      // a potential match is an id in the source and potentialIdsSet, but\n      // that has not already been merged into the DOM\n      if (isIdInConsideration(ctx, id) && idIsWithinNode(ctx, id, node2)) {\n        ++matchCount;\n      }\n    }\n    return matchCount;\n  }\n\n  /**\n   * @param {Element} content\n   * @returns {Element[]}\n   */\n  function nodesWithIds(content) {\n    let nodes = Array.from(content.querySelectorAll(\"[id]\"));\n    if (content.id) {\n      nodes.push(content);\n    }\n    return nodes;\n  }\n\n  /**\n   * A bottom up algorithm that finds all elements with ids in the node\n   * argument and populates id sets for those nodes and all their parents, generating\n   * a set of ids contained within all nodes for the entire hierarchy in the DOM\n   *\n   * @param {Element} node\n   * @param {Map<Node, Set<string>>} idMap\n   */\n  function populateIdMapForNode(node, idMap) {\n    let nodeParent = node.parentElement;\n    for (const elt of nodesWithIds(node)) {\n      /**\n       * @type {Element|null}\n       */\n      let current = elt;\n      // walk up the parent hierarchy of that element, adding the id\n      // of element to the parent's id set\n      while (current !== nodeParent && current != null) {\n        let idSet = idMap.get(current);\n        // if the id set doesn't exist, create it and insert it in the  map\n        if (idSet == null) {\n          idSet = new Set();\n          idMap.set(current, idSet);\n        }\n        idSet.add(elt.id);\n        current = current.parentElement;\n      }\n    }\n  }\n\n  /**\n   * This function computes a map of nodes to all ids contained within that node (inclusive of the\n   * node).  This map can be used to ask if two nodes have intersecting sets of ids, which allows\n   * for a looser definition of \"matching\" than tradition id matching, and allows child nodes\n   * to contribute to a parent nodes matching.\n   *\n   * @param {Element} oldContent  the old content that will be morphed\n   * @param {Element} newContent  the new content to morph to\n   * @returns {Map<Node, Set<string>>} a map of nodes to id sets for the\n   */\n  function createIdMap(oldContent, newContent) {\n    /**\n     *\n     * @type {Map<Node, Set<string>>}\n     */\n    let idMap = new Map();\n    populateIdMapForNode(oldContent, idMap);\n    populateIdMapForNode(newContent, idMap);\n    return idMap;\n  }\n\n  /**\n   * @param {Element} oldContent  the old content that will be morphed\n   * @param {Element} newContent  the new content to morph to\n   * @returns {Set<string>} the id set of all persistent nodes that exist in both old and new content\n   */\n  function createPersistentIds(oldContent, newContent) {\n    const toIdTagName = (node) => node.tagName + \"#\" + node.id;\n    const oldIdSet = new Set(nodesWithIds(oldContent).map(toIdTagName));\n\n    let matchIdSet = new Set();\n    for (const newNode of nodesWithIds(newContent)) {\n      if (oldIdSet.has(toIdTagName(newNode))) {\n        matchIdSet.add(newNode.id);\n      }\n    }\n    return matchIdSet;\n  }\n\n  //=============================================================================\n  // This is what ends up becoming the Idiomorph global object\n  //=============================================================================\n  return {\n    morph,\n    defaults,\n  };\n})();\n\nexport {Idiomorph};\n","const customEvent = (() => {\n\treturn ('CustomEvent' in window && typeof window.CustomEvent === 'function')\n\t\t? (name, data) => new CustomEvent(name, data)\n\t\t: (name, data) => {\n\t\t\tconst newEvent = document.createEvent('CustomEvent')\n\t\t\tnewEvent.initCustomEvent(name, true, true, data)\n\t\t\treturn newEvent\n\t\t}\n})()\n\nconst handler = (node, ev) => {\n\treturn function (e) {\n\t\tconst scope = this\n\t\tconst detail = e.detail || {}\n\t\tnode.__events[ev].forEach(o => {\n\t\t\to.handler.apply(scope, [e].concat(detail.args))\n\t\t})\n\t}\n}\n\nconst removeListener = (node, ev) => {\n\tif (node.__events[ev] && node.__events[ev].listener) {\n\t\tnode.removeEventListener(\n\t\t\tev,\n\t\t\tnode.__events[ev].listener,\n\t\t\t(ev == 'focus' || ev == 'blur' || ev == 'mouseenter' || ev == 'mouseleave'))\n\t\tdelete node.__events[ev]\n\t}\n}\n\nconst delegate = (node, selector, callback) => {\n\treturn function (e) {\n\n\t\tconst element = this\n\t\tconst detail = e.detail || {}\n\n\t\tlet parent = e.target\n\n\t\twhile (parent) {\n\t\t\tif (parent.matches(selector)) {\n\t\t\t\te.delegateTarget = parent\n\t\t\t\tcallback.apply(element, [e].concat(detail.args))\n\t\t\t}\n\t\t\tif (parent === node) break\n\t\t\tparent = parent.parentNode\n\t\t}\n\t}\n}\n\nexport const on = (node, ev, selectorOrCallback, callback) => {\n\n\tnode.__events = node.__events || {}\n\tnode.__events[ev] = (node.__events[ev] || [])\n\n\tif (!node.__events[ev].length) {\n\t\tconst fn = handler(node, ev)\n\t\tnode.addEventListener(\n\t\t\tev,\n\t\t\tfn,\n\t\t\t(ev == 'focus' || ev == 'blur' || ev == 'mouseenter' || ev == 'mouseleave'))\n\t\tnode.__events[ev].listener = fn\n\t}\n\n\tif (selectorOrCallback.call) {\n\t\tnode.__events[ev].push({ handler: selectorOrCallback, callback: selectorOrCallback })\n\t} else {\n\t\tnode.__events[ev].push({ handler: delegate(node, selectorOrCallback, callback), callback })\n\t}\n}\n\nexport const off = (node, ev, fn) => {\n\n\tif (fn && node.__events[ev] && node.__events[ev].length) {\n\t\tvar old = node.__events[ev]\n\t\tnode.__events[ev] = node.__events[ev].filter(function (o) { return o.callback != fn; })\n\t\tnode.__events[ev].listener = old.listener\n\t\tif (!node.__events[ev].length)\n\t\t\tremoveListener(node, ev)\n\t} else {\n\t\tremoveListener(node, ev)\n\t}\n}\n\nexport const trigger = (node, name, args) => {\n\tnode.dispatchEvent(customEvent(name, { bubbles: true, detail: args }))\n}\n","import { type Component } from '..'\nimport { Idiomorph } from 'idiomorph/dist/idiomorph.esm'\nimport { rAF, dup, safe } from './utils'\nimport { buildtemplates } from './template-system'\nimport { on, off, trigger } from './utils/events'\nimport { publish, subscribe } from './utils/pubsub'\n\nexport default function Component( elm, { module, dependencies, templates, components }) {\n\n\tconst options = getOptions( module )\n\tconst initialState = (new Function( `return ${elm.getAttribute('html-model') || '{}'}`))()\n\tconst selector = Object.keys(components).toString()\n\n\tbuildtemplates( elm, selector, templates, components )\n\n\tconst tplid = elm.getAttribute('tplid')\n\tconst template = tplid ? templates[tplid] : null\n\tconst state = { data: module.model ? dup(module.model) : {} }\n\tstate.data = Object.assign( state.data, initialState)\n\n\tconst base: Component = {\n\t\ttemplate,\n\t\telm,\n\t\tdependencies,\n\t\tpublish,\n\t\tsubscribe,\n\n\t\tmain(fn) {\n\t\t\toptions.main = fn\n\t\t},\n\n\t\tunmount(fn) {\n\t\t\toptions.unmount = fn\n\t\t},\n\n\t\tonupdate(fn) {\n\t\t\toptions.onupdate = fn\n\t\t},\n\n\t\ton(eventName, selectorOrCallback, callback) {\n\t\t\ton(elm, eventName, selectorOrCallback, callback)\n\t\t},\n\n\t\toff(eventName, callback) {\n\t\t\toff(elm, eventName, callback)\n\t\t},\n\n\t\ttrigger(eventName, target, args) {\n\t\t\tif (target.constructor === String) {\n\t\t\t\tArray\n\t\t\t\t\t.from(elm.querySelectorAll(target))\n\t\t\t\t\t.forEach( children => trigger(children, eventName, { args: args }) )\n\t\t\t}\n\t\t\telse trigger(elm, eventName, { args: target })\n\t\t},\n\n\t\temit: ( ...args ) => {\n\t\t\ttrigger(elm, args.shift(), { args: args })\n\t\t},\n\n\t\tstate: {\n\t\t\tset( data ) {\n\t\t\t\tif (data.constructor === Function) {\n\t\t\t\t\tconst newstate = dup(state.data)\n\t\t\t\t\tdata(newstate)\n\t\t\t\t\tbase.render(newstate)\n\t\t\t\t} else {\n\t\t\t\t\tbase.render(data)\n\t\t\t\t}\n\t\t\t\treturn new Promise((resolve) => rAF(_ => rAF(() => resolve(state.data))))\n\t\t\t},\n\t\t\tget() {\n\t\t\t\treturn dup(state.data)\n\t\t\t},\n\n\t\t\tgetRaw(){\n\t\t\t\treturn state.data\n\t\t\t}\n\t\t},\n\n\t\trender(data = state.data) {\n\n\t\t\tif (!document.body.contains(elm)) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tstate.data = Object.assign(state.data, data)\n\n\t\t\tconst newdata = dup(state.data)\n\t\t\tconst newhtml = templates[tplid].call(Object.assign(options.view(newdata), elm.___scope___), elm, safe)\n\n\t\t\tIdiomorph.morph(elm, newhtml, IdiomorphOptions(elm))\n\t\t\tupdateScope( elm )\n\n\t\t\trAF(_ => {\n\t\t\t\tArray\n\t\t\t\t\t.from(elm.querySelectorAll('[tplid]'))\n\t\t\t\t\t.forEach((child: any) => {\n\t\t\t\t\t\tconst props = Object.assign( child.base.state.getRaw(), data )\n\t\t\t\t\t\tchild.options.onupdate(props)\n\t\t\t\t\t\tchild.base.render(props)\n\t\t\t\t\t})\n\t\t\t})\n\t\t},\n\n\t\tinnerHTML( target, html_ ) {\n\n\t\t\tconst element = html_? target : elm\n\t\t\tconst clone = element.cloneNode()\n\t\t\tconst html = html_? html_ : target\n\t\t\tclone.innerHTML = html\n\n\t\t\trAF( _ => Idiomorph.morph(element, clone, IdiomorphOptions) )\n\t\t}\n\t}\n\n\treturn { base, options }\n}\n\nconst getOptions = (module) => ({\n\tmain: (a) => a,\n\tunmount: (a) => a,\n\tonupdate: (a) => a,\n\tview: module.view ? module.view : (a) => a\n})\n\nconst updateScope = (node) => {\n\tnode.querySelectorAll('[scope]').forEach( scopeElement => {\n\t\tscopeElement.querySelectorAll('[tplid]').forEach( cp => {\n\t\t\tif( !cp.___scope___ ) {\n\t\t\t\tconst script = scopeElement.lastElementChild\n\t\t\t\tcp.___scope___ = 'scope' in script.dataset? (new Function(`return ${script.text}`))() : {}\n\t\t\t}\n\t\t})\n\t})\n}\n\n\nconst IdiomorphOptions = (parent) => ({\n\n\tcallbacks: {\n\n\t\tbeforeNodeMorphed( node ) {\n\t\t\tif( node.nodeType === 1 ) {\n\t\t\t\tif( 'html-static' in node.attributes ) {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\tif( node.base && node !== parent ) {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n})\n","import Component from './component'\nimport { purge, rAF } from './utils'\n\nexport default function Element(module, dependencies, templates, components) {\n\n\treturn class extends HTMLElement {\n\n\t\tbase: any\n\t\toptions: any\n\t\treturns : any\n\t\t__events: any\n\n\t\tconstructor() {\n\t\t\tsuper()\n\t\t}\n\n\t\tconnectedCallback() {\n\n\t\t\tconst { base, options } = Component(this, { module, dependencies, templates, components })\n\n\t\t\tthis.base = base\n\t\t\tthis.options = options\n\t\t\tthis.base.render()\n\t\t\tthis.returns = module.default(base)\n\n\t\t\tif( this.__template && this.__template.constructor === Promise ) {\n\t\t\t\tthis.__template.then( _ => {\n\t\t\t\t\tif( this.base && this.options.main) {\n\t\t\t\t\t\tconst array = this.options.main(this.base)\n\t\t\t\t\t\tif( array && array.length ){\n\t\t\t\t\t\t\tarray.forEach(f => f(this.base))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif( this.returns && this.returns.constructor === Promise ) {\n\t\t\t\tthis.returns.then( _ => {\n\t\t\t\t\tif( this.base && this.options.main) {\n\t\t\t\t\t\tconst array = this.options.main(this.base)\n\t\t\t\t\t\tif( array && array.length ){\n\t\t\t\t\t\t\tarray.forEach(f => f(this.base))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\t} else {\n\t\t\t\tif( this.base && this.options.main ){\n\t\t\t\t\tconst array = this.options.main(this.base)\n\t\t\t\t\tif( array && array.length ) {\n\t\t\t\t\t\tarray.forEach(f => f(this.base))\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdisconnectedCallback() {\n\t\t\tthis.options.unmount(this.base)\n\t\t\trAF(() => {\n\t\t\t\tif(!document.body.contains(this) ) {\n\t\t\t\t\tthis.__events? this.__events = null : null\n\t\t\t\t\tthis.base? this.base.elm = null : null\n\t\t\t\t\tthis.base? this.base = null : null\n\t\t\t\t\tpurge(this)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\n\t\tattributeChangedCallback() {\n\t\t\t//TODO\n\t\t}\n\t}\n}\n","import { templateConfig, buildtemplates } from './template-system'\nimport { publish, subscribe } from './utils/pubsub'\nimport { html, attributes } from '../html'\nimport Element from './element'\n\nconst templates = {}\nconst components = {}\n\nexport { html, attributes }\n\nexport default {\n\n\ttemplateConfig,\n\n\tpublish,\n\tsubscribe,\n\n\tregister( name, module, dependencies = {} ) {\n\t\tcomponents[name] = { name, module, dependencies }\n\t},\n\n\tstart( target = document.body ) {\n\t\tconst keys = Object.keys(components)\n\t\tconst selector = keys.toString()\n\t\tif( keys.length ) {\n\t\t\tbuildtemplates( target, selector, templates, components )\n\t\t\tregisterComponents()\n\t\t}\n\t}\n}\n\nconst registerComponents = () => {\n\tObject\n\t\t.values( components )\n\t\t.forEach( (component) => {\n\t\t\tconst { name, module, dependencies } = component as any\n\t\t\tif( !customElements.get(name) ){\n\t\t\t\tconst Base = Element(module, dependencies, templates, components)\n\t\t\t\tcustomElements.define(name, Base)\n\t\t\t}\n\t\t})\n}\n","\nexport const attributes = ( attrs ) => {\n\tconst result = Object.entries(attrs)\n\t\t.map(([key, value]) => {\n\t\t\tif( value === '' ) {\n\t\t\t\treturn key\n\t\t\t}\n\t\t\treturn `${key}=\"${value}\"`\n\t\t})\n\t\t.join(' ')\n\treturn result\n}\n\n// From\n// https://2ality.com/2015/01/template-strings-html.html#comment-2078932192\nexport const html = (literalSections, ...substs) => {\n\n\t// Use raw literal sections: we dont want\n\t// backslashes (\\n etc.) to be interpreted\n\tlet raw = literalSections.raw\n\n\tlet result = ''\n\n\tsubsts.forEach((subst, i) => {\n\t\t// Retrieve the literal section preceding\n\t\t// the current substitution\n\t\tlet lit = raw[i]\n\n\t\t// In the example, map() returns an array:\n\t\t// If substitution is an array (and not a string),\n\t\t// we turn it into a string\n\t\tif (Array.isArray(subst)) {\n\t\t\tsubst = subst.join('')\n\t\t}\n\n\t\tresult += lit\n\t\tresult += subst\n\t})\n\t// Take care of last literal section\n\t// (Never fails, because an empty template string\n\t// produces one literal section, an empty string)\n\tresult += raw[raw.length-1] // (A)\n\n\treturn result\n}\n"],"names":["parser","DOMParser","wrap","open","node","close","_a","parentNode","insertBefore","_b","nextSibling","textarea","document","createElement","decodeHTML","text","innerHTML","value","rAF","fn","requestAnimationFrame","setTimeout","dup","o","JSON","parse","stringify","purge","d","i","l","n","a","attributes","length","name","childNodes","safe","execute","val","err","config","tags","Template","element","fixDIffIf","html","regexTags","RegExp","virtual","parseFromString","replace","querySelectorAll","forEach","htmlForeach","getAttribute","htmlFor","htmlIf","htmlInner","htmlClass","forEachInstruction","selector","split","match","varname","object","removeAttribute","setAttribute","script","dataset","scope","type","appendChild","createTextNode","className","trim","body","all","key","Transpile","outerHTML","decodedHTML","Function","_","variable","buildtemplates","target","templates","components","concat","matches","Array","from","reverse","template","content","createTemplateId","id","c","r","Math","random","toString","localName","module","children","constructor","Promise","__template","then","htmlstring","_if","querySelector","createComment","topics","_async","publish","params","Object","assign","topic","subscribe","method","push","filter","Idiomorph","EMPTY_SET","Set","defaults","morphStyle","callbacks","beforeNodeAdded","noOp","afterNodeAdded","beforeNodeMorphed","afterNodeMorphed","beforeNodeRemoved","afterNodeRemoved","beforeAttributeUpdated","beforeNodePantried","head","style","shouldPreserve","elt","shouldReAppend","shouldRemove","afterHeadMorphed","morphNormalizedContent","oldNode","normalizedNewContent","ctx","block","oldHead","newHead","promises","handleHeadElement","ignore","morphChildren","twoPass","restoreFromPantry","bestMatch","newContent","currentElement","firstChild","bestElement","score","newScore","scoreElement","findBestNodeMatch","previousSibling","morphedNode","morphOldNodeTo","elements","stack","added","pop","parentElement","insertSiblings","ignoreValueOfActiveElement","possibleActiveElement","ignoreActiveValue","activeElement","ignoreActive","removeChild","isSoftMatch","HTMLHeadElement","syncNodeFrom","replaceChild","newParent","oldParent","HTMLTemplateElement","newChild","nextNewChild","insertionPoint","persistentIds","has","removeIdsFromConsideration","isIdSetMatch","idSetMatch","findIdSetMatch","removeNodesBetween","softMatch","findSoftMatch","tempNode","removeNode","ignoreAttribute","attr","to","updateType","nodeType","fromEl","toEl","fromAttributes","toAttributes","fromAttribute","toAttribute","hasAttribute","nodeValue","HTMLInputElement","fromValue","toValue","syncBooleanAttribute","HTMLOptionElement","HTMLTextAreaElement","syncInputValue","attributeName","Element","fromLiveValue","ignoreUpdate","newHeadTag","currentHead","removed","preserved","nodesToAppend","headMergeStyle","srcToNewHeadNodes","Map","newHeadChild","set","currentHeadElt","inNewContent","isReAppended","isPreserved","delete","values","newNode","newElt","createRange","createContextualFragment","href","src","resolve","promise","_resolve","addEventListener","removedElement","kept","createPantry","pantry","hidden","insertAdjacentElement","node1","node2","tagName","getIdIntersectionCount","startInclusive","endExclusive","cursor","newChildPotentialIdCount","potentialMatch","otherMatchCount","potentialSoftMatch","siblingSoftMatchCount","generatedByIdiomorph","WeakSet","idMap","get","hasPersistentIdNodes","moveToPantry","child","moveBefore","root","matchElement","hasChildNodes","before","remove","isIdInConsideration","deadIds","idIsWithinNode","targetNode","idSet","add","sourceSet","matchCount","nodesWithIds","nodes","populateIdMapForNode","nodeParent","current","createIdMap","oldContent","createPersistentIds","toIdTagName","oldIdSet","map","matchIdSet","morph","Document","documentElement","contentWithSvgsRemoved","htmlElement","parseContent","normalizedContent","Node","dummyParent","append","normalizeContent","mergedConfig","finalConfig","mergeDefaults","createMorphContext","customEvent","window","CustomEvent","data","newEvent","createEvent","initCustomEvent","handler","ev","e","this","detail","__events","apply","args","removeListener","listener","removeEventListener","delegate","callback","parent","delegateTarget","on","selectorOrCallback","call","off","old","trigger","dispatchEvent","bubbles","getOptions","main","unmount","onupdate","view","updateScope","scopeElement","cp","___scope___","lastElementChild","IdiomorphOptions","base","dependencies","HTMLElement","connectedCallback","options","elm","initialState","keys","tplid","state","model","eventName","String","emit","shift","newstate","render","getRaw","contains","newdata","newhtml","props","html_","clone","cloneNode","Component","returns","default","array","f","disconnectedCallback","attributeChangedCallback","index","templateConfig","newconfig","register","start","registerComponents","component","customElements","Base","define","attrs","entries","join","literalSections","substs","raw","result","subst","lit","isArray"],"mappings":"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","x_google_ignoreList":[4]}