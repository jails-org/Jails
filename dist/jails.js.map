{"version":3,"file":"jails.js","sources":["../src/utils/index.ts","../node_modules/idiomorph/dist/idiomorph.esm.js","../src/utils/pubsub.ts","../src/component.ts","../src/element.ts","../src/template-system.ts","../src/index.ts"],"sourcesContent":["\nconst textarea = document.createElement('textarea')\n\nexport const g = {\n\tscope: {}\n}\n\nexport const decodeHTML = (text) => {\n\ttextarea.innerHTML = text\n\treturn textarea.value\n}\n\nexport const rAF = (fn) => {\n\tif (requestAnimationFrame)\n\t\treturn requestAnimationFrame(fn)\n\telse\n\t\treturn setTimeout(fn, 1000 / 60)\n}\n\nexport const uuid = () => {\n\treturn Math.random().toString(36).substring(2, 9)\n}\n\nexport const dup = (o) => {\n\treturn JSON.parse(JSON.stringify(o))\n}\n\nexport const safe = (execute, val) => {\n\ttry{\n\t\treturn execute()\n\t}catch(err){\n\t\treturn val || ''\n\t}\n}\n","/**\n * @typedef {object} ConfigHead\n *\n * @property {'merge' | 'append' | 'morph' | 'none'} [style]\n * @property {boolean} [block]\n * @property {boolean} [ignore]\n * @property {function(Element): boolean} [shouldPreserve]\n * @property {function(Element): boolean} [shouldReAppend]\n * @property {function(Element): boolean} [shouldRemove]\n * @property {function(Element, {added: Node[], kept: Element[], removed: Element[]}): void} [afterHeadMorphed]\n */\n\n/**\n * @typedef {object} ConfigCallbacks\n *\n * @property {function(Node): boolean} [beforeNodeAdded]\n * @property {function(Node): void} [afterNodeAdded]\n * @property {function(Element, Node): boolean} [beforeNodeMorphed]\n * @property {function(Element, Node): void} [afterNodeMorphed]\n * @property {function(Element): boolean} [beforeNodeRemoved]\n * @property {function(Element): void} [afterNodeRemoved]\n * @property {function(string, Element, \"update\" | \"remove\"): boolean} [beforeAttributeUpdated]\n */\n\n/**\n * @typedef {object} Config\n *\n * @property {'outerHTML' | 'innerHTML'} [morphStyle]\n * @property {boolean} [ignoreActive]\n * @property {boolean} [ignoreActiveValue]\n * @property {boolean} [restoreFocus]\n * @property {ConfigCallbacks} [callbacks]\n * @property {ConfigHead} [head]\n */\n\n/**\n * @typedef {function} NoOp\n *\n * @returns {void}\n */\n\n/**\n * @typedef {object} ConfigHeadInternal\n *\n * @property {'merge' | 'append' | 'morph' | 'none'} style\n * @property {boolean} [block]\n * @property {boolean} [ignore]\n * @property {(function(Element): boolean) | NoOp} shouldPreserve\n * @property {(function(Element): boolean) | NoOp} shouldReAppend\n * @property {(function(Element): boolean) | NoOp} shouldRemove\n * @property {(function(Element, {added: Node[], kept: Element[], removed: Element[]}): void) | NoOp} afterHeadMorphed\n */\n\n/**\n * @typedef {object} ConfigCallbacksInternal\n *\n * @property {(function(Node): boolean) | NoOp} beforeNodeAdded\n * @property {(function(Node): void) | NoOp} afterNodeAdded\n * @property {(function(Node, Node): boolean) | NoOp} beforeNodeMorphed\n * @property {(function(Node, Node): void) | NoOp} afterNodeMorphed\n * @property {(function(Node): boolean) | NoOp} beforeNodeRemoved\n * @property {(function(Node): void) | NoOp} afterNodeRemoved\n * @property {(function(string, Element, \"update\" | \"remove\"): boolean) | NoOp} beforeAttributeUpdated\n */\n\n/**\n * @typedef {object} ConfigInternal\n *\n * @property {'outerHTML' | 'innerHTML'} morphStyle\n * @property {boolean} [ignoreActive]\n * @property {boolean} [ignoreActiveValue]\n * @property {boolean} [restoreFocus]\n * @property {ConfigCallbacksInternal} callbacks\n * @property {ConfigHeadInternal} head\n */\n\n/**\n * @typedef {Object} IdSets\n * @property {Set<string>} persistentIds\n * @property {Map<Node, Set<string>>} idMap\n */\n\n/**\n * @typedef {Function} Morph\n *\n * @param {Element | Document} oldNode\n * @param {Element | Node | HTMLCollection | Node[] | string | null} newContent\n * @param {Config} [config]\n * @returns {undefined | Node[]}\n */\n\n// base IIFE to define idiomorph\n/**\n *\n * @type {{defaults: ConfigInternal, morph: Morph}}\n */\nvar Idiomorph = (function () {\n  \"use strict\";\n\n  /**\n   * @typedef {object} MorphContext\n   *\n   * @property {Element} target\n   * @property {Element} newContent\n   * @property {ConfigInternal} config\n   * @property {ConfigInternal['morphStyle']} morphStyle\n   * @property {ConfigInternal['ignoreActive']} ignoreActive\n   * @property {ConfigInternal['ignoreActiveValue']} ignoreActiveValue\n   * @property {ConfigInternal['restoreFocus']} restoreFocus\n   * @property {Map<Node, Set<string>>} idMap\n   * @property {Set<string>} persistentIds\n   * @property {ConfigInternal['callbacks']} callbacks\n   * @property {ConfigInternal['head']} head\n   * @property {HTMLDivElement} pantry\n   */\n\n  //=============================================================================\n  // AND NOW IT BEGINS...\n  //=============================================================================\n\n  const noOp = () => {};\n  /**\n   * Default configuration values, updatable by users now\n   * @type {ConfigInternal}\n   */\n  const defaults = {\n    morphStyle: \"outerHTML\",\n    callbacks: {\n      beforeNodeAdded: noOp,\n      afterNodeAdded: noOp,\n      beforeNodeMorphed: noOp,\n      afterNodeMorphed: noOp,\n      beforeNodeRemoved: noOp,\n      afterNodeRemoved: noOp,\n      beforeAttributeUpdated: noOp,\n    },\n    head: {\n      style: \"merge\",\n      shouldPreserve: (elt) => elt.getAttribute(\"im-preserve\") === \"true\",\n      shouldReAppend: (elt) => elt.getAttribute(\"im-re-append\") === \"true\",\n      shouldRemove: noOp,\n      afterHeadMorphed: noOp,\n    },\n    restoreFocus: true,\n  };\n\n  /**\n   * Core idiomorph function for morphing one DOM tree to another\n   *\n   * @param {Element | Document} oldNode\n   * @param {Element | Node | HTMLCollection | Node[] | string | null} newContent\n   * @param {Config} [config]\n   * @returns {Promise<Node[]> | Node[]}\n   */\n  function morph(oldNode, newContent, config = {}) {\n    oldNode = normalizeElement(oldNode);\n    const newNode = normalizeParent(newContent);\n    const ctx = createMorphContext(oldNode, newNode, config);\n\n    const morphedNodes = saveAndRestoreFocus(ctx, () => {\n      return withHeadBlocking(\n        ctx,\n        oldNode,\n        newNode,\n        /** @param {MorphContext} ctx */ (ctx) => {\n          if (ctx.morphStyle === \"innerHTML\") {\n            morphChildren(ctx, oldNode, newNode);\n            return Array.from(oldNode.childNodes);\n          } else {\n            return morphOuterHTML(ctx, oldNode, newNode);\n          }\n        },\n      );\n    });\n\n    ctx.pantry.remove();\n    return morphedNodes;\n  }\n\n  /**\n   * Morph just the outerHTML of the oldNode to the newContent\n   * We have to be careful because the oldNode could have siblings which need to be untouched\n   * @param {MorphContext} ctx\n   * @param {Element} oldNode\n   * @param {Element} newNode\n   * @returns {Node[]}\n   */\n  function morphOuterHTML(ctx, oldNode, newNode) {\n    const oldParent = normalizeParent(oldNode);\n\n    // basis for calulating which nodes were morphed\n    // since there may be unmorphed sibling nodes\n    let childNodes = Array.from(oldParent.childNodes);\n    const index = childNodes.indexOf(oldNode);\n    // how many elements are to the right of the oldNode\n    const rightMargin = childNodes.length - (index + 1);\n\n    morphChildren(\n      ctx,\n      oldParent,\n      newNode,\n      // these two optional params are the secret sauce\n      oldNode, // start point for iteration\n      oldNode.nextSibling, // end point for iteration\n    );\n\n    // return just the morphed nodes\n    childNodes = Array.from(oldParent.childNodes);\n    return childNodes.slice(index, childNodes.length - rightMargin);\n  }\n\n  /**\n   * @param {MorphContext} ctx\n   * @param {Function} fn\n   * @returns {Promise<Node[]> | Node[]}\n   */\n  function saveAndRestoreFocus(ctx, fn) {\n    if (!ctx.config.restoreFocus) return fn();\n    let activeElement =\n      /** @type {HTMLInputElement|HTMLTextAreaElement|null} */ (\n        document.activeElement\n      );\n\n    // don't bother if the active element is not an input or textarea\n    if (\n      !(\n        activeElement instanceof HTMLInputElement ||\n        activeElement instanceof HTMLTextAreaElement\n      )\n    ) {\n      return fn();\n    }\n\n    const { id: activeElementId, selectionStart, selectionEnd } = activeElement;\n\n    const results = fn();\n\n    if (activeElementId && activeElementId !== document.activeElement?.id) {\n      activeElement = ctx.target.querySelector(`#${activeElementId}`);\n      activeElement?.focus();\n    }\n    if (activeElement && !activeElement.selectionEnd && selectionEnd) {\n      activeElement.setSelectionRange(selectionStart, selectionEnd);\n    }\n\n    return results;\n  }\n\n  const morphChildren = (function () {\n    /**\n     * This is the core algorithm for matching up children.  The idea is to use id sets to try to match up\n     * nodes as faithfully as possible.  We greedily match, which allows us to keep the algorithm fast, but\n     * by using id sets, we are able to better match up with content deeper in the DOM.\n     *\n     * Basic algorithm:\n     * - for each node in the new content:\n     *   - search self and siblings for an id set match, falling back to a soft match\n     *   - if match found\n     *     - remove any nodes up to the match:\n     *       - pantry persistent nodes\n     *       - delete the rest\n     *     - morph the match\n     *   - elsif no match found, and node is persistent\n     *     - find its match by querying the old root (future) and pantry (past)\n     *     - move it and its children here\n     *     - morph it\n     *   - else\n     *     - create a new node from scratch as a last result\n     *\n     * @param {MorphContext} ctx the merge context\n     * @param {Element} oldParent the old content that we are merging the new content into\n     * @param {Element} newParent the parent element of the new content\n     * @param {Node|null} [insertionPoint] the point in the DOM we start morphing at (defaults to first child)\n     * @param {Node|null} [endPoint] the point in the DOM we stop morphing at (defaults to after last child)\n     */\n    function morphChildren(\n      ctx,\n      oldParent,\n      newParent,\n      insertionPoint = null,\n      endPoint = null,\n    ) {\n      // normalize\n      if (\n        oldParent instanceof HTMLTemplateElement &&\n        newParent instanceof HTMLTemplateElement\n      ) {\n        // @ts-ignore we can pretend the DocumentFragment is an Element\n        oldParent = oldParent.content;\n        // @ts-ignore ditto\n        newParent = newParent.content;\n      }\n      insertionPoint ||= oldParent.firstChild;\n\n      // run through all the new content\n      for (const newChild of newParent.childNodes) {\n        // once we reach the end of the old parent content skip to the end and insert the rest\n        if (insertionPoint && insertionPoint != endPoint) {\n          const bestMatch = findBestMatch(\n            ctx,\n            newChild,\n            insertionPoint,\n            endPoint,\n          );\n          if (bestMatch) {\n            // if the node to morph is not at the insertion point then remove/move up to it\n            if (bestMatch !== insertionPoint) {\n              removeNodesBetween(ctx, insertionPoint, bestMatch);\n            }\n            morphNode(bestMatch, newChild, ctx);\n            insertionPoint = bestMatch.nextSibling;\n            continue;\n          }\n        }\n\n        // if the matching node is elsewhere in the original content\n        if (newChild instanceof Element && ctx.persistentIds.has(newChild.id)) {\n          // move it and all its children here and morph\n          const movedChild = moveBeforeById(\n            oldParent,\n            newChild.id,\n            insertionPoint,\n            ctx,\n          );\n          morphNode(movedChild, newChild, ctx);\n          insertionPoint = movedChild.nextSibling;\n          continue;\n        }\n\n        // last resort: insert the new node from scratch\n        const insertedNode = createNode(\n          oldParent,\n          newChild,\n          insertionPoint,\n          ctx,\n        );\n        // could be null if beforeNodeAdded prevented insertion\n        if (insertedNode) {\n          insertionPoint = insertedNode.nextSibling;\n        }\n      }\n\n      // remove any remaining old nodes that didn't match up with new content\n      while (insertionPoint && insertionPoint != endPoint) {\n        const tempNode = insertionPoint;\n        insertionPoint = insertionPoint.nextSibling;\n        removeNode(ctx, tempNode);\n      }\n    }\n\n    /**\n     * This performs the action of inserting a new node while handling situations where the node contains\n     * elements with persistent ids and possible state info we can still preserve by moving in and then morphing\n     *\n     * @param {Element} oldParent\n     * @param {Node} newChild\n     * @param {Node|null} insertionPoint\n     * @param {MorphContext} ctx\n     * @returns {Node|null}\n     */\n    function createNode(oldParent, newChild, insertionPoint, ctx) {\n      if (ctx.callbacks.beforeNodeAdded(newChild) === false) return null;\n      if (ctx.idMap.has(newChild)) {\n        // node has children with ids with possible state so create a dummy elt of same type and apply full morph algorithm\n        const newEmptyChild = document.createElement(\n          /** @type {Element} */ (newChild).tagName,\n        );\n        oldParent.insertBefore(newEmptyChild, insertionPoint);\n        morphNode(newEmptyChild, newChild, ctx);\n        ctx.callbacks.afterNodeAdded(newEmptyChild);\n        return newEmptyChild;\n      } else {\n        // optimisation: no id state to preserve so we can just insert a clone of the newChild and its descendants\n        const newClonedChild = document.importNode(newChild, true); // importNode to not mutate newParent\n        oldParent.insertBefore(newClonedChild, insertionPoint);\n        ctx.callbacks.afterNodeAdded(newClonedChild);\n        return newClonedChild;\n      }\n    }\n\n    //=============================================================================\n    // Matching Functions\n    //=============================================================================\n    const findBestMatch = (function () {\n      /**\n       * Scans forward from the startPoint to the endPoint looking for a match\n       * for the node. It looks for an id set match first, then a soft match.\n       * We abort softmatching if we find two future soft matches, to reduce churn.\n       * @param {Node} node\n       * @param {MorphContext} ctx\n       * @param {Node | null} startPoint\n       * @param {Node | null} endPoint\n       * @returns {Node | null}\n       */\n      function findBestMatch(ctx, node, startPoint, endPoint) {\n        let softMatch = null;\n        let nextSibling = node.nextSibling;\n        let siblingSoftMatchCount = 0;\n\n        let cursor = startPoint;\n        while (cursor && cursor != endPoint) {\n          // soft matching is a prerequisite for id set matching\n          if (isSoftMatch(cursor, node)) {\n            if (isIdSetMatch(ctx, cursor, node)) {\n              return cursor; // found an id set match, we're done!\n            }\n\n            // we haven't yet saved a soft match fallback\n            if (softMatch === null) {\n              // the current soft match will hard match something else in the future, leave it\n              if (!ctx.idMap.has(cursor)) {\n                // save this as the fallback if we get through the loop without finding a hard match\n                softMatch = cursor;\n              }\n            }\n          }\n          if (\n            softMatch === null &&\n            nextSibling &&\n            isSoftMatch(cursor, nextSibling)\n          ) {\n            // The next new node has a soft match with this node, so\n            // increment the count of future soft matches\n            siblingSoftMatchCount++;\n            nextSibling = nextSibling.nextSibling;\n\n            // If there are two future soft matches, block soft matching for this node to allow\n            // future siblings to soft match. This is to reduce churn in the DOM when an element\n            // is prepended.\n            if (siblingSoftMatchCount >= 2) {\n              softMatch = undefined;\n            }\n          }\n\n          // if the current node contains active element, stop looking for better future matches,\n          // because if one is found, this node will be moved to the pantry, reparenting it and thus losing focus\n          if (cursor.contains(document.activeElement)) break;\n\n          cursor = cursor.nextSibling;\n        }\n\n        return softMatch || null;\n      }\n\n      /**\n       *\n       * @param {MorphContext} ctx\n       * @param {Node} oldNode\n       * @param {Node} newNode\n       * @returns {boolean}\n       */\n      function isIdSetMatch(ctx, oldNode, newNode) {\n        let oldSet = ctx.idMap.get(oldNode);\n        let newSet = ctx.idMap.get(newNode);\n\n        if (!newSet || !oldSet) return false;\n\n        for (const id of oldSet) {\n          // a potential match is an id in the new and old nodes that\n          // has not already been merged into the DOM\n          // But the newNode content we call this on has not been\n          // merged yet and we don't allow duplicate IDs so it is simple\n          if (newSet.has(id)) {\n            return true;\n          }\n        }\n        return false;\n      }\n\n      /**\n       *\n       * @param {Node} oldNode\n       * @param {Node} newNode\n       * @returns {boolean}\n       */\n      function isSoftMatch(oldNode, newNode) {\n        // ok to cast: if one is not element, `id` and `tagName` will be undefined and we'll just compare that.\n        const oldElt = /** @type {Element} */ (oldNode);\n        const newElt = /** @type {Element} */ (newNode);\n\n        return (\n          oldElt.nodeType === newElt.nodeType &&\n          oldElt.tagName === newElt.tagName &&\n          // If oldElt has an `id` with possible state and it doesn't match newElt.id then avoid morphing.\n          // We'll still match an anonymous node with an IDed newElt, though, because if it got this far,\n          // its not persistent, and new nodes can't have any hidden state.\n          (!oldElt.id || oldElt.id === newElt.id)\n        );\n      }\n\n      return findBestMatch;\n    })();\n\n    //=============================================================================\n    // DOM Manipulation Functions\n    //=============================================================================\n\n    /**\n     * Gets rid of an unwanted DOM node; strategy depends on nature of its reuse:\n     * - Persistent nodes will be moved to the pantry for later reuse\n     * - Other nodes will have their hooks called, and then are removed\n     * @param {MorphContext} ctx\n     * @param {Node} node\n     */\n    function removeNode(ctx, node) {\n      // are we going to id set match this later?\n      if (ctx.idMap.has(node)) {\n        // skip callbacks and move to pantry\n        moveBefore(ctx.pantry, node, null);\n      } else {\n        // remove for realsies\n        if (ctx.callbacks.beforeNodeRemoved(node) === false) return;\n        node.parentNode?.removeChild(node);\n        ctx.callbacks.afterNodeRemoved(node);\n      }\n    }\n\n    /**\n     * Remove nodes between the start and end nodes\n     * @param {MorphContext} ctx\n     * @param {Node} startInclusive\n     * @param {Node} endExclusive\n     * @returns {Node|null}\n     */\n    function removeNodesBetween(ctx, startInclusive, endExclusive) {\n      /** @type {Node | null} */\n      let cursor = startInclusive;\n      // remove nodes until the endExclusive node\n      while (cursor && cursor !== endExclusive) {\n        let tempNode = /** @type {Node} */ (cursor);\n        cursor = cursor.nextSibling;\n        removeNode(ctx, tempNode);\n      }\n      return cursor;\n    }\n\n    /**\n     * Search for an element by id within the document and pantry, and move it using moveBefore.\n     *\n     * @param {Element} parentNode - The parent node to which the element will be moved.\n     * @param {string} id - The ID of the element to be moved.\n     * @param {Node | null} after - The reference node to insert the element before.\n     *                              If `null`, the element is appended as the last child.\n     * @param {MorphContext} ctx\n     * @returns {Element} The found element\n     */\n    function moveBeforeById(parentNode, id, after, ctx) {\n      const target =\n        /** @type {Element} - will always be found */\n        (\n          ctx.target.querySelector(`#${id}`) ||\n            ctx.pantry.querySelector(`#${id}`)\n        );\n      removeElementFromAncestorsIdMaps(target, ctx);\n      moveBefore(parentNode, target, after);\n      return target;\n    }\n\n    /**\n     * Removes an element from its ancestors' id maps. This is needed when an element is moved from the\n     * \"future\" via `moveBeforeId`. Otherwise, its erstwhile ancestors could be mistakenly moved to the\n     * pantry rather than being deleted, preventing their removal hooks from being called.\n     *\n     * @param {Element} element - element to remove from its ancestors' id maps\n     * @param {MorphContext} ctx\n     */\n    function removeElementFromAncestorsIdMaps(element, ctx) {\n      const id = element.id;\n      /** @ts-ignore - safe to loop in this way **/\n      while ((element = element.parentNode)) {\n        let idSet = ctx.idMap.get(element);\n        if (idSet) {\n          idSet.delete(id);\n          if (!idSet.size) {\n            ctx.idMap.delete(element);\n          }\n        }\n      }\n    }\n\n    /**\n     * Moves an element before another element within the same parent.\n     * Uses the proposed `moveBefore` API if available (and working), otherwise falls back to `insertBefore`.\n     * This is essentialy a forward-compat wrapper.\n     *\n     * @param {Element} parentNode - The parent node containing the after element.\n     * @param {Node} element - The element to be moved.\n     * @param {Node | null} after - The reference node to insert `element` before.\n     *                              If `null`, `element` is appended as the last child.\n     */\n    function moveBefore(parentNode, element, after) {\n      // @ts-ignore - use proposed moveBefore feature\n      if (parentNode.moveBefore) {\n        try {\n          // @ts-ignore - use proposed moveBefore feature\n          parentNode.moveBefore(element, after);\n        } catch (e) {\n          // fall back to insertBefore as some browsers may fail on moveBefore when trying to move Dom disconnected nodes to pantry\n          parentNode.insertBefore(element, after);\n        }\n      } else {\n        parentNode.insertBefore(element, after);\n      }\n    }\n\n    return morphChildren;\n  })();\n\n  //=============================================================================\n  // Single Node Morphing Code\n  //=============================================================================\n  const morphNode = (function () {\n    /**\n     * @param {Node} oldNode root node to merge content into\n     * @param {Node} newContent new content to merge\n     * @param {MorphContext} ctx the merge context\n     * @returns {Node | null} the element that ended up in the DOM\n     */\n    function morphNode(oldNode, newContent, ctx) {\n      if (ctx.ignoreActive && oldNode === document.activeElement) {\n        // don't morph focused element\n        return null;\n      }\n\n      if (ctx.callbacks.beforeNodeMorphed(oldNode, newContent) === false) {\n        return oldNode;\n      }\n\n      if (oldNode instanceof HTMLHeadElement && ctx.head.ignore) {\n        // ignore the head element\n      } else if (\n        oldNode instanceof HTMLHeadElement &&\n        ctx.head.style !== \"morph\"\n      ) {\n        // ok to cast: if newContent wasn't also a <head>, it would've got caught in the `!isSoftMatch` branch above\n        handleHeadElement(\n          oldNode,\n          /** @type {HTMLHeadElement} */ (newContent),\n          ctx,\n        );\n      } else {\n        morphAttributes(oldNode, newContent, ctx);\n        if (!ignoreValueOfActiveElement(oldNode, ctx)) {\n          // @ts-ignore newContent can be a node here because .firstChild will be null\n          morphChildren(ctx, oldNode, newContent);\n        }\n      }\n      ctx.callbacks.afterNodeMorphed(oldNode, newContent);\n      return oldNode;\n    }\n\n    /**\n     * syncs the oldNode to the newNode, copying over all attributes and\n     * inner element state from the newNode to the oldNode\n     *\n     * @param {Node} oldNode the node to copy attributes & state to\n     * @param {Node} newNode the node to copy attributes & state from\n     * @param {MorphContext} ctx the merge context\n     */\n    function morphAttributes(oldNode, newNode, ctx) {\n      let type = newNode.nodeType;\n\n      // if is an element type, sync the attributes from the\n      // new node into the new node\n      if (type === 1 /* element type */) {\n        const oldElt = /** @type {Element} */ (oldNode);\n        const newElt = /** @type {Element} */ (newNode);\n\n        const oldAttributes = oldElt.attributes;\n        const newAttributes = newElt.attributes;\n        for (const newAttribute of newAttributes) {\n          if (ignoreAttribute(newAttribute.name, oldElt, \"update\", ctx)) {\n            continue;\n          }\n          if (oldElt.getAttribute(newAttribute.name) !== newAttribute.value) {\n            oldElt.setAttribute(newAttribute.name, newAttribute.value);\n          }\n        }\n        // iterate backwards to avoid skipping over items when a delete occurs\n        for (let i = oldAttributes.length - 1; 0 <= i; i--) {\n          const oldAttribute = oldAttributes[i];\n\n          // toAttributes is a live NamedNodeMap, so iteration+mutation is unsafe\n          // e.g. custom element attribute callbacks can remove other attributes\n          if (!oldAttribute) continue;\n\n          if (!newElt.hasAttribute(oldAttribute.name)) {\n            if (ignoreAttribute(oldAttribute.name, oldElt, \"remove\", ctx)) {\n              continue;\n            }\n            oldElt.removeAttribute(oldAttribute.name);\n          }\n        }\n\n        if (!ignoreValueOfActiveElement(oldElt, ctx)) {\n          syncInputValue(oldElt, newElt, ctx);\n        }\n      }\n\n      // sync text nodes\n      if (type === 8 /* comment */ || type === 3 /* text */) {\n        if (oldNode.nodeValue !== newNode.nodeValue) {\n          oldNode.nodeValue = newNode.nodeValue;\n        }\n      }\n    }\n\n    /**\n     * NB: many bothans died to bring us information:\n     *\n     *  https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n     *  https://github.com/choojs/nanomorph/blob/master/lib/morph.jsL113\n     *\n     * @param {Element} oldElement the element to sync the input value to\n     * @param {Element} newElement the element to sync the input value from\n     * @param {MorphContext} ctx the merge context\n     */\n    function syncInputValue(oldElement, newElement, ctx) {\n      if (\n        oldElement instanceof HTMLInputElement &&\n        newElement instanceof HTMLInputElement &&\n        newElement.type !== \"file\"\n      ) {\n        let newValue = newElement.value;\n        let oldValue = oldElement.value;\n\n        // sync boolean attributes\n        syncBooleanAttribute(oldElement, newElement, \"checked\", ctx);\n        syncBooleanAttribute(oldElement, newElement, \"disabled\", ctx);\n\n        if (!newElement.hasAttribute(\"value\")) {\n          if (!ignoreAttribute(\"value\", oldElement, \"remove\", ctx)) {\n            oldElement.value = \"\";\n            oldElement.removeAttribute(\"value\");\n          }\n        } else if (oldValue !== newValue) {\n          if (!ignoreAttribute(\"value\", oldElement, \"update\", ctx)) {\n            oldElement.setAttribute(\"value\", newValue);\n            oldElement.value = newValue;\n          }\n        }\n        // TODO: QUESTION(1cg): this used to only check `newElement` unlike the other branches -- why?\n        // did I break something?\n      } else if (\n        oldElement instanceof HTMLOptionElement &&\n        newElement instanceof HTMLOptionElement\n      ) {\n        syncBooleanAttribute(oldElement, newElement, \"selected\", ctx);\n      } else if (\n        oldElement instanceof HTMLTextAreaElement &&\n        newElement instanceof HTMLTextAreaElement\n      ) {\n        let newValue = newElement.value;\n        let oldValue = oldElement.value;\n        if (ignoreAttribute(\"value\", oldElement, \"update\", ctx)) {\n          return;\n        }\n        if (newValue !== oldValue) {\n          oldElement.value = newValue;\n        }\n        if (\n          oldElement.firstChild &&\n          oldElement.firstChild.nodeValue !== newValue\n        ) {\n          oldElement.firstChild.nodeValue = newValue;\n        }\n      }\n    }\n\n    /**\n     * @param {Element} oldElement element to write the value to\n     * @param {Element} newElement element to read the value from\n     * @param {string} attributeName the attribute name\n     * @param {MorphContext} ctx the merge context\n     */\n    function syncBooleanAttribute(oldElement, newElement, attributeName, ctx) {\n      // @ts-ignore this function is only used on boolean attrs that are reflected as dom properties\n      const newLiveValue = newElement[attributeName],\n        // @ts-ignore ditto\n        oldLiveValue = oldElement[attributeName];\n      if (newLiveValue !== oldLiveValue) {\n        const ignoreUpdate = ignoreAttribute(\n          attributeName,\n          oldElement,\n          \"update\",\n          ctx,\n        );\n        if (!ignoreUpdate) {\n          // update attribute's associated DOM property\n          // @ts-ignore this function is only used on boolean attrs that are reflected as dom properties\n          oldElement[attributeName] = newElement[attributeName];\n        }\n        if (newLiveValue) {\n          if (!ignoreUpdate) {\n            // https://developer.mozilla.org/en-US/docs/Glossary/Boolean/HTML\n            // this is the correct way to set a boolean attribute to \"true\"\n            oldElement.setAttribute(attributeName, \"\");\n          }\n        } else {\n          if (!ignoreAttribute(attributeName, oldElement, \"remove\", ctx)) {\n            oldElement.removeAttribute(attributeName);\n          }\n        }\n      }\n    }\n\n    /**\n     * @param {string} attr the attribute to be mutated\n     * @param {Element} element the element that is going to be updated\n     * @param {\"update\" | \"remove\"} updateType\n     * @param {MorphContext} ctx the merge context\n     * @returns {boolean} true if the attribute should be ignored, false otherwise\n     */\n    function ignoreAttribute(attr, element, updateType, ctx) {\n      if (\n        attr === \"value\" &&\n        ctx.ignoreActiveValue &&\n        element === document.activeElement\n      ) {\n        return true;\n      }\n      return (\n        ctx.callbacks.beforeAttributeUpdated(attr, element, updateType) ===\n        false\n      );\n    }\n\n    /**\n     * @param {Node} possibleActiveElement\n     * @param {MorphContext} ctx\n     * @returns {boolean}\n     */\n    function ignoreValueOfActiveElement(possibleActiveElement, ctx) {\n      return (\n        !!ctx.ignoreActiveValue &&\n        possibleActiveElement === document.activeElement &&\n        possibleActiveElement !== document.body\n      );\n    }\n\n    return morphNode;\n  })();\n\n  //=============================================================================\n  // Head Management Functions\n  //=============================================================================\n  /**\n   * @param {MorphContext} ctx\n   * @param {Element} oldNode\n   * @param {Element} newNode\n   * @param {function} callback\n   * @returns {Node[] | Promise<Node[]>}\n   */\n  function withHeadBlocking(ctx, oldNode, newNode, callback) {\n    if (ctx.head.block) {\n      const oldHead = oldNode.querySelector(\"head\");\n      const newHead = newNode.querySelector(\"head\");\n      if (oldHead && newHead) {\n        const promises = handleHeadElement(oldHead, newHead, ctx);\n        // when head promises resolve, proceed ignoring the head tag\n        return Promise.all(promises).then(() => {\n          const newCtx = Object.assign(ctx, {\n            head: {\n              block: false,\n              ignore: true,\n            },\n          });\n          return callback(newCtx);\n        });\n      }\n    }\n    // just proceed if we not head blocking\n    return callback(ctx);\n  }\n\n  /**\n   *  The HEAD tag can be handled specially, either w/ a 'merge' or 'append' style\n   *\n   * @param {Element} oldHead\n   * @param {Element} newHead\n   * @param {MorphContext} ctx\n   * @returns {Promise<void>[]}\n   */\n  function handleHeadElement(oldHead, newHead, ctx) {\n    let added = [];\n    let removed = [];\n    let preserved = [];\n    let nodesToAppend = [];\n\n    // put all new head elements into a Map, by their outerHTML\n    let srcToNewHeadNodes = new Map();\n    for (const newHeadChild of newHead.children) {\n      srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild);\n    }\n\n    // for each elt in the current head\n    for (const currentHeadElt of oldHead.children) {\n      // If the current head element is in the map\n      let inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML);\n      let isReAppended = ctx.head.shouldReAppend(currentHeadElt);\n      let isPreserved = ctx.head.shouldPreserve(currentHeadElt);\n      if (inNewContent || isPreserved) {\n        if (isReAppended) {\n          // remove the current version and let the new version replace it and re-execute\n          removed.push(currentHeadElt);\n        } else {\n          // this element already exists and should not be re-appended, so remove it from\n          // the new content map, preserving it in the DOM\n          srcToNewHeadNodes.delete(currentHeadElt.outerHTML);\n          preserved.push(currentHeadElt);\n        }\n      } else {\n        if (ctx.head.style === \"append\") {\n          // we are appending and this existing element is not new content\n          // so if and only if it is marked for re-append do we do anything\n          if (isReAppended) {\n            removed.push(currentHeadElt);\n            nodesToAppend.push(currentHeadElt);\n          }\n        } else {\n          // if this is a merge, we remove this content since it is not in the new head\n          if (ctx.head.shouldRemove(currentHeadElt) !== false) {\n            removed.push(currentHeadElt);\n          }\n        }\n      }\n    }\n\n    // Push the remaining new head elements in the Map into the\n    // nodes to append to the head tag\n    nodesToAppend.push(...srcToNewHeadNodes.values());\n\n    let promises = [];\n    for (const newNode of nodesToAppend) {\n      // TODO: This could theoretically be null, based on type\n      let newElt = /** @type {ChildNode} */ (\n        document.createRange().createContextualFragment(newNode.outerHTML)\n          .firstChild\n      );\n      if (ctx.callbacks.beforeNodeAdded(newElt) !== false) {\n        if (\n          (\"href\" in newElt && newElt.href) ||\n          (\"src\" in newElt && newElt.src)\n        ) {\n          /** @type {(result?: any) => void} */ let resolve;\n          let promise = new Promise(function (_resolve) {\n            resolve = _resolve;\n          });\n          newElt.addEventListener(\"load\", function () {\n            resolve();\n          });\n          promises.push(promise);\n        }\n        oldHead.appendChild(newElt);\n        ctx.callbacks.afterNodeAdded(newElt);\n        added.push(newElt);\n      }\n    }\n\n    // remove all removed elements, after we have appended the new elements to avoid\n    // additional network requests for things like style sheets\n    for (const removedElement of removed) {\n      if (ctx.callbacks.beforeNodeRemoved(removedElement) !== false) {\n        oldHead.removeChild(removedElement);\n        ctx.callbacks.afterNodeRemoved(removedElement);\n      }\n    }\n\n    ctx.head.afterHeadMorphed(oldHead, {\n      added: added,\n      kept: preserved,\n      removed: removed,\n    });\n    return promises;\n  }\n\n  //=============================================================================\n  // Create Morph Context Functions\n  //=============================================================================\n  const createMorphContext = (function () {\n    /**\n     *\n     * @param {Element} oldNode\n     * @param {Element} newContent\n     * @param {Config} config\n     * @returns {MorphContext}\n     */\n    function createMorphContext(oldNode, newContent, config) {\n      const { persistentIds, idMap } = createIdMaps(oldNode, newContent);\n\n      const mergedConfig = mergeDefaults(config);\n      const morphStyle = mergedConfig.morphStyle || \"outerHTML\";\n      if (![\"innerHTML\", \"outerHTML\"].includes(morphStyle)) {\n        throw `Do not understand how to morph style ${morphStyle}`;\n      }\n\n      return {\n        target: oldNode,\n        newContent: newContent,\n        config: mergedConfig,\n        morphStyle: morphStyle,\n        ignoreActive: mergedConfig.ignoreActive,\n        ignoreActiveValue: mergedConfig.ignoreActiveValue,\n        restoreFocus: mergedConfig.restoreFocus,\n        idMap: idMap,\n        persistentIds: persistentIds,\n        pantry: createPantry(),\n        callbacks: mergedConfig.callbacks,\n        head: mergedConfig.head,\n      };\n    }\n\n    /**\n     * Deep merges the config object and the Idiomorph.defaults object to\n     * produce a final configuration object\n     * @param {Config} config\n     * @returns {ConfigInternal}\n     */\n    function mergeDefaults(config) {\n      let finalConfig = Object.assign({}, defaults);\n\n      // copy top level stuff into final config\n      Object.assign(finalConfig, config);\n\n      // copy callbacks into final config (do this to deep merge the callbacks)\n      finalConfig.callbacks = Object.assign(\n        {},\n        defaults.callbacks,\n        config.callbacks,\n      );\n\n      // copy head config into final config  (do this to deep merge the head)\n      finalConfig.head = Object.assign({}, defaults.head, config.head);\n\n      return finalConfig;\n    }\n\n    /**\n     * @returns {HTMLDivElement}\n     */\n    function createPantry() {\n      const pantry = document.createElement(\"div\");\n      pantry.hidden = true;\n      document.body.insertAdjacentElement(\"afterend\", pantry);\n      return pantry;\n    }\n\n    /**\n     * Returns all elements with an ID contained within the root element and its descendants\n     *\n     * @param {Element} root\n     * @returns {Element[]}\n     */\n    function findIdElements(root) {\n      let elements = Array.from(root.querySelectorAll(\"[id]\"));\n      if (root.id) {\n        elements.push(root);\n      }\n      return elements;\n    }\n\n    /**\n     * A bottom-up algorithm that populates a map of Element -> IdSet.\n     * The idSet for a given element is the set of all IDs contained within its subtree.\n     * As an optimzation, we filter these IDs through the given list of persistent IDs,\n     * because we don't need to bother considering IDed elements that won't be in the new content.\n     *\n     * @param {Map<Node, Set<string>>} idMap\n     * @param {Set<string>} persistentIds\n     * @param {Element} root\n     * @param {Element[]} elements\n     */\n    function populateIdMapWithTree(idMap, persistentIds, root, elements) {\n      for (const elt of elements) {\n        if (persistentIds.has(elt.id)) {\n          /** @type {Element|null} */\n          let current = elt;\n          // walk up the parent hierarchy of that element, adding the id\n          // of element to the parent's id set\n          while (current) {\n            let idSet = idMap.get(current);\n            // if the id set doesn't exist, create it and insert it in the map\n            if (idSet == null) {\n              idSet = new Set();\n              idMap.set(current, idSet);\n            }\n            idSet.add(elt.id);\n\n            if (current === root) break;\n            current = current.parentElement;\n          }\n        }\n      }\n    }\n\n    /**\n     * This function computes a map of nodes to all ids contained within that node (inclusive of the\n     * node).  This map can be used to ask if two nodes have intersecting sets of ids, which allows\n     * for a looser definition of \"matching\" than tradition id matching, and allows child nodes\n     * to contribute to a parent nodes matching.\n     *\n     * @param {Element} oldContent  the old content that will be morphed\n     * @param {Element} newContent  the new content to morph to\n     * @returns {IdSets}\n     */\n    function createIdMaps(oldContent, newContent) {\n      const oldIdElements = findIdElements(oldContent);\n      const newIdElements = findIdElements(newContent);\n\n      const persistentIds = createPersistentIds(oldIdElements, newIdElements);\n\n      /** @type {Map<Node, Set<string>>} */\n      let idMap = new Map();\n      populateIdMapWithTree(idMap, persistentIds, oldContent, oldIdElements);\n\n      /** @ts-ignore - if newContent is a duck-typed parent, pass its single child node as the root to halt upwards iteration */\n      const newRoot = newContent.__idiomorphRoot || newContent;\n      populateIdMapWithTree(idMap, persistentIds, newRoot, newIdElements);\n\n      return { persistentIds, idMap };\n    }\n\n    /**\n     * This function computes the set of ids that persist between the two contents excluding duplicates\n     *\n     * @param {Element[]} oldIdElements\n     * @param {Element[]} newIdElements\n     * @returns {Set<string>}\n     */\n    function createPersistentIds(oldIdElements, newIdElements) {\n      let duplicateIds = new Set();\n\n      /** @type {Map<string, string>} */\n      let oldIdTagNameMap = new Map();\n      for (const { id, tagName } of oldIdElements) {\n        if (oldIdTagNameMap.has(id)) {\n          duplicateIds.add(id);\n        } else {\n          oldIdTagNameMap.set(id, tagName);\n        }\n      }\n\n      let persistentIds = new Set();\n      for (const { id, tagName } of newIdElements) {\n        if (persistentIds.has(id)) {\n          duplicateIds.add(id);\n        } else if (oldIdTagNameMap.get(id) === tagName) {\n          persistentIds.add(id);\n        }\n        // skip if tag types mismatch because its not possible to morph one tag into another\n      }\n\n      for (const id of duplicateIds) {\n        persistentIds.delete(id);\n      }\n      return persistentIds;\n    }\n\n    return createMorphContext;\n  })();\n\n  //=============================================================================\n  // HTML Normalization Functions\n  //=============================================================================\n  const { normalizeElement, normalizeParent } = (function () {\n    /** @type {WeakSet<Node>} */\n    const generatedByIdiomorph = new WeakSet();\n\n    /**\n     *\n     * @param {Element | Document} content\n     * @returns {Element}\n     */\n    function normalizeElement(content) {\n      if (content instanceof Document) {\n        return content.documentElement;\n      } else {\n        return content;\n      }\n    }\n\n    /**\n     *\n     * @param {null | string | Node | HTMLCollection | Node[] | Document & {generatedByIdiomorph:boolean}} newContent\n     * @returns {Element}\n     */\n    function normalizeParent(newContent) {\n      if (newContent == null) {\n        return document.createElement(\"div\"); // dummy parent element\n      } else if (typeof newContent === \"string\") {\n        return normalizeParent(parseContent(newContent));\n      } else if (\n        generatedByIdiomorph.has(/** @type {Element} */ (newContent))\n      ) {\n        // the template tag created by idiomorph parsing can serve as a dummy parent\n        return /** @type {Element} */ (newContent);\n      } else if (newContent instanceof Node) {\n        if (newContent.parentNode) {\n          // we can't use the parent directly because newContent may have siblings\n          // that we don't want in the morph, and reparenting might be expensive (TODO is it?),\n          // so we create a duck-typed parent node instead.\n          return createDuckTypedParent(newContent);\n        } else {\n          // a single node is added as a child to a dummy parent\n          const dummyParent = document.createElement(\"div\");\n          dummyParent.append(newContent);\n          return dummyParent;\n        }\n      } else {\n        // all nodes in the array or HTMLElement collection are consolidated under\n        // a single dummy parent element\n        const dummyParent = document.createElement(\"div\");\n        for (const elt of [...newContent]) {\n          dummyParent.append(elt);\n        }\n        return dummyParent;\n      }\n    }\n\n    /**\n     * Creates a fake duck-typed parent element to wrap a single node, without actually reparenting it.\n     * \"If it walks like a duck, and quacks like a duck, then it must be a duck!\" -- James Whitcomb Riley (1849â€“1916)\n     *\n     * @param {Node} newContent\n     * @returns {Element}\n     */\n    function createDuckTypedParent(newContent) {\n      return /** @type {Element} */ (\n        /** @type {unknown} */ ({\n          childNodes: [newContent],\n          /** @ts-ignore - cover your eyes for a minute, tsc */\n          querySelectorAll: (s) => {\n            /** @ts-ignore */\n            const elements = newContent.querySelectorAll(s);\n            /** @ts-ignore */\n            return newContent.matches(s) ? [newContent, ...elements] : elements;\n          },\n          /** @ts-ignore */\n          insertBefore: (n, r) => newContent.parentNode.insertBefore(n, r),\n          /** @ts-ignore */\n          moveBefore: (n, r) => newContent.parentNode.moveBefore(n, r),\n          // for later use with populateIdMapWithTree to halt upwards iteration\n          get __idiomorphRoot() {\n            return newContent;\n          },\n        })\n      );\n    }\n\n    /**\n     *\n     * @param {string} newContent\n     * @returns {Node | null | DocumentFragment}\n     */\n    function parseContent(newContent) {\n      let parser = new DOMParser();\n\n      // remove svgs to avoid false-positive matches on head, etc.\n      let contentWithSvgsRemoved = newContent.replace(\n        /<svg(\\s[^>]*>|>)([\\s\\S]*?)<\\/svg>/gim,\n        \"\",\n      );\n\n      // if the newContent contains a html, head or body tag, we can simply parse it w/o wrapping\n      if (\n        contentWithSvgsRemoved.match(/<\\/html>/) ||\n        contentWithSvgsRemoved.match(/<\\/head>/) ||\n        contentWithSvgsRemoved.match(/<\\/body>/)\n      ) {\n        let content = parser.parseFromString(newContent, \"text/html\");\n        // if it is a full HTML document, return the document itself as the parent container\n        if (contentWithSvgsRemoved.match(/<\\/html>/)) {\n          generatedByIdiomorph.add(content);\n          return content;\n        } else {\n          // otherwise return the html element as the parent container\n          let htmlElement = content.firstChild;\n          if (htmlElement) {\n            generatedByIdiomorph.add(htmlElement);\n          }\n          return htmlElement;\n        }\n      } else {\n        // if it is partial HTML, wrap it in a template tag to provide a parent element and also to help\n        // deal with touchy tags like tr, tbody, etc.\n        let responseDoc = parser.parseFromString(\n          \"<body><template>\" + newContent + \"</template></body>\",\n          \"text/html\",\n        );\n        let content = /** @type {HTMLTemplateElement} */ (\n          responseDoc.body.querySelector(\"template\")\n        ).content;\n        generatedByIdiomorph.add(content);\n        return content;\n      }\n    }\n\n    return { normalizeElement, normalizeParent };\n  })();\n\n  //=============================================================================\n  // This is what ends up becoming the Idiomorph global object\n  //=============================================================================\n  return {\n    morph,\n    defaults,\n  };\n})();\n\nexport {Idiomorph};\n","\nconst topics: any = {}\nconst _async: any = {}\n\nexport const publish = (name, params) => {\n\t_async[name] = Object.assign({}, _async[name], params)\n\tif (topics[name])\n\t\ttopics[name].forEach(topic => topic(params))\n}\n\nexport const subscribe = (name, method) => {\n\ttopics[name] = topics[name] || []\n\ttopics[name].push(method)\n\tif (name in _async) {\n\t\tmethod(_async[name])\n\t}\n\treturn () => {\n\t\ttopics[name] = topics[name].filter( fn => fn != method )\n\t}\n}\n","import { safe, g, dup } from './utils'\nimport { Idiomorph } from 'idiomorph/dist/idiomorph.esm'\nimport { publish, subscribe } from './utils/pubsub'\n\nexport const Component = ({ name, module, dependencies, node, templates, signal, register }) => {\n\n\tlet tick\n\tlet preserve\t\t= []\n\n\tconst _model \t\t= module.model || {}\n\tconst initialState \t= (new Function( `return ${node.getAttribute('html-model') || '{}'}`))()\n\tconst tplid \t\t= node.getAttribute('tplid')\n\tconst scopeid \t\t= node.getAttribute('html-scopeid')\n\tconst tpl \t\t\t= templates[ tplid ]\n\tconst scope \t\t= g.scope[ scopeid ]\n\tconst model  \t\t= dup(module?.model?.apply ? _model({ elm:node, initialState }) : _model)\n\tconst state \t\t= Object.assign({}, scope, model, initialState)\n\tconst view \t\t\t= module.view? module.view : (data) => data\n\n\tconst base = {\n\t\tname,\n\t\tmodel,\n\t\telm: node,\n\t\ttemplate: tpl.template,\n\t\tdependencies,\n\t\tpublish,\n\t\tsubscribe,\n\n\t\tmain(fn) {\n\t\t\tnode.addEventListener(':mount', fn)\n\t\t},\n\n\t\t/**\n\t\t * @State\n\t\t */\n\t\tstate : {\n\n\t\t\tprotected( list ) {\n\t\t\t\tif( list ) {\n\t\t\t\t\tpreserve = list\n\t\t\t\t} else {\n\t\t\t\t\treturn preserve\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tsave(data) {\n\t\t\t\tif( data.constructor === Function ) {\n\t\t\t\t\tdata( state )\n\t\t\t\t} else {\n\t\t\t\t\tObject.assign(state, data)\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tset( data ) {\n\n\t\t\t\tif (!document.body.contains(node)) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif( data.constructor === Function ) {\n\t\t\t\t\tdata(state)\n\t\t\t\t} else {\n\t\t\t\t\tObject.assign(state, data)\n\t\t\t\t}\n\n\t\t\t\tconst newstate = Object.assign({}, state, scope)\n\n\t\t\t\treturn new Promise((resolve) => {\n\t\t\t\t\trender(newstate, () => resolve(newstate))\n\t\t\t\t})\n\t\t\t},\n\n\t\t\tget() {\n\t\t\t\treturn Object.assign({}, state)\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * @Events\n\t\t */\n\t\ton( ev, selectorOrCallback, callback ) {\n\n\t\t\tif( callback ) {\n\t\t\t\tcallback.handler = (e) => {\n\t\t\t\t\tconst detail = e.detail || {}\n\t\t\t\t\tlet parent = e.target\n\t\t\t\t\twhile (parent) {\n\t\t\t\t\t\tif (parent.matches(selectorOrCallback)) {\n\t\t\t\t\t\t\te.delegateTarget = parent\n\t\t\t\t\t\t\tcallback.apply(node, [e].concat(detail.args))\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (parent === node) break\n\t\t\t\t\t\tparent = parent.parentNode\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnode.addEventListener(ev, callback.handler, {\n\t\t\t\t\tsignal,\n\t\t\t\t\tcapture: (ev == 'focus' || ev == 'blur' || ev == 'mouseenter' || ev == 'mouseleave')\n\t\t\t\t})\n\n\t\t\t} else {\n\t\t\t\tselectorOrCallback.handler = (e) => {\n\t\t\t\t\te.delegateTarget = node\n\t\t\t\t\tselectorOrCallback.apply(node, [e].concat(e.detail.args))\n\t\t\t\t}\n\t\t\t\tnode.addEventListener(ev, selectorOrCallback.handler, { signal })\n\t\t\t}\n\n\t\t},\n\n\t\toff( ev, callback ) {\n\t\t\tif( callback.handler ) {\n\t\t\t\tnode.removeEventListener(ev, callback.handler)\n\t\t\t}\n\t\t},\n\n\t\ttrigger(ev, selectorOrCallback, data) {\n\t\t\tif( selectorOrCallback.constructor === String ) {\n\t\t\t\tArray\n\t\t\t\t\t.from(node.querySelectorAll(selectorOrCallback))\n\t\t\t\t\t.forEach( children => {\n\t\t\t\t\t\tchildren.dispatchEvent(new CustomEvent(ev, { bubbles: true, detail: { args: data } }) )\n\t\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tnode.dispatchEvent(new CustomEvent(ev, { bubbles: true, detail:{ args: data } }))\n\t\t\t}\n\t\t},\n\n\t\temit(ev, data) {\n\t\t\tnode.dispatchEvent(new CustomEvent(ev, { bubbles: true, detail: { args: data } }))\n\t\t},\n\n\t\tunmount( fn ) {\n\t\t\tnode.addEventListener(':unmount', fn)\n\t\t},\n\n\t\tinnerHTML ( target, html_ ) {\n\t\t\tconst element = html_? target : node\n\t\t\tconst clone = element.cloneNode()\n\t\t\tconst html = html_? html_ : target\n\t\t\tclone.innerHTML = html\n\t\t\tIdiomorph.morph(element, clone)\n\t\t}\n\t}\n\n\tconst render = ( data, callback = (() => {}) ) => {\n\t\tclearTimeout( tick )\n\t\ttick = setTimeout(() => {\n\t\t\tconst html = tpl.render.call( view(data), node, safe, g )\n\t\t\tIdiomorph.morph( node, html, IdiomorphOptions(node, register) )\n\t\t\tPromise.resolve().then(() => {\n\t\t\t\tnode.querySelectorAll('[tplid]')\n\t\t\t\t\t.forEach((element) => {\n\t\t\t\t\t\tconst child = register.get(element)\n\t\t\t\t\t\tif(!child) return\n\t\t\t\t\t\tchild.state.protected().forEach( key => delete data[key] )\n\t\t\t\t\t\tchild.state.set(data)\n\t\t\t\t\t})\n\t\t\t\tPromise.resolve().then(() => {\n\t\t\t\t\tg.scope = {}\n\t\t\t\t\tcallback()\n\t\t\t\t})\n\t\t\t})\n\t\t})\n\t}\n\n\trender( state )\n\tregister.set( node, base )\n\treturn module.default( base )\n}\n\nconst IdiomorphOptions = ( parent, register ) => ({\n\tcallbacks: {\n\t\tbeforeNodeMorphed( node ) {\n\t\t\tif( node.nodeType === 1 ) {\n\t\t\t\tif( 'html-static' in node.attributes ) {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\tif( register.get(node) && node !== parent ) {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n})\n","import { Component } from './component'\n\nconst register = new WeakMap()\n\nexport const Element = ({ component, templates, start }) => {\n\n\tconst { name, module, dependencies } = component\n\n\treturn class extends HTMLElement {\n\n\t\tconstructor() {\n\t\t\tsuper()\n\t\t}\n\n\t\tconnectedCallback() {\n\n\t\t\tthis.abortController = new AbortController()\n\n\t\t\tif( !this.getAttribute('tplid') ) {\n\t\t\t\tstart( this.parentNode )\n\t\t\t}\n\n\t\t\tconst rtrn = Component({\n\t\t\t\tnode:this,\n\t\t\t\tname,\n\t\t\t\tmodule,\n\t\t\t\tdependencies,\n\t\t\t\ttemplates,\n\t\t\t\tsignal: this.abortController.signal,\n\t\t\t\tregister\n\t\t\t})\n\n\t\t\tif ( rtrn && rtrn.constructor === Promise ) {\n\t\t\t\trtrn.then(() => {\n\t\t\t\t\tthis.dispatchEvent( new CustomEvent(':mount') )\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tthis.dispatchEvent( new CustomEvent(':mount') )\n\t\t\t}\n\t\t}\n\n\t\tdisconnectedCallback() {\n\t\t\tthis.dispatchEvent( new CustomEvent(':unmount') )\n\t\t\tthis.abortController.abort()\n\t\t}\n\t}\n}\n","import { uuid, decodeHTML } from './utils'\n\nconst templates  = {}\n\nconst config = {\n\ttags: ['{{', '}}']\n}\n\nexport const templateConfig = (newconfig) => {\n\tObject.assign( config, newconfig )\n}\n\nexport const template = ( target, { components }) => {\n\n\ttagElements( target, [...Object.keys( components ), '[html-if]', 'template'], components )\n\tconst clone = target.cloneNode( true )\n\n\ttransformTemplate( clone )\n\tremoveTemplateTagsRecursively( clone )\n\tsetTemplates( clone, components )\n\n\treturn templates\n}\n\nexport const compile = ( html ) => {\n\n\tconst parsedHtml = JSON.stringify( html )\n\n\treturn new Function('$element', 'safe', '$g',`\n\t\tvar $data = this;\n\t\twith( $data ){\n\t\t\tvar output=${parsedHtml\n\t\t\t\t.replace(/%%_=(.+?)_%%/g, function(_, variable){\n\t\t\t\t\treturn '\"+safe(function(){return '+ decodeHTML(variable) +';})+\"'\n\t\t\t\t})\n\t\t\t\t.replace(/%%_(.+?)_%%/g, function(_, variable){\n\t\t\t\t\treturn '\";' + decodeHTML(variable) +'\\noutput+=\"'\n\t\t\t\t})};return output;\n\t\t}\n\t`)\n}\n\nconst tagElements = ( target, keys, components ) => {\n\ttarget\n\t\t.querySelectorAll( keys.toString() )\n\t\t.forEach((node) => {\n\t\t\tconst name = node.localName\n\t\t\tif( name === 'template' ) {\n\t\t\t\treturn tagElements( node.content, keys, components )\n\t\t\t}\n\t\t\tif( node.getAttribute('html-if') && !node.id ) {\n\t\t\t\tnode.id = uuid()\n\t\t\t}\n\t\t\tif( name in components ) {\n\t\t\t\tnode.setAttribute('tplid', uuid())\n\t\t\t}\n\t\t})\n}\n\nconst transformAttributes = ( html ) => {\n\n\tconst regexTags = new RegExp(`\\\\${config.tags[0]}(.+?)\\\\${config.tags[1]}`, 'g')\n\n\treturn html\n\t\t.replace(/jails___scope-id/g, '%%_=$scopeid_%%')\n\t\t.replace(regexTags, '%%_=$1_%%')\n\t\t// Booleans\n\t\t// https://meiert.com/en/blog/boolean-attributes-of-html/\n\t\t.replace(/html-(allowfullscreen|async|autofocus|autoplay|checked|controls|default|defer|disabled|formnovalidate|inert|ismap|itemscope|loop|multiple|muted|nomodule|novalidate|open|playsinline|readonly|required|reversed|selected)=\\\"(.*?)\\\"/g, `%%_if(safe(function(){ return $2 })){_%%$1%%_}_%%`)\n\t\t// The rest\n\t\t.replace(/html-(.*?)=\\\"(.*?)\\\"/g, (all, key, value) => {\n\t\t\tif (key === 'key' || key === 'model' || key === 'scopeid' ) {\n\t\t\t\treturn all\n\t\t\t}\n\t\t\tif (value) {\n\t\t\t\tvalue = value.replace(/^{|}$/g, '')\n\t\t\t\treturn `${key}=\"%%_=safe(function(){ return ${value} })_%%\"`\n\t\t\t} else {\n\t\t\t\treturn all\n\t\t\t}\n\t\t})\n}\n\nconst transformTemplate = ( clone ) => {\n\n\tclone.querySelectorAll('template, [html-for], [html-if], [html-inner], [html-class]')\n\t\t.forEach(( element ) => {\n\n\t\t\tconst htmlFor \t= element.getAttribute('html-for')\n\t\t\tconst htmlIf \t= element.getAttribute('html-if')\n\t\t\tconst htmlInner = element.getAttribute('html-inner')\n\t\t\tconst htmlClass = element.getAttribute('html-class')\n\n\t\t\tif ( htmlFor ) {\n\n\t\t\t\telement.removeAttribute('html-for')\n\n\t\t\t\tconst split \t = htmlFor.match(/(.*)\\sin\\s(.*)/) || ''\n\t\t\t\tconst varname \t = split[1]\n\t\t\t\tconst object \t = split[2]\n\t\t\t\tconst objectname = object.split(/\\./).shift()\n\t\t\t\tconst open \t\t = document.createTextNode(`%%_ ;(function(){ var $index = 0; for(var $key in safe(function(){ return ${object} }) ){ var $scopeid = Math.random().toString(36).substring(2, 9); var ${varname} = ${object}[$key]; $g.scope[$scopeid] = Object.assign({}, { ${objectname}: ${objectname} }, { ${varname} :${varname}, $index: $index, $key: $key }); _%%`)\n\t\t\t\tconst close \t = document.createTextNode(`%%_ $index++; } })() _%%`)\n\n\t\t\t\twrap(open, element, close)\n\t\t\t}\n\n\t\t\tif (htmlIf) {\n\t\t\t\telement.removeAttribute('html-if')\n\t\t\t\tconst open = document.createTextNode(`%%_ if ( safe(function(){ return ${htmlIf} }) ){ _%%`)\n\t\t\t\tconst close = document.createTextNode(`%%_ }  _%%`)\n\t\t\t\twrap(open, element, close)\n\t\t\t}\n\n\t\t\tif (htmlInner) {\n\t\t\t\telement.removeAttribute('html-inner')\n\t\t\t\telement.innerHTML = `%%_=${htmlInner}_%%`\n\t\t\t}\n\n\t\t\tif (htmlClass) {\n\t\t\t\telement.removeAttribute('html-class')\n\t\t\t\telement.className = (element.className + ` %%_=${htmlClass}_%%`).trim()\n\t\t\t}\n\n\t\t\tif( element.localName === 'template' ) {\n\t\t\t\ttransformTemplate(element.content)\n\t\t\t}\n\t\t})\n}\n\nconst setTemplates = ( clone, components ) => {\n\n\tArray.from(clone.querySelectorAll('[tplid]'))\n\t\t.reverse()\n\t\t.forEach((node) => {\n\n\t\t\tconst tplid = node.getAttribute('tplid')\n\t\t\tconst name  = node.localName\n\t\t\tnode.setAttribute('html-scopeid', 'jails___scope-id')\n\n\t\t\tif( name in components && components[name].module.template ) {\n\t\t\t\tconst children = node.innerHTML\n\t\t\t\tconst html = components[name].module.template({ elm:node, children })\n\t\t\t\tnode.innerHTML = html\n\t\t\t}\n\n\t\t\tconst html = transformAttributes(node.outerHTML)\n\n\t\t\ttemplates[ tplid ] = {\n\t\t\t\ttemplate: html,\n\t\t\t\trender\t: compile(html)\n\t\t\t}\n\t\t})\n}\n\nconst removeTemplateTagsRecursively = (node) => {\n\n\t// Get all <template> elements within the node\n\tconst templates = node.querySelectorAll('template')\n\n\ttemplates.forEach((template) => {\n\n\t\tif( template.getAttribute('html-if') || template.getAttribute('html-inner') ) {\n\t\t\treturn\n\t\t}\n\n\t\t// Process any nested <template> tags within this <template> first\n\t\tremoveTemplateTagsRecursively(template.content)\n\n\t\t// Get the parent of the <template> tag\n\t\tconst parent = template.parentNode\n\n\t\tif (parent) {\n\t\t\t// Move all child nodes from the <template>'s content to its parent\n\t\t\tconst content = template.content\n\t\t\twhile (content.firstChild) {\n\t\t\t\tparent.insertBefore(content.firstChild, template)\n\t\t\t}\n\t\t\t// Remove the <template> tag itself\n\t\t\tparent.removeChild(template)\n\t\t}\n\t})\n}\n\nconst wrap = (open, node, close) => {\n\tnode.parentNode?.insertBefore(open, node)\n\tnode.parentNode?.insertBefore(close, node.nextSibling)\n}\n","\nimport { Element } from './element'\nimport { template, templateConfig as config } from './template-system'\n\nexport { publish, subscribe } from './utils/pubsub'\n\nexport const templateConfig = (options) => {\n\tconfig( options )\n}\n\nwindow.__jails__ = window.__jails__ || { components: {} }\n\nexport const register = ( name, module, dependencies ) => {\n\tconst { components } = window.__jails__\n\tcomponents[ name ] = { name, module, dependencies }\n}\n\nexport const start = ( target = document.body ) => {\n\n\tconst { components } = window.__jails__\n\tconst templates = template( target, { components } )\n\n\tObject\n\t\t.values( components )\n\t\t.forEach(({ name, module, dependencies }) => {\n\t\t\tif( !customElements.get(name) ) {\n\t\t\t\tcustomElements.define( name, Element({ component: { name, module, dependencies }, templates, start }))\n\t\t\t}\n\t})\n}\n\ndeclare global {\n\tinterface Window {\n\t  __jails__?: {\n\t\tcomponents: Record<string, any>\n\t  }\n\t}\n}\n"],"names":["textarea","document","createElement","g","scope","decodeHTML","text","innerHTML","value","uuid","Math","random","toString","substring","safe","execute","val","err","Idiomorph","noOp","defaults","morphStyle","callbacks","beforeNodeAdded","afterNodeAdded","beforeNodeMorphed","afterNodeMorphed","beforeNodeRemoved","afterNodeRemoved","beforeAttributeUpdated","head","style","shouldPreserve","elt","getAttribute","shouldReAppend","shouldRemove","afterHeadMorphed","restoreFocus","morphChildren","createNode","oldParent","newChild","insertionPoint","ctx","idMap","has","newEmptyChild","tagName","insertBefore","morphNode","newClonedChild","importNode","findBestMatch","isIdSetMatch","oldNode","newNode","oldSet","get","newSet","id","isSoftMatch","oldElt","newElt","nodeType","node","startPoint","endPoint","softMatch","nextSibling","siblingSoftMatchCount","cursor","contains","activeElement","removeNode","moveBefore","pantry","_a","parentNode","removeChild","removeNodesBetween","startInclusive","endExclusive","tempNode","moveBeforeById","after","target","querySelector","element","idSet","delete","size","removeElementFromAncestorsIdMaps","e","newParent","HTMLTemplateElement","content","firstChild","childNodes","bestMatch","Element","persistentIds","movedChild","insertedNode","syncBooleanAttribute","oldElement","newElement","attributeName","newLiveValue","ignoreUpdate","ignoreAttribute","setAttribute","removeAttribute","attr","updateType","ignoreActiveValue","ignoreValueOfActiveElement","possibleActiveElement","body","newContent","ignoreActive","HTMLHeadElement","ignore","handleHeadElement","type","oldAttributes","attributes","newAttributes","newAttribute","name","i","length","oldAttribute","hasAttribute","HTMLInputElement","newValue","oldValue","HTMLOptionElement","HTMLTextAreaElement","nodeValue","syncInputValue","morphAttributes","oldHead","newHead","added","removed","preserved","nodesToAppend","srcToNewHeadNodes","Map","newHeadChild","children","set","outerHTML","currentHeadElt","inNewContent","isReAppended","isPreserved","push","values","promises","createRange","createContextualFragment","href","src","resolve","promise","Promise","_resolve","addEventListener","appendChild","removedElement","kept","createMorphContext","createPantry","hidden","insertAdjacentElement","findIdElements","root","elements","Array","from","querySelectorAll","populateIdMapWithTree","current","Set","add","parentElement","config","oldContent","oldIdElements","newIdElements","duplicateIds","oldIdTagNameMap","createPersistentIds","newRoot","__idiomorphRoot","createIdMaps","mergedConfig","finalConfig","Object","assign","mergeDefaults","includes","normalizeElement","normalizeParent","generatedByIdiomorph","WeakSet","Document","documentElement","parser","DOMParser","contentWithSvgsRemoved","replace","match","parseFromString","htmlElement","parseContent","Node","s","matches","n","r","createDuckTypedParent","dummyParent","append","morph","morphedNodes","fn","activeElementId","selectionStart","selectionEnd","results","focus","setSelectionRange","saveAndRestoreFocus","callback","block","all","then","newCtx","withHeadBlocking","index","indexOf","rightMargin","slice","morphOuterHTML","remove","topics","_async","publish","params","forEach","topic","subscribe","method","filter","Component","module","dependencies","templates","signal","register","tick","preserve","_model","model","initialState","Function","tplid","scopeid","tpl","o","apply","elm","JSON","parse","stringify","state","view","data","base","template","main","protected","list","save","constructor","newstate","render","on","ev","selectorOrCallback","handler","detail","parent","delegateTarget","concat","args","capture","off","removeEventListener","trigger","String","dispatchEvent","CustomEvent","bubbles","emit","unmount","html_","clone","cloneNode","html","clearTimeout","setTimeout","call","IdiomorphOptions","child","key","default","WeakMap","component","start","HTMLElement","super","connectedCallback","this","abortController","AbortController","rtrn","disconnectedCallback","abort","tags","compile","parsedHtml","_","variable","tagElements","keys","components","localName","transformTemplate","htmlFor","htmlIf","htmlInner","htmlClass","split","varname","object","objectname","shift","open","createTextNode","close","wrap","className","trim","setTemplates","reverse","regexTags","RegExp","transformAttributes","removeTemplateTagsRecursively","_b","window","__jails__","customElements","define","options","newconfig"],"mappings":"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","x_google_ignoreList":[1]}