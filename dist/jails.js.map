{"version":3,"file":"jails.js","sources":["../src/utils/index.ts","../node_modules/idiomorph/dist/idiomorph.esm.js","../src/utils/pubsub.ts","../src/component.ts","../src/element.ts","../src/template-system.ts","../src/index.ts"],"sourcesContent":["\nconst textarea = document.createElement('textarea')\n\nexport const g = {\n\tscope: {}\n}\n\nexport const decodeHTML = (text) => {\n\ttextarea.innerHTML = text\n\treturn textarea.value\n}\n\nexport const rAF = (fn) => {\n\tif (requestAnimationFrame)\n\t\treturn requestAnimationFrame(fn)\n\telse\n\t\treturn setTimeout(fn, 1000 / 60)\n}\n\nexport const uuid = () => {\n\treturn Math.random().toString(36).substring(2, 9)\n}\n\nexport const dup = (o) => {\n\treturn JSON.parse(JSON.stringify(o))\n}\n\n// http://crockford.com/javascript/memory/leak.html\nexport const purge = (d) => {\n\tvar a = d.attributes, i, l, n\n\tif (a) {\n\t\tfor (i = a.length - 1; i >= 0; i -= 1) {\n\t\t\tn = a[i].name\n\t\t\tif (typeof d[n] === 'function') {\n\t\t\t\td[n] = null\n\t\t\t}\n\t\t}\n\t}\n\ta = d.childNodes\n\tif (a) {\n\t\tl = a.length\n\t\tfor (i = 0; i < l; i += 1) {\n\t\t\tpurge(d.childNodes[i])\n\t\t}\n\t}\n}\n\nexport const safe = (execute, val) => {\n\ttry{\n\t\treturn execute()\n\t}catch(err){\n\t\treturn val || ''\n\t}\n}\n","/**\n * @typedef {object} ConfigHead\n *\n * @property {'merge' | 'append' | 'morph' | 'none'} [style]\n * @property {boolean} [block]\n * @property {boolean} [ignore]\n * @property {function(Element): boolean} [shouldPreserve]\n * @property {function(Element): boolean} [shouldReAppend]\n * @property {function(Element): boolean} [shouldRemove]\n * @property {function(Element, {added: Node[], kept: Element[], removed: Element[]}): void} [afterHeadMorphed]\n */\n\n/**\n * @typedef {object} ConfigCallbacks\n *\n * @property {function(Node): boolean} [beforeNodeAdded]\n * @property {function(Node): void} [afterNodeAdded]\n * @property {function(Element, Node): boolean} [beforeNodeMorphed]\n * @property {function(Element, Node): void} [afterNodeMorphed]\n * @property {function(Element): boolean} [beforeNodeRemoved]\n * @property {function(Element): void} [afterNodeRemoved]\n * @property {function(string, Element, \"update\" | \"remove\"): boolean} [beforeAttributeUpdated]\n * @property {function(Element): boolean} [beforeNodePantried]\n */\n\n/**\n * @typedef {object} Config\n *\n * @property {'outerHTML' | 'innerHTML'} [morphStyle]\n * @property {boolean} [ignoreActive]\n * @property {boolean} [ignoreActiveValue]\n * @property {ConfigCallbacks} [callbacks]\n * @property {ConfigHead} [head]\n */\n\n/**\n * @typedef {function} NoOp\n *\n * @returns {void}\n */\n\n/**\n * @typedef {object} ConfigHeadInternal\n *\n * @property {'merge' | 'append' | 'morph' | 'none'} style\n * @property {boolean} [block]\n * @property {boolean} [ignore]\n * @property {(function(Element): boolean) | NoOp} shouldPreserve\n * @property {(function(Element): boolean) | NoOp} shouldReAppend\n * @property {(function(Element): boolean) | NoOp} shouldRemove\n * @property {(function(Element, {added: Node[], kept: Element[], removed: Element[]}): void) | NoOp} afterHeadMorphed\n */\n\n/**\n * @typedef {object} ConfigCallbacksInternal\n *\n * @property {(function(Node): boolean) | NoOp} beforeNodeAdded\n * @property {(function(Node): void) | NoOp} afterNodeAdded\n * @property {(function(Node, Node): boolean) | NoOp} beforeNodeMorphed\n * @property {(function(Node, Node): void) | NoOp} afterNodeMorphed\n * @property {(function(Node): boolean) | NoOp} beforeNodeRemoved\n * @property {(function(Node): void) | NoOp} afterNodeRemoved\n * @property {(function(string, Element, \"update\" | \"remove\"): boolean) | NoOp} beforeAttributeUpdated\n * @property {(function(Node): boolean) | NoOp} beforeNodePantried\n */\n\n/**\n * @typedef {object} ConfigInternal\n *\n * @property {'outerHTML' | 'innerHTML'} morphStyle\n * @property {boolean} [ignoreActive]\n * @property {boolean} [ignoreActiveValue]\n * @property {ConfigCallbacksInternal} callbacks\n * @property {ConfigHeadInternal} head\n * @property {boolean} [twoPass]\n */\n\n/**\n * @typedef {Function} Morph\n *\n * @param {Element | Document} oldNode\n * @param {Element | Node | HTMLCollection | Node[] | string | null} newContent\n * @param {Config} [config]\n * @returns {undefined | Node[]}\n */\n\n// base IIFE to define idiomorph\n/**\n *\n * @type {{defaults: ConfigInternal, morph: Morph}}\n */\nvar Idiomorph = (function () {\n  \"use strict\";\n\n  /**\n   * @typedef {object} MorphContext\n   *\n   * @property {Node} target\n   * @property {Node} newContent\n   * @property {ConfigInternal} config\n   * @property {ConfigInternal['morphStyle']} morphStyle\n   * @property {ConfigInternal['ignoreActive']} ignoreActive\n   * @property {ConfigInternal['ignoreActiveValue']} ignoreActiveValue\n   * @property {Map<Node, Set<string>>} idMap\n   * @property {Set<string>} persistentIds\n   * @property {Set<string>} deadIds\n   * @property {ConfigInternal['callbacks']} callbacks\n   * @property {ConfigInternal['head']} head\n   * @property {HTMLDivElement} pantry\n   */\n\n  //=============================================================================\n  // AND NOW IT BEGINS...\n  //=============================================================================\n\n  /**\n   *\n   * @type {Set<string>}\n   */\n  let EMPTY_SET = new Set();\n\n  /**\n   * Default configuration values, updatable by users now\n   * @type {ConfigInternal}\n   */\n  let defaults = {\n    morphStyle: \"outerHTML\",\n    callbacks: {\n      beforeNodeAdded: noOp,\n      afterNodeAdded: noOp,\n      beforeNodeMorphed: noOp,\n      afterNodeMorphed: noOp,\n      beforeNodeRemoved: noOp,\n      afterNodeRemoved: noOp,\n      beforeAttributeUpdated: noOp,\n      beforeNodePantried: noOp,\n    },\n    head: {\n      style: \"merge\",\n      shouldPreserve: function (elt) {\n        return elt.getAttribute(\"im-preserve\") === \"true\";\n      },\n      shouldReAppend: function (elt) {\n        return elt.getAttribute(\"im-re-append\") === \"true\";\n      },\n      shouldRemove: noOp,\n      afterHeadMorphed: noOp,\n    },\n  };\n\n  /**\n   * =============================================================================\n   * Core Morphing Algorithm - morph, morphNormalizedContent, morphOldNodeTo, morphChildren\n   * =============================================================================\n   *\n   * @param {Element | Document} oldNode\n   * @param {Element | Node | HTMLCollection | Node[] | string | null} newContent\n   * @param {Config} [config]\n   * @returns {undefined | Node[]}\n   */\n  function morph(oldNode, newContent, config = {}) {\n    if (oldNode instanceof Document) {\n      oldNode = oldNode.documentElement;\n    }\n\n    if (typeof newContent === \"string\") {\n      newContent = parseContent(newContent);\n    }\n\n    let normalizedContent = normalizeContent(newContent);\n\n    let ctx = createMorphContext(oldNode, normalizedContent, config);\n\n    return morphNormalizedContent(oldNode, normalizedContent, ctx);\n  }\n\n  /**\n   *\n   * @param {Element} oldNode\n   * @param {Element} normalizedNewContent\n   * @param {MorphContext} ctx\n   * @returns {undefined | Node[]}\n   */\n  function morphNormalizedContent(oldNode, normalizedNewContent, ctx) {\n    if (ctx.head.block) {\n      let oldHead = oldNode.querySelector(\"head\");\n      let newHead = normalizedNewContent.querySelector(\"head\");\n      if (oldHead && newHead) {\n        let promises = handleHeadElement(newHead, oldHead, ctx);\n        // when head promises resolve, call morph again, ignoring the head tag\n        Promise.all(promises).then(function () {\n          morphNormalizedContent(\n            oldNode,\n            normalizedNewContent,\n            Object.assign(ctx, {\n              head: {\n                block: false,\n                ignore: true,\n              },\n            }),\n          );\n        });\n        return;\n      }\n    }\n\n    if (ctx.morphStyle === \"innerHTML\") {\n      // innerHTML, so we are only updating the children\n      morphChildren(normalizedNewContent, oldNode, ctx);\n      if (ctx.config.twoPass) {\n        restoreFromPantry(oldNode, ctx);\n      }\n      return Array.from(oldNode.children);\n    } else if (ctx.morphStyle === \"outerHTML\" || ctx.morphStyle == null) {\n      // otherwise find the best element match in the new content, morph that, and merge its siblings\n      // into either side of the best match\n      let bestMatch = findBestNodeMatch(normalizedNewContent, oldNode, ctx);\n\n      // stash the siblings that will need to be inserted on either side of the best match\n      let previousSibling = bestMatch?.previousSibling ?? null;\n      let nextSibling = bestMatch?.nextSibling ?? null;\n\n      // morph it\n      let morphedNode = morphOldNodeTo(oldNode, bestMatch, ctx);\n\n      if (bestMatch) {\n        // if there was a best match, merge the siblings in too and return the\n        // whole bunch\n        if (morphedNode) {\n          const elements = insertSiblings(\n            previousSibling,\n            morphedNode,\n            nextSibling,\n          );\n          if (ctx.config.twoPass) {\n            restoreFromPantry(morphedNode.parentNode, ctx);\n          }\n          return elements;\n        }\n      } else {\n        // otherwise nothing was added to the DOM\n        return [];\n      }\n    } else {\n      throw \"Do not understand how to morph style \" + ctx.morphStyle;\n    }\n  }\n\n  /**\n   * @param {Node} possibleActiveElement\n   * @param {MorphContext} ctx\n   * @returns {boolean}\n   */\n  // TODO: ignoreActive and ignoreActiveValue are marked as optional since they are not\n  //   initialised in the default config object. As a result the && in the function body may\n  //   return undefined instead of boolean. Either expand the type of the return value to\n  //   include undefined or wrap the ctx.ignoreActiveValue into a Boolean()\n  function ignoreValueOfActiveElement(possibleActiveElement, ctx) {\n    return (\n      !!ctx.ignoreActiveValue &&\n      possibleActiveElement === document.activeElement &&\n      possibleActiveElement !== document.body\n    );\n  }\n\n  /**\n   * @param {Node} oldNode root node to merge content into\n   * @param {Node | null} newContent new content to merge\n   * @param {MorphContext} ctx the merge context\n   * @returns {Node | null} the element that ended up in the DOM\n   */\n  function morphOldNodeTo(oldNode, newContent, ctx) {\n    if (ctx.ignoreActive && oldNode === document.activeElement) {\n      // don't morph focused element\n    } else if (newContent == null) {\n      if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return oldNode;\n\n      oldNode.parentNode?.removeChild(oldNode);\n      ctx.callbacks.afterNodeRemoved(oldNode);\n      return null;\n    } else if (!isSoftMatch(oldNode, newContent)) {\n      if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return oldNode;\n      if (ctx.callbacks.beforeNodeAdded(newContent) === false) return oldNode;\n\n      oldNode.parentNode?.replaceChild(newContent, oldNode);\n      ctx.callbacks.afterNodeAdded(newContent);\n      ctx.callbacks.afterNodeRemoved(oldNode);\n      return newContent;\n    } else {\n      if (ctx.callbacks.beforeNodeMorphed(oldNode, newContent) === false)\n        return oldNode;\n\n      if (oldNode instanceof HTMLHeadElement && ctx.head.ignore) {\n        // ignore the head element\n      } else if (\n        oldNode instanceof HTMLHeadElement &&\n        ctx.head.style !== \"morph\"\n      ) {\n        // ok to cast: if newContent wasn't also a <head>, it would've got caught in the `!isSoftMatch` branch above\n        handleHeadElement(\n          /** @type {HTMLHeadElement} */ (newContent),\n          oldNode,\n          ctx,\n        );\n      } else {\n        syncNodeFrom(newContent, oldNode, ctx);\n        if (!ignoreValueOfActiveElement(oldNode, ctx)) {\n          morphChildren(newContent, oldNode, ctx);\n        }\n      }\n      ctx.callbacks.afterNodeMorphed(oldNode, newContent);\n      return oldNode;\n    }\n    return null;\n  }\n\n  /**\n   * This is the core algorithm for matching up children.  The idea is to use id sets to try to match up\n   * nodes as faithfully as possible.  We greedily match, which allows us to keep the algorithm fast, but\n   * by using id sets, we are able to better match up with content deeper in the DOM.\n   *\n   * Basic algorithm is, for each node in the new content:\n   *\n   * - if we have reached the end of the old parent, append the new content\n   * - if the new content has an id set match with the current insertion point, morph\n   * - search for an id set match\n   * - if id set match found, morph\n   * - otherwise search for a \"soft\" match\n   * - if a soft match is found, morph\n   * - otherwise, prepend the new node before the current insertion point\n   *\n   * The two search algorithms terminate if competing node matches appear to outweigh what can be achieved\n   * with the current node.  See findIdSetMatch() and findSoftMatch() for details.\n   *\n   * @param {Node} newParent the parent element of the new content\n   * @param {Node} oldParent the old content that we are merging the new content into\n   * @param {MorphContext} ctx the merge context\n   * @returns {void}\n   */\n  function morphChildren(newParent, oldParent, ctx) {\n    if (\n      newParent instanceof HTMLTemplateElement &&\n      oldParent instanceof HTMLTemplateElement\n    ) {\n      newParent = newParent.content;\n      oldParent = oldParent.content;\n    }\n\n    /**\n     *\n     * @type {Node | null}\n     */\n    let nextNewChild = newParent.firstChild;\n    /**\n     *\n     * @type {Node | null}\n     */\n    let insertionPoint = oldParent.firstChild;\n    let newChild;\n\n    // run through all the new content\n    while (nextNewChild) {\n      newChild = nextNewChild;\n      nextNewChild = newChild.nextSibling;\n\n      // if we are at the end of the exiting parent's children, just append\n      if (insertionPoint == null) {\n        // skip add callbacks when we're going to be restoring this from the pantry in the second pass\n        if (\n          ctx.config.twoPass &&\n          ctx.persistentIds.has(/** @type {Element} */ (newChild).id)\n        ) {\n          oldParent.appendChild(newChild);\n        } else {\n          if (ctx.callbacks.beforeNodeAdded(newChild) === false) continue;\n          oldParent.appendChild(newChild);\n          ctx.callbacks.afterNodeAdded(newChild);\n        }\n        removeIdsFromConsideration(ctx, newChild);\n        continue;\n      }\n\n      // if the current node has an id set match then morph\n      if (isIdSetMatch(newChild, insertionPoint, ctx)) {\n        morphOldNodeTo(insertionPoint, newChild, ctx);\n        insertionPoint = insertionPoint.nextSibling;\n        removeIdsFromConsideration(ctx, newChild);\n        continue;\n      }\n\n      // otherwise search forward in the existing old children for an id set match\n      let idSetMatch = findIdSetMatch(\n        newParent,\n        oldParent,\n        newChild,\n        insertionPoint,\n        ctx,\n      );\n\n      // if we found a potential match, remove the nodes until that point and morph\n      if (idSetMatch) {\n        insertionPoint = removeNodesBetween(insertionPoint, idSetMatch, ctx);\n        morphOldNodeTo(idSetMatch, newChild, ctx);\n        removeIdsFromConsideration(ctx, newChild);\n        continue;\n      }\n\n      // no id set match found, so scan forward for a soft match for the current node\n      let softMatch = findSoftMatch(\n        newParent,\n        oldParent,\n        newChild,\n        insertionPoint,\n        ctx,\n      );\n\n      // if we found a soft match for the current node, morph\n      if (softMatch) {\n        insertionPoint = removeNodesBetween(insertionPoint, softMatch, ctx);\n        morphOldNodeTo(softMatch, newChild, ctx);\n        removeIdsFromConsideration(ctx, newChild);\n        continue;\n      }\n\n      // abandon all hope of morphing, just insert the new child before the insertion point\n      // and move on\n\n      // skip add callbacks when we're going to be restoring this from the pantry in the second pass\n      if (\n        ctx.config.twoPass &&\n        ctx.persistentIds.has(/** @type {Element} */ (newChild).id)\n      ) {\n        oldParent.insertBefore(newChild, insertionPoint);\n      } else {\n        if (ctx.callbacks.beforeNodeAdded(newChild) === false) continue;\n        oldParent.insertBefore(newChild, insertionPoint);\n        ctx.callbacks.afterNodeAdded(newChild);\n      }\n      removeIdsFromConsideration(ctx, newChild);\n    }\n\n    // remove any remaining old nodes that didn't match up with new content\n    while (insertionPoint !== null) {\n      let tempNode = insertionPoint;\n      insertionPoint = insertionPoint.nextSibling;\n      removeNode(tempNode, ctx);\n    }\n  }\n\n  //=============================================================================\n  // Attribute Syncing Code\n  //=============================================================================\n\n  /**\n   * @param {string} attr the attribute to be mutated\n   * @param {Element} to the element that is going to be updated\n   * @param {\"update\" | \"remove\"} updateType\n   * @param {MorphContext} ctx the merge context\n   * @returns {boolean} true if the attribute should be ignored, false otherwise\n   */\n  function ignoreAttribute(attr, to, updateType, ctx) {\n    if (\n      attr === \"value\" &&\n      ctx.ignoreActiveValue &&\n      to === document.activeElement\n    ) {\n      return true;\n    }\n    return ctx.callbacks.beforeAttributeUpdated(attr, to, updateType) === false;\n  }\n\n  /**\n   * syncs a given node with another node, copying over all attributes and\n   * inner element state from the 'from' node to the 'to' node\n   *\n   * @param {Node} from the element to copy attributes & state from\n   * @param {Node} to the element to copy attributes & state to\n   * @param {MorphContext} ctx the merge context\n   */\n  function syncNodeFrom(from, to, ctx) {\n    let type = from.nodeType;\n\n    // if is an element type, sync the attributes from the\n    // new node into the new node\n    if (type === 1 /* element type */) {\n      const fromEl = /** @type {Element} */ (from);\n      const toEl = /** @type {Element} */ (to);\n      const fromAttributes = fromEl.attributes;\n      const toAttributes = toEl.attributes;\n      for (const fromAttribute of fromAttributes) {\n        if (ignoreAttribute(fromAttribute.name, toEl, \"update\", ctx)) {\n          continue;\n        }\n        if (toEl.getAttribute(fromAttribute.name) !== fromAttribute.value) {\n          toEl.setAttribute(fromAttribute.name, fromAttribute.value);\n        }\n      }\n      // iterate backwards to avoid skipping over items when a delete occurs\n      for (let i = toAttributes.length - 1; 0 <= i; i--) {\n        const toAttribute = toAttributes[i];\n\n        // toAttributes is a live NamedNodeMap, so iteration+mutation is unsafe\n        // e.g. custom element attribute callbacks can remove other attributes\n        if (!toAttribute) continue;\n\n        if (!fromEl.hasAttribute(toAttribute.name)) {\n          if (ignoreAttribute(toAttribute.name, toEl, \"remove\", ctx)) {\n            continue;\n          }\n          toEl.removeAttribute(toAttribute.name);\n        }\n      }\n    }\n\n    // sync text nodes\n    if (type === 8 /* comment */ || type === 3 /* text */) {\n      if (to.nodeValue !== from.nodeValue) {\n        to.nodeValue = from.nodeValue;\n      }\n    }\n\n    if (!ignoreValueOfActiveElement(to, ctx)) {\n      // sync input values\n      syncInputValue(from, to, ctx);\n    }\n  }\n\n  /**\n   * @param {Element} from element to sync the value from\n   * @param {Element} to element to sync the value to\n   * @param {string} attributeName the attribute name\n   * @param {MorphContext} ctx the merge context\n   */\n  function syncBooleanAttribute(from, to, attributeName, ctx) {\n    // TODO: prefer set/getAttribute here\n    if (!(from instanceof Element && to instanceof Element)) return;\n    // @ts-ignore this function is only used on boolean attrs that are reflected as dom properties\n    const fromLiveValue = from[attributeName],\n      toLiveValue = to[attributeName];\n    if (fromLiveValue !== toLiveValue) {\n      let ignoreUpdate = ignoreAttribute(attributeName, to, \"update\", ctx);\n      if (!ignoreUpdate) {\n        // update attribute's associated DOM property\n        // @ts-ignore this function is only used on boolean attrs that are reflected as dom properties\n        to[attributeName] = from[attributeName];\n      }\n      if (fromLiveValue) {\n        if (!ignoreUpdate) {\n          // TODO: do we really want this? tests say so but it feels wrong\n          to.setAttribute(attributeName, fromLiveValue);\n        }\n      } else {\n        if (!ignoreAttribute(attributeName, to, \"remove\", ctx)) {\n          to.removeAttribute(attributeName);\n        }\n      }\n    }\n  }\n\n  /**\n   * NB: many bothans died to bring us information:\n   *\n   *  https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n   *  https://github.com/choojs/nanomorph/blob/master/lib/morph.jsL113\n   *\n   * @param {Node} from the element to sync the input value from\n   * @param {Node} to the element to sync the input value to\n   * @param {MorphContext} ctx the merge context\n   */\n  function syncInputValue(from, to, ctx) {\n    if (\n      from instanceof HTMLInputElement &&\n      to instanceof HTMLInputElement &&\n      from.type !== \"file\"\n    ) {\n      let fromValue = from.value;\n      let toValue = to.value;\n\n      // sync boolean attributes\n      syncBooleanAttribute(from, to, \"checked\", ctx);\n      syncBooleanAttribute(from, to, \"disabled\", ctx);\n\n      if (!from.hasAttribute(\"value\")) {\n        if (!ignoreAttribute(\"value\", to, \"remove\", ctx)) {\n          to.value = \"\";\n          to.removeAttribute(\"value\");\n        }\n      } else if (fromValue !== toValue) {\n        if (!ignoreAttribute(\"value\", to, \"update\", ctx)) {\n          to.setAttribute(\"value\", fromValue);\n          to.value = fromValue;\n        }\n      }\n      // TODO: QUESTION(1cg): this used to only check `from` unlike the other branches -- why?\n      // did I break something?\n    } else if (\n      from instanceof HTMLOptionElement &&\n      to instanceof HTMLOptionElement\n    ) {\n      syncBooleanAttribute(from, to, \"selected\", ctx);\n    } else if (\n      from instanceof HTMLTextAreaElement &&\n      to instanceof HTMLTextAreaElement\n    ) {\n      let fromValue = from.value;\n      let toValue = to.value;\n      if (ignoreAttribute(\"value\", to, \"update\", ctx)) {\n        return;\n      }\n      if (fromValue !== toValue) {\n        to.value = fromValue;\n      }\n      if (to.firstChild && to.firstChild.nodeValue !== fromValue) {\n        to.firstChild.nodeValue = fromValue;\n      }\n    }\n  }\n\n  /**\n   * =============================================================================\n   *  The HEAD tag can be handled specially, either w/ a 'merge' or 'append' style\n   * =============================================================================\n   * @param {Element} newHeadTag\n   * @param {Element} currentHead\n   * @param {MorphContext} ctx\n   * @returns {Promise<void>[]}\n   */\n  function handleHeadElement(newHeadTag, currentHead, ctx) {\n    /**\n     * @type {Node[]}\n     */\n    let added = [];\n    /**\n     * @type {Element[]}\n     */\n    let removed = [];\n    /**\n     * @type {Element[]}\n     */\n    let preserved = [];\n    /**\n     * @type {Element[]}\n     */\n    let nodesToAppend = [];\n\n    let headMergeStyle = ctx.head.style;\n\n    // put all new head elements into a Map, by their outerHTML\n    let srcToNewHeadNodes = new Map();\n    for (const newHeadChild of newHeadTag.children) {\n      srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild);\n    }\n\n    // for each elt in the current head\n    for (const currentHeadElt of currentHead.children) {\n      // If the current head element is in the map\n      let inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML);\n      let isReAppended = ctx.head.shouldReAppend(currentHeadElt);\n      let isPreserved = ctx.head.shouldPreserve(currentHeadElt);\n      if (inNewContent || isPreserved) {\n        if (isReAppended) {\n          // remove the current version and let the new version replace it and re-execute\n          removed.push(currentHeadElt);\n        } else {\n          // this element already exists and should not be re-appended, so remove it from\n          // the new content map, preserving it in the DOM\n          srcToNewHeadNodes.delete(currentHeadElt.outerHTML);\n          preserved.push(currentHeadElt);\n        }\n      } else {\n        if (headMergeStyle === \"append\") {\n          // we are appending and this existing element is not new content\n          // so if and only if it is marked for re-append do we do anything\n          if (isReAppended) {\n            removed.push(currentHeadElt);\n            nodesToAppend.push(currentHeadElt);\n          }\n        } else {\n          // if this is a merge, we remove this content since it is not in the new head\n          if (ctx.head.shouldRemove(currentHeadElt) !== false) {\n            removed.push(currentHeadElt);\n          }\n        }\n      }\n    }\n\n    // Push the remaining new head elements in the Map into the\n    // nodes to append to the head tag\n    nodesToAppend.push(...srcToNewHeadNodes.values());\n    log(\"to append: \", nodesToAppend);\n\n    let promises = [];\n    for (const newNode of nodesToAppend) {\n      log(\"adding: \", newNode);\n      // TODO: This could theoretically be null, based on type\n      let newElt = /** @type {ChildNode} */ (\n        document.createRange().createContextualFragment(newNode.outerHTML)\n          .firstChild\n      );\n      log(newElt);\n      if (ctx.callbacks.beforeNodeAdded(newElt) !== false) {\n        if (\n          (\"href\" in newElt && newElt.href) ||\n          (\"src\" in newElt && newElt.src)\n        ) {\n          /** @type {(result?: any) => void} */ let resolve;\n          let promise = new Promise(function (_resolve) {\n            resolve = _resolve;\n          });\n          newElt.addEventListener(\"load\", function () {\n            resolve();\n          });\n          promises.push(promise);\n        }\n        currentHead.appendChild(newElt);\n        ctx.callbacks.afterNodeAdded(newElt);\n        added.push(newElt);\n      }\n    }\n\n    // remove all removed elements, after we have appended the new elements to avoid\n    // additional network requests for things like style sheets\n    for (const removedElement of removed) {\n      if (ctx.callbacks.beforeNodeRemoved(removedElement) !== false) {\n        currentHead.removeChild(removedElement);\n        ctx.callbacks.afterNodeRemoved(removedElement);\n      }\n    }\n\n    ctx.head.afterHeadMorphed(currentHead, {\n      added: added,\n      kept: preserved,\n      removed: removed,\n    });\n    return promises;\n  }\n\n  //=============================================================================\n  // Misc\n  //=============================================================================\n\n  /**\n   * @param {any[]} _args\n   */\n  function log(..._args) {\n    //console.log(args);\n  }\n\n  function noOp() {}\n\n  /**\n   * Deep merges the config object and the Idiomoroph.defaults object to\n   * produce a final configuration object\n   * @param {Config} config\n   * @returns {ConfigInternal}\n   */\n  function mergeDefaults(config) {\n    /**\n     * @type {ConfigInternal}\n     */\n    let finalConfig = Object.assign({}, defaults);\n\n    // copy top level stuff into final config\n    Object.assign(finalConfig, config);\n\n    // copy callbacks into final config (do this to deep merge the callbacks)\n    finalConfig.callbacks = Object.assign(\n      {},\n      defaults.callbacks,\n      config.callbacks,\n    );\n\n    // copy head config into final config  (do this to deep merge the head)\n    finalConfig.head = Object.assign({}, defaults.head, config.head);\n\n    return finalConfig;\n  }\n\n  /**\n   *\n   * @param {Element} oldNode\n   * @param {Element} newContent\n   * @param {Config} config\n   * @returns {MorphContext}\n   */\n  function createMorphContext(oldNode, newContent, config) {\n    const mergedConfig = mergeDefaults(config);\n    return {\n      target: oldNode,\n      newContent: newContent,\n      config: mergedConfig,\n      morphStyle: mergedConfig.morphStyle,\n      ignoreActive: mergedConfig.ignoreActive,\n      ignoreActiveValue: mergedConfig.ignoreActiveValue,\n      idMap: createIdMap(oldNode, newContent),\n      deadIds: new Set(),\n      persistentIds: mergedConfig.twoPass\n        ? createPersistentIds(oldNode, newContent)\n        : new Set(),\n      pantry: mergedConfig.twoPass\n        ? createPantry()\n        : document.createElement(\"div\"),\n      callbacks: mergedConfig.callbacks,\n      head: mergedConfig.head,\n    };\n  }\n\n  function createPantry() {\n    const pantry = document.createElement(\"div\");\n    pantry.hidden = true;\n    document.body.insertAdjacentElement(\"afterend\", pantry);\n    return pantry;\n  }\n\n  /**\n   *\n   * @param {Node | null} node1\n   * @param {Node | null} node2\n   * @param {MorphContext} ctx\n   * @returns {boolean}\n   */\n  // TODO: The function handles this as if it's Element or null, but the function is called in\n  //   places where the arguments may be just a Node, not an Element\n  function isIdSetMatch(node1, node2, ctx) {\n    if (node1 == null || node2 == null) {\n      return false;\n    }\n    if (\n      node1 instanceof Element &&\n      node2 instanceof Element &&\n      node1.tagName === node2.tagName\n    ) {\n      if (node1.id !== \"\" && node1.id === node2.id) {\n        return true;\n      } else {\n        return getIdIntersectionCount(ctx, node1, node2) > 0;\n      }\n    }\n    return false;\n  }\n\n  /**\n   *\n   * @param {Node | null} oldNode\n   * @param {Node | null} newNode\n   * @returns {boolean}\n   */\n  function isSoftMatch(oldNode, newNode) {\n    if (oldNode == null || newNode == null) {\n      return false;\n    }\n    // ok to cast: if one is not element, `id` or `tagName` will be undefined and we'll compare that\n    // If oldNode has an `id` with possible state and it doesn't match newNode.id then avoid morphing\n    if (\n      /** @type {Element} */ (oldNode).id &&\n      /** @type {Element} */ (oldNode).id !==\n        /** @type {Element} */ (newNode).id\n    ) {\n      return false;\n    }\n    return (\n      oldNode.nodeType === newNode.nodeType &&\n      /** @type {Element} */ (oldNode).tagName ===\n        /** @type {Element} */ (newNode).tagName\n    );\n  }\n\n  /**\n   *\n   * @param {Node} startInclusive\n   * @param {Node} endExclusive\n   * @param {MorphContext} ctx\n   * @returns {Node | null}\n   */\n  function removeNodesBetween(startInclusive, endExclusive, ctx) {\n    /** @type {Node | null} */ let cursor = startInclusive;\n    while (cursor !== endExclusive) {\n      let tempNode = /** @type {Node} */ (cursor);\n      // TODO: Prefer assigning to a new variable here or expand the type of startInclusive\n      //  to be Node | null\n      cursor = tempNode.nextSibling;\n      removeNode(tempNode, ctx);\n    }\n    removeIdsFromConsideration(ctx, endExclusive);\n    return endExclusive.nextSibling;\n  }\n\n  /**\n   * =============================================================================\n   *  Scans forward from the insertionPoint in the old parent looking for a potential id match\n   *  for the newChild.  We stop if we find a potential id match for the new child OR\n   *  if the number of potential id matches we are discarding is greater than the\n   *  potential id matches for the new child\n   * =============================================================================\n   * @param {Node} newContent\n   * @param {Node} oldParent\n   * @param {Node} newChild\n   * @param {Node} insertionPoint\n   * @param {MorphContext} ctx\n   * @returns {null | Node}\n   */\n  function findIdSetMatch(\n    newContent,\n    oldParent,\n    newChild,\n    insertionPoint,\n    ctx,\n  ) {\n    // max id matches we are willing to discard in our search\n    let newChildPotentialIdCount = getIdIntersectionCount(\n      ctx,\n      newChild,\n      oldParent,\n    );\n\n    /**\n     * @type {Node | null}\n     */\n    let potentialMatch = null;\n\n    // only search forward if there is a possibility of an id match\n    if (newChildPotentialIdCount > 0) {\n      // TODO: This is ghosting the potentialMatch variable outside of this block.\n      //   Probably an error\n      potentialMatch = insertionPoint;\n      // if there is a possibility of an id match, scan forward\n      // keep track of the potential id match count we are discarding (the\n      // newChildPotentialIdCount must be greater than this to make it likely\n      // worth it)\n      let otherMatchCount = 0;\n      while (potentialMatch != null) {\n        // If we have an id match, return the current potential match\n        if (isIdSetMatch(newChild, potentialMatch, ctx)) {\n          return potentialMatch;\n        }\n\n        // computer the other potential matches of this new content\n        otherMatchCount += getIdIntersectionCount(\n          ctx,\n          potentialMatch,\n          newContent,\n        );\n        if (otherMatchCount > newChildPotentialIdCount) {\n          // if we have more potential id matches in _other_ content, we\n          // do not have a good candidate for an id match, so return null\n          return null;\n        }\n\n        // advanced to the next old content child\n        potentialMatch = potentialMatch.nextSibling;\n      }\n    }\n    return potentialMatch;\n  }\n\n  /**\n   * =============================================================================\n   *  Scans forward from the insertionPoint in the old parent looking for a potential soft match\n   *  for the newChild.  We stop if we find a potential soft match for the new child OR\n   *  if we find a potential id match in the old parents children OR if we find two\n   *  potential soft matches for the next two pieces of new content\n   * =============================================================================\n   * @param {Node} newContent\n   * @param {Node} oldParent\n   * @param {Node} newChild\n   * @param {Node} insertionPoint\n   * @param {MorphContext} ctx\n   * @returns {null | Node}\n   */\n  function findSoftMatch(newContent, oldParent, newChild, insertionPoint, ctx) {\n    /**\n     * @type {Node | null}\n     */\n    let potentialSoftMatch = insertionPoint;\n    /**\n     * @type {Node | null}\n     */\n    let nextSibling = newChild.nextSibling;\n    let siblingSoftMatchCount = 0;\n\n    while (potentialSoftMatch != null) {\n      if (getIdIntersectionCount(ctx, potentialSoftMatch, newContent) > 0) {\n        // the current potential soft match has a potential id set match with the remaining new\n        // content so bail out of looking\n        return null;\n      }\n\n      // if we have a soft match with the current node, return it\n      if (isSoftMatch(potentialSoftMatch, newChild)) {\n        return potentialSoftMatch;\n      }\n\n      if (isSoftMatch(potentialSoftMatch, nextSibling)) {\n        // the next new node has a soft match with this node, so\n        // increment the count of future soft matches\n        siblingSoftMatchCount++;\n        // ok to cast: if it was null it couldn't be a soft match\n        nextSibling = /** @type {Node} */ (nextSibling).nextSibling;\n\n        // If there are two future soft matches, bail to allow the siblings to soft match\n        // so that we don't consume future soft matches for the sake of the current node\n        if (siblingSoftMatchCount >= 2) {\n          return null;\n        }\n      }\n\n      // advanced to the next old content child\n      potentialSoftMatch = potentialSoftMatch.nextSibling;\n    }\n\n    return potentialSoftMatch;\n  }\n\n  /** @type {WeakSet<Node>} */\n  const generatedByIdiomorph = new WeakSet();\n\n  /**\n   *\n   * @param {string} newContent\n   * @returns {Node | null | DocumentFragment}\n   */\n  function parseContent(newContent) {\n    let parser = new DOMParser();\n\n    // remove svgs to avoid false-positive matches on head, etc.\n    let contentWithSvgsRemoved = newContent.replace(\n      /<svg(\\s[^>]*>|>)([\\s\\S]*?)<\\/svg>/gim,\n      \"\",\n    );\n\n    // if the newContent contains a html, head or body tag, we can simply parse it w/o wrapping\n    if (\n      contentWithSvgsRemoved.match(/<\\/html>/) ||\n      contentWithSvgsRemoved.match(/<\\/head>/) ||\n      contentWithSvgsRemoved.match(/<\\/body>/)\n    ) {\n      let content = parser.parseFromString(newContent, \"text/html\");\n      // if it is a full HTML document, return the document itself as the parent container\n      if (contentWithSvgsRemoved.match(/<\\/html>/)) {\n        generatedByIdiomorph.add(content);\n        return content;\n      } else {\n        // otherwise return the html element as the parent container\n        let htmlElement = content.firstChild;\n        if (htmlElement) {\n          generatedByIdiomorph.add(htmlElement);\n          return htmlElement;\n        } else {\n          return null;\n        }\n      }\n    } else {\n      // if it is partial HTML, wrap it in a template tag to provide a parent element and also to help\n      // deal with touchy tags like tr, tbody, etc.\n      let responseDoc = parser.parseFromString(\n        \"<body><template>\" + newContent + \"</template></body>\",\n        \"text/html\",\n      );\n      let content = /** @type {HTMLTemplateElement} */ (\n        responseDoc.body.querySelector(\"template\")\n      ).content;\n      generatedByIdiomorph.add(content);\n      return content;\n    }\n  }\n\n  /**\n   *\n   * @param {null | Node | HTMLCollection | Node[] | Document & {generatedByIdiomorph:boolean}} newContent\n   * @returns {Element}\n   */\n  function normalizeContent(newContent) {\n    if (newContent == null) {\n      // noinspection UnnecessaryLocalVariableJS\n      const dummyParent = document.createElement(\"div\");\n      return dummyParent;\n    } else if (generatedByIdiomorph.has(/** @type {Element} */ (newContent))) {\n      // the template tag created by idiomorph parsing can serve as a dummy parent\n      return /** @type {Element} */ (newContent);\n    } else if (newContent instanceof Node) {\n      // a single node is added as a child to a dummy parent\n      const dummyParent = document.createElement(\"div\");\n      dummyParent.append(newContent);\n      return dummyParent;\n    } else {\n      // all nodes in the array or HTMLElement collection are consolidated under\n      // a single dummy parent element\n      const dummyParent = document.createElement(\"div\");\n      for (const elt of [...newContent]) {\n        dummyParent.append(elt);\n      }\n      return dummyParent;\n    }\n  }\n\n  /**\n   *\n   * @param {Node | null} previousSibling\n   * @param {Node} morphedNode\n   * @param {Node | null} nextSibling\n   * @returns {Node[]}\n   */\n  function insertSiblings(previousSibling, morphedNode, nextSibling) {\n    /**\n     * @type {Node[]}\n     */\n    let stack = [];\n    /**\n     * @type {Node[]}\n     */\n    let added = [];\n    while (previousSibling != null) {\n      stack.push(previousSibling);\n      previousSibling = previousSibling.previousSibling;\n    }\n    // Base the loop on the node variable, so that you do not need runtime checks for\n    // undefined value inside the loop\n    let node = stack.pop();\n    while (node !== undefined) {\n      added.push(node); // push added preceding siblings on in order and insert\n      morphedNode.parentElement?.insertBefore(node, morphedNode);\n      node = stack.pop();\n    }\n    added.push(morphedNode);\n    while (nextSibling != null) {\n      stack.push(nextSibling);\n      added.push(nextSibling); // here we are going in order, so push on as we scan, rather than add\n      nextSibling = nextSibling.nextSibling;\n    }\n    while (stack.length > 0) {\n      const node = /** @type {Node} */ (stack.pop());\n      morphedNode.parentElement?.insertBefore(node, morphedNode.nextSibling);\n    }\n    return added;\n  }\n\n  /**\n   *\n   * @param {Element} newContent\n   * @param {Element} oldNode\n   * @param {MorphContext} ctx\n   * @returns {Node | null}\n   */\n  function findBestNodeMatch(newContent, oldNode, ctx) {\n    /**\n     * @type {Node | null}\n     */\n    let currentElement;\n    currentElement = newContent.firstChild;\n    /**\n     * @type {Node | null}\n     */\n    let bestElement = currentElement;\n    let score = 0;\n    while (currentElement) {\n      let newScore = scoreElement(currentElement, oldNode, ctx);\n      if (newScore > score) {\n        bestElement = currentElement;\n        score = newScore;\n      }\n      currentElement = currentElement.nextSibling;\n    }\n    return bestElement;\n  }\n\n  /**\n   *\n   * @param {Node | null} node1\n   * @param {Element} node2\n   * @param {MorphContext} ctx\n   * @returns {number}\n   */\n  // TODO: The function handles node1 and node2 as if they are Elements but the function is\n  //   called in places where node1 and node2 may be just Nodes, not Elements\n  function scoreElement(node1, node2, ctx) {\n    if (isSoftMatch(node2, node1)) {\n      // ok to cast: isSoftMatch performs a null check\n      return (\n        0.5 + getIdIntersectionCount(ctx, /** @type {Node} */ (node1), node2)\n      );\n    }\n    return 0;\n  }\n\n  /**\n   *\n   * @param {Node} tempNode\n   * @param {MorphContext} ctx\n   */\n  // TODO: The function handles tempNode as if it's Element but the function is called in\n  //   places where tempNode may be just a Node, not an Element\n  function removeNode(tempNode, ctx) {\n    removeIdsFromConsideration(ctx, tempNode);\n    // skip remove callbacks when we're going to be restoring this from the pantry in the second pass\n    if (\n      ctx.config.twoPass &&\n      hasPersistentIdNodes(ctx, tempNode) &&\n      tempNode instanceof Element\n    ) {\n      moveToPantry(tempNode, ctx);\n    } else {\n      if (ctx.callbacks.beforeNodeRemoved(tempNode) === false) return;\n      tempNode.parentNode?.removeChild(tempNode);\n      ctx.callbacks.afterNodeRemoved(tempNode);\n    }\n  }\n\n  /**\n   *\n   * @param {Node} node\n   * @param {MorphContext} ctx\n   */\n  function moveToPantry(node, ctx) {\n    if (ctx.callbacks.beforeNodePantried(node) === false) return;\n\n    Array.from(node.childNodes).forEach((child) => {\n      moveToPantry(child, ctx);\n    });\n\n    // After processing children, process the current node\n    if (ctx.persistentIds.has(/** @type {Element} */ (node).id)) {\n      // @ts-ignore - use proposed moveBefore feature\n      if (ctx.pantry.moveBefore) {\n        // @ts-ignore - use proposed moveBefore feature\n        ctx.pantry.moveBefore(node, null);\n      } else {\n        ctx.pantry.insertBefore(node, null);\n      }\n    } else {\n      if (ctx.callbacks.beforeNodeRemoved(node) === false) return;\n      node.parentNode?.removeChild(node);\n      ctx.callbacks.afterNodeRemoved(node);\n    }\n  }\n\n  /**\n   *\n   * @param {Node | null} root\n   * @param {MorphContext} ctx\n   */\n  function restoreFromPantry(root, ctx) {\n    if (root instanceof Element) {\n      Array.from(ctx.pantry.children)\n        .reverse()\n        .forEach((element) => {\n          const matchElement = root.querySelector(`#${element.id}`);\n          if (matchElement) {\n            // @ts-ignore - use proposed moveBefore feature\n            if (matchElement.parentElement?.moveBefore) {\n              // @ts-ignore - use proposed moveBefore feature\n              matchElement.parentElement.moveBefore(element, matchElement);\n              while (matchElement.hasChildNodes()) {\n                // @ts-ignore - use proposed moveBefore feature\n                element.moveBefore(matchElement.firstChild, null);\n              }\n            } else {\n              matchElement.before(element);\n              while (matchElement.firstChild) {\n                element.insertBefore(matchElement.firstChild, null);\n              }\n            }\n            if (\n              ctx.callbacks.beforeNodeMorphed(element, matchElement) !== false\n            ) {\n              syncNodeFrom(matchElement, element, ctx);\n              ctx.callbacks.afterNodeMorphed(element, matchElement);\n            }\n            matchElement.remove();\n          }\n        });\n      ctx.pantry.remove();\n    }\n  }\n\n  //=============================================================================\n  // ID Set Functions\n  //=============================================================================\n\n  /**\n   *\n   * @param {MorphContext} ctx\n   * @param {string} id\n   * @returns {boolean}\n   */\n  function isIdInConsideration(ctx, id) {\n    return !ctx.deadIds.has(id);\n  }\n\n  /**\n   *\n   * @param {MorphContext} ctx\n   * @param {string} id\n   * @param {Node} targetNode\n   * @returns {boolean}\n   */\n  function idIsWithinNode(ctx, id, targetNode) {\n    let idSet = ctx.idMap.get(targetNode) || EMPTY_SET;\n    return idSet.has(id);\n  }\n\n  /**\n   *\n   * @param {MorphContext} ctx\n   * @param {Node} node\n   * @returns {void}\n   */\n  function removeIdsFromConsideration(ctx, node) {\n    let idSet = ctx.idMap.get(node) || EMPTY_SET;\n    for (const id of idSet) {\n      ctx.deadIds.add(id);\n    }\n  }\n\n  /**\n   *\n   * @param {MorphContext} ctx\n   * @param {Node} node\n   * @returns {boolean}\n   */\n  function hasPersistentIdNodes(ctx, node) {\n    for (const id of ctx.idMap.get(node) || EMPTY_SET) {\n      if (ctx.persistentIds.has(id)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   *\n   * @param {MorphContext} ctx\n   * @param {Node} node1\n   * @param {Node} node2\n   * @returns {number}\n   */\n  function getIdIntersectionCount(ctx, node1, node2) {\n    let sourceSet = ctx.idMap.get(node1) || EMPTY_SET;\n    let matchCount = 0;\n    for (const id of sourceSet) {\n      // a potential match is an id in the source and potentialIdsSet, but\n      // that has not already been merged into the DOM\n      if (isIdInConsideration(ctx, id) && idIsWithinNode(ctx, id, node2)) {\n        ++matchCount;\n      }\n    }\n    return matchCount;\n  }\n\n  /**\n   * @param {Element} content\n   * @returns {Element[]}\n   */\n  function nodesWithIds(content) {\n    let nodes = Array.from(content.querySelectorAll(\"[id]\"));\n    if (content.id) {\n      nodes.push(content);\n    }\n    return nodes;\n  }\n\n  /**\n   * A bottom up algorithm that finds all elements with ids in the node\n   * argument and populates id sets for those nodes and all their parents, generating\n   * a set of ids contained within all nodes for the entire hierarchy in the DOM\n   *\n   * @param {Element} node\n   * @param {Map<Node, Set<string>>} idMap\n   */\n  function populateIdMapForNode(node, idMap) {\n    let nodeParent = node.parentElement;\n    for (const elt of nodesWithIds(node)) {\n      /**\n       * @type {Element|null}\n       */\n      let current = elt;\n      // walk up the parent hierarchy of that element, adding the id\n      // of element to the parent's id set\n      while (current !== nodeParent && current != null) {\n        let idSet = idMap.get(current);\n        // if the id set doesn't exist, create it and insert it in the  map\n        if (idSet == null) {\n          idSet = new Set();\n          idMap.set(current, idSet);\n        }\n        idSet.add(elt.id);\n        current = current.parentElement;\n      }\n    }\n  }\n\n  /**\n   * This function computes a map of nodes to all ids contained within that node (inclusive of the\n   * node).  This map can be used to ask if two nodes have intersecting sets of ids, which allows\n   * for a looser definition of \"matching\" than tradition id matching, and allows child nodes\n   * to contribute to a parent nodes matching.\n   *\n   * @param {Element} oldContent  the old content that will be morphed\n   * @param {Element} newContent  the new content to morph to\n   * @returns {Map<Node, Set<string>>} a map of nodes to id sets for the\n   */\n  function createIdMap(oldContent, newContent) {\n    /**\n     *\n     * @type {Map<Node, Set<string>>}\n     */\n    let idMap = new Map();\n    populateIdMapForNode(oldContent, idMap);\n    populateIdMapForNode(newContent, idMap);\n    return idMap;\n  }\n\n  /**\n   * @param {Element} oldContent  the old content that will be morphed\n   * @param {Element} newContent  the new content to morph to\n   * @returns {Set<string>} the id set of all persistent nodes that exist in both old and new content\n   */\n  function createPersistentIds(oldContent, newContent) {\n    const toIdTagName = (node) => node.tagName + \"#\" + node.id;\n    const oldIdSet = new Set(nodesWithIds(oldContent).map(toIdTagName));\n\n    let matchIdSet = new Set();\n    for (const newNode of nodesWithIds(newContent)) {\n      if (oldIdSet.has(toIdTagName(newNode))) {\n        matchIdSet.add(newNode.id);\n      }\n    }\n    return matchIdSet;\n  }\n\n  //=============================================================================\n  // This is what ends up becoming the Idiomorph global object\n  //=============================================================================\n  return {\n    morph,\n    defaults,\n  };\n})();\n\nexport {Idiomorph};\n","\nconst topics: any = {}\nconst _async: any = {}\n\nexport const publish = (name, params) => {\n\t_async[name] = Object.assign({}, _async[name], params)\n\tif (topics[name])\n\t\ttopics[name].forEach(topic => topic(params))\n}\n\nexport const subscribe = (name, method) => {\n\ttopics[name] = topics[name] || []\n\ttopics[name].push(method)\n\tif (name in _async) {\n\t\tmethod(_async[name])\n\t}\n\treturn () => {\n\t\ttopics[name] = topics[name].filter( fn => fn != method )\n\t}\n}\n","import { safe, rAF, g } from './utils'\nimport { Idiomorph } from 'idiomorph/dist/idiomorph.esm'\nimport { publish, subscribe } from './utils/pubsub'\n\nexport const Component = ({ name, module, dependencies, node, templates, signal }) => {\n\tconst _model \t\t= module.model || {}\n\tconst initialState \t= (new Function( `return ${node.getAttribute('html-model') || '{}'}`))()\n\tconst tplid \t\t= node.getAttribute('tplid')\n\tconst scopeid \t\t= node.getAttribute('html-scope-id')\n\tconst tpl \t\t\t= templates[ tplid ]\n\tconst data \t\t\t= g.scope[ scopeid ]\n\tconst model  \t\t= module?.model?.apply ? _model({ elm:node, initialState }) : _model\n\tconst state \t\t= Object.assign({}, data, model, initialState)\n\tconst view \t\t\t= module.view? module.view : (data) => data\n\n\tlet updates \t\t= []\n\n\tconst base = {\n\t\tname,\n\t\tmodel,\n\t\telm: node,\n\t\ttemplate: tpl.template,\n\t\tdependencies,\n\t\tpublish,\n\t\tsubscribe,\n\n\t\tmain(fn) {\n\t\t\tnode.addEventListener(':mount', fn)\n\t\t},\n\n\t\t/**\n\t\t * @State\n\t\t */\n\t\tstate : {\n\n\t\t\tsave(data) {\n\t\t\t\tif( data.constructor === Function ) {\n\t\t\t\t\tdata( state )\n\t\t\t\t} else {\n\t\t\t\t\tObject.assign(state, data)\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tset( data ) {\n\n\t\t\t\tif (!document.body.contains(node)) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tif( data.constructor === Function ) {\n\t\t\t\t\tdata( state )\n\t\t\t\t}\n\t\t\t\tconst newstate = Object.assign({}, state)\n\t\t\t\trender( newstate )\n\n\t\t\t\tupdates.push(data)\n\n\t\t\t\treturn new Promise((resolve) => {\n\t\t\t\t\trAF(() => rAF(() => {\n\t\t\t\t\t\tObject.assign.apply(null, [state, ...updates ])\n\t\t\t\t\t\tif( updates.length ){\n\t\t\t\t\t\t\tconst newstate = Object.assign({}, state)\n\t\t\t\t\t\t\trender(newstate)\n\t\t\t\t\t\t\tresolve(newstate)\n\t\t\t\t\t\t\tupdates = []\n\t\t\t\t\t\t}\n\t\t\t\t\t}))\n\t\t\t\t})\n\t\t\t},\n\n\t\t\tget() {\n\t\t\t\treturn Object.assign({}, state)\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * @Events\n\t\t */\n\t\ton( ev, selectorOrCallback, callback ) {\n\n\t\t\tif( callback ) {\n\t\t\t\tcallback.handler = (e) => {\n\t\t\t\t\tconst detail = e.detail || {}\n\t\t\t\t\tlet parent = e.target\n\t\t\t\t\twhile (parent) {\n\t\t\t\t\t\tif (parent.matches(selectorOrCallback)) {\n\t\t\t\t\t\t\te.delegateTarget = parent\n\t\t\t\t\t\t\tcallback.apply(node, [e].concat(detail.args))\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (parent === node) break\n\t\t\t\t\t\tparent = parent.parentNode\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnode.addEventListener(ev, callback.handler, {\n\t\t\t\t\tsignal,\n\t\t\t\t\tcapture: (ev == 'focus' || ev == 'blur' || ev == 'mouseenter' || ev == 'mouseleave')\n\t\t\t\t})\n\n\t\t\t} else {\n\t\t\t\tselectorOrCallback.handler = (e) => {\n\t\t\t\t\te.delegateTarget = node\n\t\t\t\t\tselectorOrCallback.apply(node, [e].concat(e.detail.args))\n\t\t\t\t}\n\t\t\t\tnode.addEventListener(ev, selectorOrCallback.handler, { signal })\n\t\t\t}\n\t\t},\n\n\t\toff( ev, callback ) {\n\t\t\tif( callback.handler ) {\n\t\t\t\tnode.removeEventListener(ev, callback.handler)\n\t\t\t}\n\t\t},\n\n\t\ttrigger(ev, selectorOrCallback, data) {\n\t\t\tif( selectorOrCallback.constructor === String ) {\n\t\t\t\tArray\n\t\t\t\t\t.from(node.querySelectorAll(selectorOrCallback))\n\t\t\t\t\t.forEach( children => {\n\t\t\t\t\t\tchildren.dispatchEvent(new CustomEvent(ev, { bubbles: true, detail: { args: data } }) )\n\t\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tnode.dispatchEvent(new CustomEvent(ev, { bubbles: true, detail:{ args: data } }))\n\t\t\t}\n\t\t},\n\n\t\temit(ev, data) {\n\t\t\tnode.dispatchEvent(new CustomEvent(ev, { bubbles: true, detail: { args: data } }))\n\t\t},\n\n\t\tunmount( fn ) {\n\t\t\tnode.addEventListener(':unmount', fn)\n\t\t},\n\n\t\tinnerHTML ( target, html_ ) {\n\t\t\tconst element = html_? target : elm\n\t\t\tconst clone = element.cloneNode()\n\t\t\tconst html = html_? html_ : target\n\t\t\tclone.innerHTML = html\n\n\t\t\trAF( _ => Idiomorph.morph(element, clone, IdiomorphOptions) )\n\t\t}\n\t}\n\n\tconst render = ( data ) => {\n\n\t\tconst html = tpl.render.call( view(data), node, safe, g )\n\t\tIdiomorph.morph( node, html, IdiomorphOptions(node) )\n\n\t\tnode.querySelectorAll('[tplid]').forEach((element) => {\n\t\t\tif(!element.base) return\n\t\t\tconst base = element.base\n\t\t\tconst props = Object.keys(base.model).reduce((acc, key) => {\n\t\t\t\tif( key in data ) {\n\t\t\t\t\tif( !acc ) acc = {}\n\t\t\t\t\tacc[key] = data[key]\n\t\t\t\t}\n\t\t\t\treturn acc\n\t\t\t}, null)\n\t\t\tif( props ) {\n\t\t\t\tbase.state.set( props )\n\t\t\t}\n\t\t})\n\t\trAF(() => g.scope = {})\n\t}\n\n\tnode.base = base\n\tmodule.default( base )\n}\n\nconst IdiomorphOptions = ( parent ) => ({\n\tcallbacks: {\n\t\tbeforeNodeMorphed( node ) {\n\t\t\tif( node.nodeType === 1 ) {\n\t\t\t\tif( 'html-static' in node.attributes ) {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\tif( node.base && node !== parent ) {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n})\n","import { Component } from './component'\n\nexport const Element = ({ component, templates, start }) => {\n\n\tconst { name, module, dependencies } = component\n\tconst abortController = new AbortController()\n\n\treturn class extends HTMLElement {\n\n\t\tconstructor() {\n\t\t\tsuper()\n\t\t}\n\n\t\tconnectedCallback() {\n\n\t\t\tif( !this.getAttribute('tplid') ) {\n\t\t\t\tstart( this.parentNode )\n\t\t\t}\n\n\t\t\tComponent({\n\t\t\t\tnode:this,\n\t\t\t\tname,\n\t\t\t\tmodule,\n\t\t\t\tdependencies,\n\t\t\t\ttemplates,\n\t\t\t\tsignal: abortController.signal\n\t\t\t})\n\n\t\t\tthis.dispatchEvent( new CustomEvent(':mount') )\n\t\t\tthis.base.state.set({})\n\n\t\t}\n\n\t\tdisconnectedCallback() {\n\t\t\tthis.dispatchEvent( new CustomEvent(':unmount') )\n\t\t\tabortController.abort()\n\t\t\tdelete this.base\n\t\t}\n\t}\n}\n","import { uuid, decodeHTML } from './utils'\n\nconst templates  = {}\n\nconst config = {\n\ttags: ['{{', '}}']\n}\n\nexport const templateConfig = (newconfig) => {\n\tObject.assign( config, newconfig )\n}\n\nexport const template = ( target, { components }) => {\n\n\ttagElements( target, [...Object.keys( components ), 'template'] )\n\tconst clone = target.cloneNode( true )\n\n\ttransformTemplate( clone )\n\tremoveTemplateTagsRecursively( clone )\n\tsetTemplates( clone, components )\n\n\treturn templates\n}\n\nexport const compile = ( outerHTML ) => {\n\n\tconst html = transformAttributes( outerHTML )\n\tconst parsedHtml = JSON.stringify( html )\n\n\treturn new Function('$element', 'safe', '$g',`\n\t\tvar $data = this;\n\t\twith( $data ){\n\t\t\tvar output=${parsedHtml\n\t\t\t\t.replace(/%%_=(.+?)_%%/g, function(_, variable){\n\t\t\t\t\treturn '\"+safe(function(){return '+ variable +';})+\"'\n\t\t\t\t})\n\t\t\t\t.replace(/%%_(.+?)_%%/g, function(_, variable){\n\t\t\t\t\treturn '\";' + variable +'\\noutput+=\"'\n\t\t\t\t})};return output;\n\t\t}\n\t`)\n}\n\nconst tagElements = ( target, keys ) => {\n\ttarget\n\t\t.querySelectorAll( keys.toString() )\n\t\t.forEach((node) => {\n\t\t\tif( node.localName === 'template' ) {\n\t\t\t\treturn tagElements( node.content, keys )\n\t\t\t}\n\t\t\tnode.setAttribute('tplid', uuid())\n\t\t})\n}\n\nconst transformAttributes = ( html ) => {\n\n\tconst regexTags = new RegExp(`\\\\${config.tags[0]}(.+?)\\\\${config.tags[1]}`, 'g')\n\n\treturn html\n\t\t.replace(/jails___scope-id/g, '%%_=$scopeid_%%')\n\t\t.replace(regexTags, '%%_=$1_%%')\n\t\t// Booleans\n\t\t// https://meiert.com/en/blog/boolean-attributes-of-html/\n\t\t.replace(/html-(allowfullscreen|async|autofocus|autoplay|checked|controls|default|defer|disabled|formnovalidate|inert|ismap|itemscope|loop|multiple|muted|nomodule|novalidate|open|playsinline|readonly|required|reversed|selected)=\\\"(.*?)\\\"/g, `%%_if(safe(function(){ return $2 })){_%%$1%%_}_%%`)\n\t\t// The rest\n\t\t.replace(/html-(.*?)=\\\"(.*?)\\\"/g, (all, key, value) => {\n\t\t\tif (key === 'key' || key === 'model' || key === 'scope-id' ) {\n\t\t\t\treturn all\n\t\t\t}\n\t\t\tif (value) {\n\t\t\t\tvalue = value.replace(/^{|}$/g, '')\n\t\t\t\treturn `${key}=\"%%_=safe(function(){ return ${value} })_%%\"`\n\t\t\t} else {\n\t\t\t\treturn all\n\t\t\t}\n\t\t})\n}\n\nconst transformTemplate = ( clone ) => {\n\n\tclone.querySelectorAll('template, [html-for], [html-if], [html-inner], [html-class]')\n\t\t.forEach(( element ) => {\n\n\t\t\tconst htmlFor \t= element.getAttribute('html-for')\n\t\t\tconst htmlIf \t= element.getAttribute('html-if')\n\t\t\tconst htmlInner = element.getAttribute('html-inner')\n\t\t\tconst htmlClass = element.getAttribute('html-class')\n\n\t\t\tif ( htmlFor ) {\n\n\t\t\t\telement.removeAttribute('html-for')\n\n\t\t\t\tconst split \t= htmlFor.match(/(.*)\\sin\\s(.*)/) || ''\n\t\t\t\tconst varname \t= split[1]\n\t\t\t\tconst object \t= split[2]\n\t\t\t\tconst open \t\t= document.createTextNode(`%%_  ;(function(){ var $index = 0; for(var $key in safe(function(){ return ${object} }) ){ var $scopeid = Math.random().toString(36).substring(2, 9); var ${varname} = ${object}[$key]; $g.scope[$scopeid] = { ${varname} :${varname}, ${object}: ${object}, $index: $index, $key: $key }; _%%`)\n\t\t\t\tconst close \t= document.createTextNode(`%%_ $index++; } })() _%%`)\n\n\t\t\t\twrap(open, element, close)\n\t\t\t}\n\n\t\t\tif (htmlIf) {\n\t\t\t\telement.removeAttribute('html-if')\n\t\t\t\tconst open = document.createTextNode(`%%_ if ( safe(function(){ return ${htmlIf} }) ){ _%%`)\n\t\t\t\tconst close = document.createTextNode(`%%_ } _%%`)\n\t\t\t\twrap(open, element, close)\n\t\t\t}\n\n\t\t\tif (htmlInner) {\n\t\t\t\telement.removeAttribute('html-inner')\n\t\t\t\telement.innerHTML = `%%_=${htmlInner}_%%`\n\t\t\t}\n\n\t\t\tif (htmlClass) {\n\t\t\t\telement.removeAttribute('html-class')\n\t\t\t\telement.className = (element.className + ` %%_=${htmlClass}_%%`).trim()\n\t\t\t}\n\n\t\t\tif( element.localName === 'template' ) {\n\t\t\t\ttransformTemplate(element.content)\n\t\t\t}\n\t\t})\n}\n\nconst setTemplates = ( clone, components ) => {\n\n\tArray.from(clone.querySelectorAll('[tplid]'))\n\t\t.reverse()\n\t\t.forEach((node) => {\n\n\t\t\tconst tplid = node.getAttribute('tplid')\n\t\t\tconst name  = node.localName\n\t\t\tnode.setAttribute('html-scope-id', 'jails___scope-id')\n\n\t\t\tif( name in components && components[name].module.template ) {\n\t\t\t\tconst children = node.innerHTML\n\t\t\t\tconst html = components[name].module.template({ elm:node, children })\n\n\t\t\t\tif( html.constructor === Promise ) {\n\t\t\t\t\thtml.then( htmlstring => {\n\t\t\t\t\t\tnode.innerHTML = htmlstring\n\t\t\t\t\t\tconst html = node.outerHTML\n\t\t\t\t\t\ttemplates[tplid] = {\n\t\t\t\t\t\t\ttemplate: html,\n\t\t\t\t\t\t\trender: compile(html)\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t} else {\n\t\t\t\t\tnode.innerHTML = html\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst html = node.outerHTML\n\n\t\t\ttemplates[ tplid ] = {\n\t\t\t\ttemplate: html,\n\t\t\t\trender\t: compile(html)\n\t\t\t}\n\t\t})\n}\n\nconst removeTemplateTagsRecursively = (node) => {\n\n\t// Get all <template> elements within the node\n\tconst templates = node.querySelectorAll('template')\n\n\ttemplates.forEach((template) => {\n\n\t\tif( template.getAttribute('html-if') || template.getAttribute('html-inner') ) {\n\t\t\treturn\n\t\t}\n\n\t\t// Process any nested <template> tags within this <template> first\n\t\tremoveTemplateTagsRecursively(template.content)\n\n\t\t// Get the parent of the <template> tag\n\t\tconst parent = template.parentNode\n\n\t\tif (parent) {\n\t\t\t// Move all child nodes from the <template>'s content to its parent\n\t\t\tconst content = template.content\n\t\t\twhile (content.firstChild) {\n\t\t\t\tparent.insertBefore(content.firstChild, template)\n\t\t\t}\n\t\t\t// Remove the <template> tag itself\n\t\t\tparent.removeChild(template)\n\t\t}\n\t})\n}\n\nconst wrap = (open, node, close) => {\n\tnode.parentNode?.insertBefore(open, node)\n\tnode.parentNode?.insertBefore(close, node.nextSibling)\n}\n","import { Element } from './element'\nimport { template, templateConfig as config } from './template-system'\n\nconst components = {}\n\nexport { publish, subscribe } from './utils/pubsub'\n\nexport const templateConfig = (options) => {\n\tconfig( options )\n}\n\nexport const register = ( name, module, dependencies ) => {\n\tcomponents[ name ] = { name, module, dependencies }\n}\n\nexport const start = ( target = document.body ) => {\n\n\tconst templates = template( target, { components } )\n\n\tObject\n\t\t.values( components )\n\t\t.forEach(({ name, module, dependencies }) => {\n\t\t\tif( !customElements.get(name) ) {\n\t\t\t\tcustomElements.define( name, Element({ component: { name, module, dependencies }, templates, start }) )\n\t\t\t}\n\t})\n}\n"],"names":["document","createElement","g","scope","rAF","fn","requestAnimationFrame","setTimeout","safe","execute","val","err","Idiomorph","EMPTY_SET","Set","defaults","morphStyle","callbacks","beforeNodeAdded","noOp","afterNodeAdded","beforeNodeMorphed","afterNodeMorphed","beforeNodeRemoved","afterNodeRemoved","beforeAttributeUpdated","beforeNodePantried","head","style","shouldPreserve","elt","getAttribute","shouldReAppend","shouldRemove","afterHeadMorphed","morphNormalizedContent","oldNode","normalizedNewContent","ctx","block","oldHead","querySelector","newHead","promises","handleHeadElement","Promise","all","then","Object","assign","ignore","morphChildren","config","twoPass","restoreFromPantry","Array","from","children","bestMatch","newContent","currentElement","firstChild","bestElement","score","newScore","scoreElement","nextSibling","findBestNodeMatch","previousSibling","_a","_b","morphedNode","morphOldNodeTo","elements","stack","added","push","node","pop","parentElement","insertBefore","length","insertSiblings","parentNode","ignoreValueOfActiveElement","possibleActiveElement","ignoreActiveValue","activeElement","body","ignoreActive","removeChild","isSoftMatch","HTMLHeadElement","syncNodeFrom","replaceChild","newParent","oldParent","HTMLTemplateElement","content","newChild","nextNewChild","insertionPoint","persistentIds","has","id","appendChild","removeIdsFromConsideration","isIdSetMatch","idSetMatch","findIdSetMatch","removeNodesBetween","softMatch","findSoftMatch","tempNode","removeNode","ignoreAttribute","attr","to","updateType","type","nodeType","fromEl","toEl","fromAttributes","attributes","toAttributes","fromAttribute","name","value","setAttribute","i","toAttribute","hasAttribute","removeAttribute","nodeValue","HTMLInputElement","fromValue","toValue","syncBooleanAttribute","HTMLOptionElement","HTMLTextAreaElement","syncInputValue","attributeName","Element","fromLiveValue","ignoreUpdate","newHeadTag","currentHead","removed","preserved","nodesToAppend","headMergeStyle","srcToNewHeadNodes","Map","newHeadChild","set","outerHTML","currentHeadElt","inNewContent","isReAppended","isPreserved","delete","values","newNode","newElt","createRange","createContextualFragment","href","src","resolve","promise","_resolve","addEventListener","removedElement","kept","createPantry","pantry","hidden","insertAdjacentElement","node1","node2","tagName","getIdIntersectionCount","startInclusive","endExclusive","cursor","newChildPotentialIdCount","potentialMatch","otherMatchCount","potentialSoftMatch","siblingSoftMatchCount","generatedByIdiomorph","WeakSet","idMap","get","hasPersistentIdNodes","moveToPantry","childNodes","forEach","child","moveBefore","root","reverse","element","matchElement","hasChildNodes","before","remove","isIdInConsideration","deadIds","idIsWithinNode","targetNode","idSet","add","sourceSet","matchCount","nodesWithIds","nodes","querySelectorAll","populateIdMapForNode","nodeParent","current","createIdMap","oldContent","createPersistentIds","toIdTagName","oldIdSet","map","matchIdSet","morph","Document","documentElement","parser","DOMParser","contentWithSvgsRemoved","replace","match","parseFromString","htmlElement","parseContent","normalizedContent","Node","dummyParent","append","normalizeContent","mergedConfig","finalConfig","mergeDefaults","target","createMorphContext","topics","_async","publish","params","topic","subscribe","method","filter","IdiomorphOptions","parent","base","component","templates","start","module","dependencies","abortController","AbortController","HTMLElement","constructor","super","connectedCallback","this","signal","_model","model","initialState","Function","tplid","scopeid","tpl","data","apply","elm","state","view","updates","template","main","save","contains","newstate","render","on","ev","selectorOrCallback","callback","handler","e","detail","matches","delegateTarget","concat","args","capture","off","removeEventListener","trigger","String","dispatchEvent","CustomEvent","bubbles","emit","unmount","innerHTML","html_","clone","cloneNode","html","call","props","keys","reduce","acc","key","base2","default","Component","disconnectedCallback","abort","tags","compile","transformAttributes","parsedHtml","JSON","stringify","_","variable","tagElements","toString","localName","Math","random","substring","regexTags","RegExp","transformTemplate","htmlFor","htmlIf","htmlInner","htmlClass","split","varname","object","open","createTextNode","close","wrap","className","trim","setTemplates","components","html2","htmlstring","removeTemplateTagsRecursively","customElements","define","options","newconfig"],"mappings":"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","x_google_ignoreList":[1]}