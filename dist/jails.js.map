{"version":3,"file":"jails.js","sources":["../src/transpile.ts","../src/utils/index.ts","../src/template-system.ts","../src/utils/pubsub.ts","../src/utils/idiomorph.ts","../src/utils/events.ts","../src/component.ts","../src/element.ts","../src/index.ts"],"sourcesContent":["const parser = new DOMParser()\n\nexport default function Transpile(html, config) {\n\n\tconst regexTags = new RegExp(`\\\\${config.tags[0]}(.+?)\\\\${config.tags[1]}`, 'g')\n\tconst virtual = parser.parseFromString(html.replace(/<\\/?template[^>]*>/g, ''), 'text/html')\n\n\tvirtual.querySelectorAll('[html-for], [html-if], [html-inner], [html-class], [html-model]').forEach((element) => {\n\n\t\tconst htmlForeach = element.getAttribute('html-foreach')\n\t\tconst htmlFor \t= element.getAttribute('html-for')\n\t\tconst htmlIf \t= element.getAttribute('html-if')\n\t\tconst htmlInner = element.getAttribute('html-inner')\n\t\tconst htmlClass = element.getAttribute('html-class')\n\t\tconst forEachInstruction = htmlFor || htmlForeach\n\n\t\tif ( forEachInstruction ) {\n\t\t\tconst selector = htmlFor? 'html-for': 'html-foreach'\n\t\t\tconst split = forEachInstruction.match(/(.*)\\sin\\s(.*)/) || ''\n\t\t\tconst varname = split[1]\n\t\t\tconst object = split[2]\n\n\t\t\telement.removeAttribute(selector)\n\t\t\telement.setAttribute('scope', '')\n\t\t\tconst script = document.createElement('script')\n\n\t\t\tscript.dataset.scope = ''\n\t\t\tscript.type = 'text/html'\n\t\t\tscript.text = `%%_= $scope _%%`\n\n\t\t\telement.appendChild( script )\n\n\t\t\tconst open = document.createTextNode(`%%_(function(){ var $index = 0; for(var $key in safe(function(){ return ${object} }) ){ var ${varname} = ${object}[$key]; var $scope = JSON.stringify({ '${varname}':${varname}, $index: $index, $key:$key }); _%%`)\n\t\t\tconst close = document.createTextNode(`%%_ $index++; } })() _%%`)\n\t\t\twrap(open, element, close)\n\t\t}\n\t\tif (htmlIf) {\n\t\t\telement.removeAttribute('html-if')\n\t\t\tconst open = document.createTextNode(`%%_ if ( safe(function(){ return ${htmlIf} }) ){ _%%`)\n\t\t\tconst close = document.createTextNode(`%%_ } _%%`)\n\t\t\twrap(open, element, close)\n\t\t}\n\t\tif (htmlInner) {\n\t\t\telement.removeAttribute('html-inner')\n\t\t\telement.innerHTML = `%%_=${htmlInner}_%%`\n\t\t}\n\t\tif (htmlClass) {\n\t\t\telement.removeAttribute('html-class')\n\t\t\telement.className = (element.className + ` %%_=${htmlClass}_%%`).trim()\n\t\t}\n\t})\n\n\n\treturn (\n\t\tvirtual.body.innerHTML\n\t\t\t.replace(regexTags, '%%_=$1_%%')\n\t\t\t// Booleans\n\t\t\t// https://meiert.com/en/blog/boolean-attributes-of-html/\n\t\t\t.replace(/html-(allowfullscreen|async|autofocus|autoplay|checked|controls|default|defer|disabled|formnovalidate|inert|ismap|itemscope|loop|multiple|muted|nomodule|novalidate|open|playsinline|readonly|required|reversed|selected)=\\\"(.*?)\\\"/g, `%%_if(safe(function(){ return $2 })){_%%$1%%_}_%%`)\n\t\t\t// The rest\n\t\t\t.replace(/html-(.*?)=\\\"(.*?)\\\"/g, (all, key, value) => {\n\t\t\t\tif (key === 'key' || key === 'model' || key == 'scope') {\n\t\t\t\t\treturn all\n\t\t\t\t}\n\t\t\t\tif (value) {\n\t\t\t\t\tvalue = value.replace(/^{|}$/g, '')\n\t\t\t\t\treturn `${key}=\"%%_=safe(function(){ return ${value} })_%%\"`\n\t\t\t\t} else {\n\t\t\t\t\treturn all\n\t\t\t\t}\n\t\t\t})\n\t)\n}\n\nconst wrap = (open, node, close) => {\n\tnode.parentNode?.insertBefore(open, node)\n\tnode.parentNode?.insertBefore(close, node.nextSibling)\n}\n","const textarea = document.createElement('textarea')\n\nexport const decodeHTML = (text) => {\n\ttextarea.innerHTML = text\n\treturn textarea.value\n}\n\nexport const rAF = (fn) => {\n\tif (requestAnimationFrame)\n\t\treturn requestAnimationFrame(fn)\n\telse\n\t\treturn setTimeout(fn, 1000 / 60)\n}\n\nexport const uuid = () => {\n\treturn 'xxxxxxxx'.replace(/[xy]/g, (c) => {\n\t\tconst r = Math.random() * 8 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8)\n\t\treturn v.toString(8)\n\t})\n}\n\n\nexport const dup = (o) => {\n\treturn JSON.parse(JSON.stringify(o))\n}\n\n// http://crockford.com/javascript/memory/leak.html\nexport const purge = (d) => {\n\tvar a = d.attributes, i, l, n\n\tif (a) {\n\t\tfor (i = a.length - 1; i >= 0; i -= 1) {\n\t\t\tn = a[i].name\n\t\t\tif (typeof d[n] === 'function') {\n\t\t\t\td[n] = null\n\t\t\t}\n\t\t}\n\t}\n\ta = d.childNodes\n\tif (a) {\n\t\tl = a.length\n\t\tfor (i = 0; i < l; i += 1) {\n\t\t\tpurge(d.childNodes[i])\n\t\t}\n\t}\n}\n\nexport const safe = (execute, val) => {\n\ttry{return execute()}catch(err){return val || ''}\n}\n\n// From\n// https://2ality.com/2015/01/template-strings-html.html#comment-2078932192\nexport const html = (literalSections, ...substs) => {\n\n\t// Use raw literal sections: we donâ€™t want\n\t// backslashes (\\n etc.) to be interpreted\n\tlet raw = literalSections.raw\n\n\tlet result = ''\n\n\tsubsts.forEach((subst, i) => {\n\t\t// Retrieve the literal section preceding\n\t\t// the current substitution\n\t\tlet lit = raw[i]\n\n\t\t// In the example, map() returns an array:\n\t\t// If substitution is an array (and not a string),\n\t\t// we turn it into a string\n\t\tif (Array.isArray(subst)) {\n\t\t\tsubst = subst.join('')\n\t\t}\n\n\t\tresult += lit\n\t\tresult += subst\n\t})\n\t// Take care of last literal section\n\t// (Never fails, because an empty template string\n\t// produces one literal section, an empty string)\n\tresult += raw[raw.length-1] // (A)\n\n\treturn result\n}\n","import Transpile from './transpile'\nimport { uuid, decodeHTML } from './utils'\n\nconst config = {\n\ttags: ['${', '}']\n}\n\nexport const templateConfig = (newconfig) => {\n\tObject.assign(config, newconfig)\n}\n\nexport default function Template(element) {\n\n\tconst html = Transpile(element.outerHTML, config)\n\tconst decodedHTML  = JSON.stringify(html)\n\n\treturn new Function('$element', 'safe',`\n\t\tvar $data = this;\n\t\twith( $data ){\n\t\t\tvar output=${decodedHTML\n\t\t\t\t.replace(/%%_=(.+?)_%%/g, function(_, variable){\n\t\t\t\t\treturn '\"+safe(function(){return '+decodeHTML(variable)+';})+\"'\n\t\t\t\t})\n\t\t\t\t.replace(/%%_(.+?)_%%/g, function(_, variable){\n\t\t\t\t\treturn '\";' + decodeHTML(variable) +'\\noutput+=\"'\n\t\t\t\t})};return output;\n\t\t}\n\t`)\n}\n\nexport const buildtemplates = ( target, selector, templates, components ) => {\n\t[]\n\t\t.concat( target.matches? (target.matches(selector)? target : []) : [] )\n\t\t.concat( Array.from(target.querySelectorAll( selector )) )\n\t\t.reverse()\n\t\t.forEach( (node:HTMLElement) => {\n\t\t\tnode.querySelectorAll('template').forEach( template => buildtemplates(template.content, selector, templates, components ))\n\t\t\tcreateTemplateId(node, templates, components)\n\t\t})\n}\n\nconst createTemplateId = (element, templates, components ) => {\n\n\tconst tplid = element.getAttribute('tplid')\n\n\tif (!tplid) {\n\t\tconst id = uuid()\n\t\telement.setAttribute('tplid', id)\n\t\tconst name = element.localName\n\n\t\tif( name in components && components[name].module.template ) {\n\t\t\tconst html = components[name].module.template()\n\t\t\tif( html.constructor === Promise ) {\n\t\t\t\telement.__template = html\n\t\t\t\thtml.then( htmlstring => {\n\t\t\t\t\telement.innerHTML = htmlstring\n\t\t\t\t\ttemplates[id] = Template(element)\n\t\t\t\t})\n\t\t\t}else {\n\t\t\t\telement.innerHTML = html\n\t\t\t}\n\t\t}\n\t\ttemplates[id] = Template(element)\n\t}\n}\n\n","const topics: any = {}\nconst _async: any = {}\n\nexport const publish = (name, params) => {\n\t_async[name] = Object.assign({}, _async[name], params)\n\tif (topics[name])\n\t\ttopics[name].forEach(topic => topic(params))\n}\n\nexport const subscribe = (name, method) => {\n\ttopics[name] = topics[name] || []\n\ttopics[name].push(method)\n\tif (name in _async) {\n\t\tmethod(_async[name])\n\t}\n\treturn () => {\n\t\ttopics[name] = topics[name].filter( fn => fn != method )\n\t}\n}\n\n","/**\n * BSD 2-Clause License\n * https://github.com/bigskysoftware/idiomorph\n\n\tCopyright (c) 2022, Big Sky Software\n\tAll rights reserved.\n\n\tRedistribution and use in source and binary forms, with or without\n\tmodification, are permitted provided that the following conditions are met:\n\n\t1. Redistributions of source code must retain the above copyright notice, this\n\tlist of conditions and the following disclaimer.\n\n\t2. Redistributions in binary form must reproduce the above copyright notice,\n\tthis list of conditions and the following disclaimer in the documentation\n\tand/or other materials provided with the distribution.\n\n\tTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n\tAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n\tIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n\tDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n\tFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n\tDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n\tSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n\tCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n\tOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\tOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n// base IIFE to define idiomorph\n\n\nexport const Idiomorph = (function () {\n\t'use strict';\n\n\t//=============================================================================\n\t// AND NOW IT BEGINS...\n\t//=============================================================================\n\tlet EMPTY_SET = new Set();\n\n\t// default configuration values, updatable by users now\n\tlet defaults = {\n\t\tmorphStyle: \"outerHTML\",\n\t\tcallbacks : {\n\t\t\tbeforeNodeAdded: noOp,\n\t\t\tafterNodeAdded: noOp,\n\t\t\tbeforeNodeMorphed: noOp,\n\t\t\tafterNodeMorphed: noOp,\n\t\t\tbeforeNodeRemoved: noOp,\n\t\t\tafterNodeRemoved: noOp,\n\t\t\tbeforeAttributeUpdated: noOp,\n\n\t\t},\n\t\thead: {\n\t\t\tstyle: 'merge',\n\t\t\tshouldPreserve: function (elt) {\n\t\t\t\treturn elt.getAttribute(\"im-preserve\") === \"true\";\n\t\t\t},\n\t\t\tshouldReAppend: function (elt) {\n\t\t\t\treturn elt.getAttribute(\"im-re-append\") === \"true\";\n\t\t\t},\n\t\t\tshouldRemove: noOp,\n\t\t\tafterHeadMorphed: noOp,\n\t\t}\n\t};\n\n\t//=============================================================================\n\t// Core Morphing Algorithm - morph, morphNormalizedContent, morphOldNodeTo, morphChildren\n\t//=============================================================================\n\tfunction morph(oldNode, newContent, config = {}) {\n\n\t\tif (oldNode instanceof Document) {\n\t\t\toldNode = oldNode.documentElement;\n\t\t}\n\n\t\tif (typeof newContent === 'string') {\n\t\t\tnewContent = parseContent(newContent);\n\t\t}\n\n\t\tlet normalizedContent = normalizeContent(newContent);\n\n\t\tlet ctx = createMorphContext(oldNode, normalizedContent, config);\n\n\t\treturn morphNormalizedContent(oldNode, normalizedContent, ctx);\n\t}\n\n\tfunction morphNormalizedContent(oldNode, normalizedNewContent, ctx) {\n\t\tif (ctx.head.block) {\n\t\t\tlet oldHead = oldNode.querySelector('head');\n\t\t\tlet newHead = normalizedNewContent.querySelector('head');\n\t\t\tif (oldHead && newHead) {\n\t\t\t\tlet promises = handleHeadElement(newHead, oldHead, ctx);\n\t\t\t\t// when head promises resolve, call morph again, ignoring the head tag\n\t\t\t\tPromise.all(promises).then(function () {\n\t\t\t\t\tmorphNormalizedContent(oldNode, normalizedNewContent, Object.assign(ctx, {\n\t\t\t\t\t\thead: {\n\t\t\t\t\t\t\tblock: false,\n\t\t\t\t\t\t\tignore: true\n\t\t\t\t\t\t}\n\t\t\t\t\t}));\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (ctx.morphStyle === \"innerHTML\") {\n\n\t\t\t// innerHTML, so we are only updating the children\n\t\t\tmorphChildren(normalizedNewContent, oldNode, ctx);\n\t\t\treturn oldNode.children;\n\n\t\t} else if (ctx.morphStyle === \"outerHTML\" || ctx.morphStyle == null) {\n\t\t\t// otherwise find the best element match in the new content, morph that, and merge its siblings\n\t\t\t// into either side of the best match\n\t\t\tlet bestMatch = findBestNodeMatch(normalizedNewContent, oldNode, ctx);\n\n\t\t\t// stash the siblings that will need to be inserted on either side of the best match\n\t\t\tlet previousSibling = bestMatch?.previousSibling;\n\t\t\tlet nextSibling = bestMatch?.nextSibling;\n\n\t\t\t// morph it\n\t\t\tlet morphedNode = morphOldNodeTo(oldNode, bestMatch, ctx);\n\n\t\t\tif (bestMatch) {\n\t\t\t\t// if there was a best match, merge the siblings in too and return the\n\t\t\t\t// whole bunch\n\t\t\t\treturn insertSiblings(previousSibling, morphedNode, nextSibling);\n\t\t\t} else {\n\t\t\t\t// otherwise nothing was added to the DOM\n\t\t\t\treturn []\n\t\t\t}\n\t\t} else {\n\t\t\tthrow \"Do not understand how to morph style \" + ctx.morphStyle;\n\t\t}\n\t}\n\n\n\t/**\n\t * @param possibleActiveElement\n\t * @param ctx\n\t * @returns {boolean}\n\t */\n\tfunction ignoreValueOfActiveElement(possibleActiveElement, ctx) {\n\t\treturn ctx.ignoreActiveValue && possibleActiveElement === document.activeElement;\n\t}\n\n\t/**\n\t * @param oldNode root node to merge content into\n\t * @param newContent new content to merge\n\t * @param ctx the merge context\n\t * @returns {Element} the element that ended up in the DOM\n\t */\n\tfunction morphOldNodeTo(oldNode, newContent, ctx) {\n\t\tif (ctx.ignoreActive && oldNode === document.activeElement) {\n\t\t\t// don't morph focused element\n\t\t} else if (newContent == null) {\n\t\t\tif (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return oldNode;\n\n\t\t\toldNode.remove();\n\t\t\tctx.callbacks.afterNodeRemoved(oldNode);\n\t\t\treturn null;\n\t\t} else if (!isSoftMatch(oldNode, newContent)) {\n\t\t\tif (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return oldNode;\n\t\t\tif (ctx.callbacks.beforeNodeAdded(newContent) === false) return oldNode;\n\n\t\t\toldNode.parentElement.replaceChild(newContent, oldNode);\n\t\t\tctx.callbacks.afterNodeAdded(newContent);\n\t\t\tctx.callbacks.afterNodeRemoved(oldNode);\n\t\t\treturn newContent;\n\t\t} else {\n\t\t\tif (ctx.callbacks.beforeNodeMorphed(oldNode, newContent) === false) return oldNode;\n\n\t\t\tif (oldNode instanceof HTMLHeadElement && ctx.head.ignore) {\n\t\t\t\t// ignore the head element\n\t\t\t} else if (oldNode instanceof HTMLHeadElement && ctx.head.style !== \"morph\") {\n\t\t\t\thandleHeadElement(newContent, oldNode, ctx);\n\t\t\t} else {\n\t\t\t\tsyncNodeFrom(newContent, oldNode, ctx);\n\t\t\t\tif (!ignoreValueOfActiveElement(oldNode, ctx)) {\n\t\t\t\t\tmorphChildren(newContent, oldNode, ctx);\n\t\t\t\t}\n\t\t\t}\n\t\t\tctx.callbacks.afterNodeMorphed(oldNode, newContent);\n\t\t\treturn oldNode;\n\t\t}\n\t}\n\n\t/**\n\t * This is the core algorithm for matching up children.  The idea is to use id sets to try to match up\n\t * nodes as faithfully as possible.  We greedily match, which allows us to keep the algorithm fast, but\n\t * by using id sets, we are able to better match up with content deeper in the DOM.\n\t *\n\t * Basic algorithm is, for each node in the new content:\n\t *\n\t * - if we have reached the end of the old parent, append the new content\n\t * - if the new content has an id set match with the current insertion point, morph\n\t * - search for an id set match\n\t * - if id set match found, morph\n\t * - otherwise search for a \"soft\" match\n\t * - if a soft match is found, morph\n\t * - otherwise, prepend the new node before the current insertion point\n\t *\n\t * The two search algorithms terminate if competing node matches appear to outweigh what can be achieved\n\t * with the current node.  See findIdSetMatch() and findSoftMatch() for details.\n\t *\n\t * @param {Element} newParent the parent element of the new content\n\t * @param {Element } oldParent the old content that we are merging the new content into\n\t * @param ctx the merge context\n\t */\n\tfunction morphChildren(newParent, oldParent, ctx) {\n\n\t\tlet nextNewChild = newParent.firstChild;\n\t\tlet insertionPoint = oldParent.firstChild;\n\t\tlet newChild;\n\n\t\t// run through all the new content\n\t\twhile (nextNewChild) {\n\n\t\t\tnewChild = nextNewChild;\n\t\t\tnextNewChild = newChild.nextSibling;\n\n\t\t\t// if we are at the end of the exiting parent's children, just append\n\t\t\tif (insertionPoint == null) {\n\t\t\t\tif (ctx.callbacks.beforeNodeAdded(newChild) === false) return;\n\n\t\t\t\toldParent.appendChild(newChild);\n\t\t\t\tctx.callbacks.afterNodeAdded(newChild);\n\t\t\t\tremoveIdsFromConsideration(ctx, newChild);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// if the current node has an id set match then morph\n\t\t\tif (isIdSetMatch(newChild, insertionPoint, ctx)) {\n\t\t\t\tmorphOldNodeTo(insertionPoint, newChild, ctx);\n\t\t\t\tinsertionPoint = insertionPoint.nextSibling;\n\t\t\t\tremoveIdsFromConsideration(ctx, newChild);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// otherwise search forward in the existing old children for an id set match\n\t\t\tlet idSetMatch = findIdSetMatch(newParent, oldParent, newChild, insertionPoint, ctx);\n\n\t\t\t// if we found a potential match, remove the nodes until that point and morph\n\t\t\tif (idSetMatch) {\n\t\t\t\tinsertionPoint = removeNodesBetween(insertionPoint, idSetMatch, ctx);\n\t\t\t\tmorphOldNodeTo(idSetMatch, newChild, ctx);\n\t\t\t\tremoveIdsFromConsideration(ctx, newChild);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// no id set match found, so scan forward for a soft match for the current node\n\t\t\tlet softMatch = findSoftMatch(newParent, oldParent, newChild, insertionPoint, ctx);\n\n\t\t\t// if we found a soft match for the current node, morph\n\t\t\tif (softMatch) {\n\t\t\t\tinsertionPoint = removeNodesBetween(insertionPoint, softMatch, ctx);\n\t\t\t\tmorphOldNodeTo(softMatch, newChild, ctx);\n\t\t\t\tremoveIdsFromConsideration(ctx, newChild);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// abandon all hope of morphing, just insert the new child before the insertion point\n\t\t\t// and move on\n\t\t\tif (ctx.callbacks.beforeNodeAdded(newChild) === false) return;\n\n\t\t\toldParent.insertBefore(newChild, insertionPoint);\n\t\t\tctx.callbacks.afterNodeAdded(newChild);\n\t\t\tremoveIdsFromConsideration(ctx, newChild);\n\t\t}\n\n\t\t// remove any remaining old nodes that didn't match up with new content\n\t\twhile (insertionPoint !== null) {\n\n\t\t\tlet tempNode = insertionPoint;\n\t\t\tinsertionPoint = insertionPoint.nextSibling;\n\t\t\tremoveNode(tempNode, ctx);\n\t\t}\n\t}\n\n\t//=============================================================================\n\t// Attribute Syncing Code\n\t//=============================================================================\n\n\t/**\n\t * @param attr {String} the attribute to be mutated\n\t * @param to {Element} the element that is going to be updated\n\t * @param updateType {(\"update\"|\"remove\")}\n\t * @param ctx the merge context\n\t * @returns {boolean} true if the attribute should be ignored, false otherwise\n\t */\n\tfunction ignoreAttribute(attr, to, updateType, ctx) {\n\t\tif(attr === 'value' && ctx.ignoreActiveValue && to === document.activeElement){\n\t\t\treturn true;\n\t\t}\n\t\treturn ctx.callbacks.beforeAttributeUpdated(attr, to, updateType) === false;\n\t}\n\n\t/**\n\t * syncs a given node with another node, copying over all attributes and\n\t * inner element state from the 'from' node to the 'to' node\n\t *\n\t * @param {Element} from the element to copy attributes & state from\n\t * @param {Element} to the element to copy attributes & state to\n\t * @param ctx the merge context\n\t */\n\tfunction syncNodeFrom(from, to, ctx) {\n\t\tlet type = from.nodeType\n\n\t\t// if is an element type, sync the attributes from the\n\t\t// new node into the new node\n\t\tif (type === 1 /* element type */) {\n\t\t\tconst fromAttributes = from.attributes;\n\t\t\tconst toAttributes = to.attributes;\n\t\t\tfor (const fromAttribute of fromAttributes) {\n\t\t\t\tif (ignoreAttribute(fromAttribute.name, to, 'update', ctx)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (to.getAttribute(fromAttribute.name) !== fromAttribute.value) {\n\t\t\t\t\tto.setAttribute(fromAttribute.name, fromAttribute.value);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// iterate backwards to avoid skipping over items when a delete occurs\n\t\t\tfor (let i = toAttributes.length - 1; 0 <= i; i--) {\n\t\t\t\tconst toAttribute = toAttributes[i];\n\t\t\t\tif (ignoreAttribute(toAttribute.name, to, 'remove', ctx)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!from.hasAttribute(toAttribute.name)) {\n\t\t\t\t\tto.removeAttribute(toAttribute.name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// sync text nodes\n\t\tif (type === 8 /* comment */ || type === 3 /* text */) {\n\t\t\tif (to.nodeValue !== from.nodeValue) {\n\t\t\t\tto.nodeValue = from.nodeValue;\n\t\t\t}\n\t\t}\n\n\t\tif (!ignoreValueOfActiveElement(to, ctx)) {\n\t\t\t// sync input values\n\t\t\tsyncInputValue(from, to, ctx);\n\t\t}\n\t}\n\n\t/**\n\t * @param from {Element} element to sync the value from\n\t * @param to {Element} element to sync the value to\n\t * @param attributeName {String} the attribute name\n\t * @param ctx the merge context\n\t */\n\tfunction syncBooleanAttribute(from, to, attributeName, ctx) {\n\t\tif (from[attributeName] !== to[attributeName]) {\n\t\t\tlet ignoreUpdate = ignoreAttribute(attributeName, to, 'update', ctx);\n\t\t\tif (!ignoreUpdate) {\n\t\t\t\tto[attributeName] = from[attributeName];\n\t\t\t}\n\t\t\tif (from[attributeName]) {\n\t\t\t\tif (!ignoreUpdate) {\n\t\t\t\t\tto.setAttribute(attributeName, from[attributeName]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!ignoreAttribute(attributeName, to, 'remove', ctx)) {\n\t\t\t\t\tto.removeAttribute(attributeName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * NB: many bothans died to bring us information:\n\t *\n\t *  https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n\t *  https://github.com/choojs/nanomorph/blob/master/lib/morph.jsL113\n\t *\n\t * @param from {Element} the element to sync the input value from\n\t * @param to {Element} the element to sync the input value to\n\t * @param ctx the merge context\n\t */\n\tfunction syncInputValue(from, to, ctx) {\n\t\tif (from instanceof HTMLInputElement &&\n\t\t\tto instanceof HTMLInputElement &&\n\t\t\tfrom.type !== 'file') {\n\n\t\t\tlet fromValue = from.value;\n\t\t\tlet toValue = to.value;\n\n\t\t\t// sync boolean attributes\n\t\t\tsyncBooleanAttribute(from, to, 'checked', ctx);\n\t\t\tsyncBooleanAttribute(from, to, 'disabled', ctx);\n\n\t\t\tif (!from.hasAttribute('value')) {\n\t\t\t\tif (!ignoreAttribute('value', to, 'remove', ctx)) {\n\t\t\t\t\tto.value = '';\n\t\t\t\t\tto.removeAttribute('value');\n\t\t\t\t}\n\t\t\t} else if (fromValue !== toValue) {\n\t\t\t\tif (!ignoreAttribute('value', to, 'update', ctx)) {\n\t\t\t\t\tto.setAttribute('value', fromValue);\n\t\t\t\t\tto.value = fromValue;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (from instanceof HTMLOptionElement) {\n\t\t\tsyncBooleanAttribute(from, to, 'selected', ctx)\n\t\t} else if (from instanceof HTMLTextAreaElement && to instanceof HTMLTextAreaElement) {\n\t\t\tlet fromValue = from.value;\n\t\t\tlet toValue = to.value;\n\t\t\tif (ignoreAttribute('value', to, 'update', ctx)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (fromValue !== toValue) {\n\t\t\t\tto.value = fromValue;\n\t\t\t}\n\t\t\tif (to.firstChild && to.firstChild.nodeValue !== fromValue) {\n\t\t\t\tto.firstChild.nodeValue = fromValue\n\t\t\t}\n\t\t}\n\t}\n\n\t//=============================================================================\n\t// the HEAD tag can be handled specially, either w/ a 'merge' or 'append' style\n\t//=============================================================================\n\tfunction handleHeadElement(newHeadTag, currentHead, ctx) {\n\n\t\tlet added = []\n\t\tlet removed = []\n\t\tlet preserved = []\n\t\tlet nodesToAppend = []\n\n\t\tlet headMergeStyle = ctx.head.style;\n\n\t\t// put all new head elements into a Map, by their outerHTML\n\t\tlet srcToNewHeadNodes = new Map();\n\t\tfor (const newHeadChild of newHeadTag.children) {\n\t\t\tsrcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild);\n\t\t}\n\n\t\t// for each elt in the current head\n\t\tfor (const currentHeadElt of currentHead.children) {\n\n\t\t\t// If the current head element is in the map\n\t\t\tlet inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML);\n\t\t\tlet isReAppended = ctx.head.shouldReAppend(currentHeadElt);\n\t\t\tlet isPreserved = ctx.head.shouldPreserve(currentHeadElt);\n\t\t\tif (inNewContent || isPreserved) {\n\t\t\t\tif (isReAppended) {\n\t\t\t\t\t// remove the current version and let the new version replace it and re-execute\n\t\t\t\t\tremoved.push(currentHeadElt);\n\t\t\t\t} else {\n\t\t\t\t\t// this element already exists and should not be re-appended, so remove it from\n\t\t\t\t\t// the new content map, preserving it in the DOM\n\t\t\t\t\tsrcToNewHeadNodes.delete(currentHeadElt.outerHTML);\n\t\t\t\t\tpreserved.push(currentHeadElt);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (headMergeStyle === \"append\") {\n\t\t\t\t\t// we are appending and this existing element is not new content\n\t\t\t\t\t// so if and only if it is marked for re-append do we do anything\n\t\t\t\t\tif (isReAppended) {\n\t\t\t\t\t\tremoved.push(currentHeadElt);\n\t\t\t\t\t\tnodesToAppend.push(currentHeadElt);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// if this is a merge, we remove this content since it is not in the new head\n\t\t\t\t\tif (ctx.head.shouldRemove(currentHeadElt) !== false) {\n\t\t\t\t\t\tremoved.push(currentHeadElt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Push the remaining new head elements in the Map into the\n\t\t// nodes to append to the head tag\n\t\tnodesToAppend.push(...srcToNewHeadNodes.values());\n\t\tlog(\"to append: \", nodesToAppend);\n\n\t\tlet promises = [];\n\t\tfor (const newNode of nodesToAppend) {\n\t\t\tlog(\"adding: \", newNode);\n\t\t\tlet newElt = document.createRange().createContextualFragment(newNode.outerHTML).firstChild;\n\t\t\tlog(newElt);\n\t\t\tif (ctx.callbacks.beforeNodeAdded(newElt) !== false) {\n\t\t\t\tif (newElt.href || newElt.src) {\n\t\t\t\t\tlet resolve = null;\n\t\t\t\t\tlet promise = new Promise(function (_resolve) {\n\t\t\t\t\t\tresolve = _resolve;\n\t\t\t\t\t});\n\t\t\t\t\tnewElt.addEventListener('load', function () {\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t});\n\t\t\t\t\tpromises.push(promise);\n\t\t\t\t}\n\t\t\t\tcurrentHead.appendChild(newElt);\n\t\t\t\tctx.callbacks.afterNodeAdded(newElt);\n\t\t\t\tadded.push(newElt);\n\t\t\t}\n\t\t}\n\n\t\t// remove all removed elements, after we have appended the new elements to avoid\n\t\t// additional network requests for things like style sheets\n\t\tfor (const removedElement of removed) {\n\t\t\tif (ctx.callbacks.beforeNodeRemoved(removedElement) !== false) {\n\t\t\t\tcurrentHead.removeChild(removedElement);\n\t\t\t\tctx.callbacks.afterNodeRemoved(removedElement);\n\t\t\t}\n\t\t}\n\n\t\tctx.head.afterHeadMorphed(currentHead, {added: added, kept: preserved, removed: removed});\n\t\treturn promises;\n\t}\n\n\t//=============================================================================\n\t// Misc\n\t//=============================================================================\n\n\tfunction log() {\n\t\t//console.log(arguments);\n\t}\n\n\tfunction noOp() {\n\t}\n\n\t/*\n\t  Deep merges the config object and the Idiomoroph.defaults object to\n\t  produce a final configuration object\n\t */\n\tfunction mergeDefaults(config) {\n\t\tlet finalConfig = {};\n\t\t// copy top level stuff into final config\n\t\tObject.assign(finalConfig, defaults);\n\t\tObject.assign(finalConfig, config);\n\n\t\t// copy callbacks into final config (do this to deep merge the callbacks)\n\t\tfinalConfig.callbacks = {};\n\t\tObject.assign(finalConfig.callbacks, defaults.callbacks);\n\t\tObject.assign(finalConfig.callbacks, config.callbacks);\n\n\t\t// copy head config into final config  (do this to deep merge the head)\n\t\tfinalConfig.head = {};\n\t\tObject.assign(finalConfig.head, defaults.head);\n\t\tObject.assign(finalConfig.head, config.head);\n\t\treturn finalConfig;\n\t}\n\n\tfunction createMorphContext(oldNode, newContent, config) {\n\t\tconfig = mergeDefaults(config);\n\t\treturn {\n\t\t\ttarget: oldNode,\n\t\t\tnewContent: newContent,\n\t\t\tconfig: config,\n\t\t\tmorphStyle: config.morphStyle,\n\t\t\tignoreActive: config.ignoreActive,\n\t\t\tignoreActiveValue: config.ignoreActiveValue,\n\t\t\tidMap: createIdMap(oldNode, newContent),\n\t\t\tdeadIds: new Set(),\n\t\t\tcallbacks: config.callbacks,\n\t\t\thead: config.head\n\t\t}\n\t}\n\n\tfunction isIdSetMatch(node1, node2, ctx) {\n\t\tif (node1 == null || node2 == null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (node1.nodeType === node2.nodeType && node1.tagName === node2.tagName) {\n\t\t\tif (node1.id !== \"\" && node1.id === node2.id) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn getIdIntersectionCount(ctx, node1, node2) > 0;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction isSoftMatch(node1, node2) {\n\t\tif (node1 == null || node2 == null) {\n\t\t\treturn false;\n\t\t}\n\t\treturn node1.nodeType === node2.nodeType && node1.tagName === node2.tagName\n\t}\n\n\tfunction removeNodesBetween(startInclusive, endExclusive, ctx) {\n\t\twhile (startInclusive !== endExclusive) {\n\t\t\tlet tempNode = startInclusive;\n\t\t\tstartInclusive = startInclusive.nextSibling;\n\t\t\tremoveNode(tempNode, ctx);\n\t\t}\n\t\tremoveIdsFromConsideration(ctx, endExclusive);\n\t\treturn endExclusive.nextSibling;\n\t}\n\n\t//=============================================================================\n\t// Scans forward from the insertionPoint in the old parent looking for a potential id match\n\t// for the newChild.  We stop if we find a potential id match for the new child OR\n\t// if the number of potential id matches we are discarding is greater than the\n\t// potential id matches for the new child\n\t//=============================================================================\n\tfunction findIdSetMatch(newContent, oldParent, newChild, insertionPoint, ctx) {\n\n\t\t// max id matches we are willing to discard in our search\n\t\tlet newChildPotentialIdCount = getIdIntersectionCount(ctx, newChild, oldParent);\n\n\t\tlet potentialMatch = null;\n\n\t\t// only search forward if there is a possibility of an id match\n\t\tif (newChildPotentialIdCount > 0) {\n\t\t\tlet potentialMatch = insertionPoint;\n\t\t\t// if there is a possibility of an id match, scan forward\n\t\t\t// keep track of the potential id match count we are discarding (the\n\t\t\t// newChildPotentialIdCount must be greater than this to make it likely\n\t\t\t// worth it)\n\t\t\tlet otherMatchCount = 0;\n\t\t\twhile (potentialMatch != null) {\n\n\t\t\t\t// If we have an id match, return the current potential match\n\t\t\t\tif (isIdSetMatch(newChild, potentialMatch, ctx)) {\n\t\t\t\t\treturn potentialMatch;\n\t\t\t\t}\n\n\t\t\t\t// computer the other potential matches of this new content\n\t\t\t\totherMatchCount += getIdIntersectionCount(ctx, potentialMatch, newContent);\n\t\t\t\tif (otherMatchCount > newChildPotentialIdCount) {\n\t\t\t\t\t// if we have more potential id matches in _other_ content, we\n\t\t\t\t\t// do not have a good candidate for an id match, so return null\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\t// advanced to the next old content child\n\t\t\t\tpotentialMatch = potentialMatch.nextSibling;\n\t\t\t}\n\t\t}\n\t\treturn potentialMatch;\n\t}\n\n\t//=============================================================================\n\t// Scans forward from the insertionPoint in the old parent looking for a potential soft match\n\t// for the newChild.  We stop if we find a potential soft match for the new child OR\n\t// if we find a potential id match in the old parents children OR if we find two\n\t// potential soft matches for the next two pieces of new content\n\t//=============================================================================\n\tfunction findSoftMatch(newContent, oldParent, newChild, insertionPoint, ctx) {\n\n\t\tlet potentialSoftMatch = insertionPoint;\n\t\tlet nextSibling = newChild.nextSibling;\n\t\tlet siblingSoftMatchCount = 0;\n\n\t\twhile (potentialSoftMatch != null) {\n\n\t\t\tif (getIdIntersectionCount(ctx, potentialSoftMatch, newContent) > 0) {\n\t\t\t\t// the current potential soft match has a potential id set match with the remaining new\n\t\t\t\t// content so bail out of looking\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// if we have a soft match with the current node, return it\n\t\t\tif (isSoftMatch(newChild, potentialSoftMatch)) {\n\t\t\t\treturn potentialSoftMatch;\n\t\t\t}\n\n\t\t\tif (isSoftMatch(nextSibling, potentialSoftMatch)) {\n\t\t\t\t// the next new node has a soft match with this node, so\n\t\t\t\t// increment the count of future soft matches\n\t\t\t\tsiblingSoftMatchCount++;\n\t\t\t\tnextSibling = nextSibling.nextSibling;\n\n\t\t\t\t// If there are two future soft matches, bail to allow the siblings to soft match\n\t\t\t\t// so that we don't consume future soft matches for the sake of the current node\n\t\t\t\tif (siblingSoftMatchCount >= 2) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// advanced to the next old content child\n\t\t\tpotentialSoftMatch = potentialSoftMatch.nextSibling;\n\t\t}\n\n\t\treturn potentialSoftMatch;\n\t}\n\n\tfunction parseContent(newContent) {\n\t\tlet parser = new DOMParser();\n\n\t\t// remove svgs to avoid false-positive matches on head, etc.\n\t\tlet contentWithSvgsRemoved = newContent.replace(/<svg(\\s[^>]*>|>)([\\s\\S]*?)<\\/svg>/gim, '');\n\n\t\t// if the newContent contains a html, head or body tag, we can simply parse it w/o wrapping\n\t\tif (contentWithSvgsRemoved.match(/<\\/html>/) || contentWithSvgsRemoved.match(/<\\/head>/) || contentWithSvgsRemoved.match(/<\\/body>/)) {\n\t\t\tlet content = parser.parseFromString(newContent, \"text/html\");\n\t\t\t// if it is a full HTML document, return the document itself as the parent container\n\t\t\tif (contentWithSvgsRemoved.match(/<\\/html>/)) {\n\t\t\t\tcontent.generatedByIdiomorph = true;\n\t\t\t\treturn content;\n\t\t\t} else {\n\t\t\t\t// otherwise return the html element as the parent container\n\t\t\t\tlet htmlElement = content.firstChild;\n\t\t\t\tif (htmlElement) {\n\t\t\t\t\thtmlElement.generatedByIdiomorph = true;\n\t\t\t\t\treturn htmlElement;\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// if it is partial HTML, wrap it in a template tag to provide a parent element and also to help\n\t\t\t// deal with touchy tags like tr, tbody, etc.\n\t\t\tlet responseDoc = parser.parseFromString(\"<body><template>\" + newContent + \"</template></body>\", \"text/html\");\n\t\t\tlet content = responseDoc.body.querySelector('template').content;\n\t\t\tcontent.generatedByIdiomorph = true;\n\t\t\treturn content\n\t\t}\n\t}\n\n\tfunction normalizeContent(newContent) {\n\t\tif (newContent == null) {\n\t\t\t// noinspection UnnecessaryLocalVariableJS\n\t\t\tconst dummyParent = document.createElement('div');\n\t\t\treturn dummyParent;\n\t\t} else if (newContent.generatedByIdiomorph) {\n\t\t\t// the template tag created by idiomorph parsing can serve as a dummy parent\n\t\t\treturn newContent;\n\t\t} else if (newContent instanceof Node) {\n\t\t\t// a single node is added as a child to a dummy parent\n\t\t\tconst dummyParent = document.createElement('div');\n\t\t\tdummyParent.append(newContent);\n\t\t\treturn dummyParent;\n\t\t} else {\n\t\t\t// all nodes in the array or HTMLElement collection are consolidated under\n\t\t\t// a single dummy parent element\n\t\t\tconst dummyParent = document.createElement('div');\n\t\t\tfor (const elt of [...newContent]) {\n\t\t\t\tdummyParent.append(elt);\n\t\t\t}\n\t\t\treturn dummyParent;\n\t\t}\n\t}\n\n\tfunction insertSiblings(previousSibling, morphedNode, nextSibling) {\n\t\tlet stack = []\n\t\tlet added = []\n\t\twhile (previousSibling != null) {\n\t\t\tstack.push(previousSibling);\n\t\t\tpreviousSibling = previousSibling.previousSibling;\n\t\t}\n\t\twhile (stack.length > 0) {\n\t\t\tlet node = stack.pop();\n\t\t\tadded.push(node); // push added preceding siblings on in order and insert\n\t\t\tmorphedNode.parentElement.insertBefore(node, morphedNode);\n\t\t}\n\t\tadded.push(morphedNode);\n\t\twhile (nextSibling != null) {\n\t\t\tstack.push(nextSibling);\n\t\t\tadded.push(nextSibling); // here we are going in order, so push on as we scan, rather than add\n\t\t\tnextSibling = nextSibling.nextSibling;\n\t\t}\n\t\twhile (stack.length > 0) {\n\t\t\tmorphedNode.parentElement.insertBefore(stack.pop(), morphedNode.nextSibling);\n\t\t}\n\t\treturn added;\n\t}\n\n\tfunction findBestNodeMatch(newContent, oldNode, ctx) {\n\t\tlet currentElement;\n\t\tcurrentElement = newContent.firstChild;\n\t\tlet bestElement = currentElement;\n\t\tlet score = 0;\n\t\twhile (currentElement) {\n\t\t\tlet newScore = scoreElement(currentElement, oldNode, ctx);\n\t\t\tif (newScore > score) {\n\t\t\t\tbestElement = currentElement;\n\t\t\t\tscore = newScore;\n\t\t\t}\n\t\t\tcurrentElement = currentElement.nextSibling;\n\t\t}\n\t\treturn bestElement;\n\t}\n\n\tfunction scoreElement(node1, node2, ctx) {\n\t\tif (isSoftMatch(node1, node2)) {\n\t\t\treturn .5 + getIdIntersectionCount(ctx, node1, node2);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tfunction removeNode(tempNode, ctx) {\n\t\tremoveIdsFromConsideration(ctx, tempNode)\n\t\tif (ctx.callbacks.beforeNodeRemoved(tempNode) === false) return;\n\n\t\ttempNode.remove();\n\t\tctx.callbacks.afterNodeRemoved(tempNode);\n\t}\n\n\t//=============================================================================\n\t// ID Set Functions\n\t//=============================================================================\n\n\tfunction isIdInConsideration(ctx, id) {\n\t\treturn !ctx.deadIds.has(id);\n\t}\n\n\tfunction idIsWithinNode(ctx, id, targetNode) {\n\t\tlet idSet = ctx.idMap.get(targetNode) || EMPTY_SET;\n\t\treturn idSet.has(id);\n\t}\n\n\tfunction removeIdsFromConsideration(ctx, node) {\n\t\tlet idSet = ctx.idMap.get(node) || EMPTY_SET;\n\t\tfor (const id of idSet) {\n\t\t\tctx.deadIds.add(id);\n\t\t}\n\t}\n\n\tfunction getIdIntersectionCount(ctx, node1, node2) {\n\t\tlet sourceSet = ctx.idMap.get(node1) || EMPTY_SET;\n\t\tlet matchCount = 0;\n\t\tfor (const id of sourceSet) {\n\t\t\t// a potential match is an id in the source and potentialIdsSet, but\n\t\t\t// that has not already been merged into the DOM\n\t\t\tif (isIdInConsideration(ctx, id) && idIsWithinNode(ctx, id, node2)) {\n\t\t\t\t++matchCount;\n\t\t\t}\n\t\t}\n\t\treturn matchCount;\n\t}\n\n\t/**\n\t * A bottom up algorithm that finds all elements with ids inside of the node\n\t * argument and populates id sets for those nodes and all their parents, generating\n\t * a set of ids contained within all nodes for the entire hierarchy in the DOM\n\t *\n\t * @param node {Element}\n\t * @param {Map<Node, Set<String>>} idMap\n\t */\n\tfunction populateIdMapForNode(node, idMap) {\n\t\tlet nodeParent = node.parentElement;\n\t\t// find all elements with an id property\n\t\tlet idElements = node.querySelectorAll('[id]');\n\t\tfor (const elt of idElements) {\n\t\t\tlet current = elt;\n\t\t\t// walk up the parent hierarchy of that element, adding the id\n\t\t\t// of element to the parent's id set\n\t\t\twhile (current !== nodeParent && current != null) {\n\t\t\t\tlet idSet = idMap.get(current);\n\t\t\t\t// if the id set doesn't exist, create it and insert it in the  map\n\t\t\t\tif (idSet == null) {\n\t\t\t\t\tidSet = new Set();\n\t\t\t\t\tidMap.set(current, idSet);\n\t\t\t\t}\n\t\t\t\tidSet.add(elt.id);\n\t\t\t\tcurrent = current.parentElement;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * This function computes a map of nodes to all ids contained within that node (inclusive of the\n\t * node).  This map can be used to ask if two nodes have intersecting sets of ids, which allows\n\t * for a looser definition of \"matching\" than tradition id matching, and allows child nodes\n\t * to contribute to a parent nodes matching.\n\t *\n\t * @param {Element} oldContent  the old content that will be morphed\n\t * @param {Element} newContent  the new content to morph to\n\t * @returns {Map<Node, Set<String>>} a map of nodes to id sets for the\n\t */\n\tfunction createIdMap(oldContent, newContent) {\n\t\tlet idMap = new Map();\n\t\tpopulateIdMapForNode(oldContent, idMap);\n\t\tpopulateIdMapForNode(newContent, idMap);\n\t\treturn idMap;\n\t}\n\n\t//=============================================================================\n\t// This is what ends up becoming the Idiomorph global object\n\t//=============================================================================\n\treturn {\n\t\tmorph,\n\t\tdefaults\n\t}\n})();\n","const customEvent = (() => {\n\treturn ('CustomEvent' in window && typeof window.CustomEvent === 'function')\n\t\t? (name, data) => new CustomEvent(name, data)\n\t\t: (name, data) => {\n\t\t\tconst newEvent = document.createEvent('CustomEvent')\n\t\t\tnewEvent.initCustomEvent(name, true, true, data)\n\t\t\treturn newEvent\n\t\t}\n})()\n\nconst handler = (node, ev) => {\n\treturn function (e) {\n\t\tconst scope = this\n\t\tconst detail = e.detail || {}\n\t\tnode.__events[ev].forEach(o => {\n\t\t\to.handler.apply(scope, [e].concat(detail.args))\n\t\t})\n\t}\n}\n\nconst removeListener = (node, ev) => {\n\tif (node.__events[ev] && node.__events[ev].listener) {\n\t\tnode.removeEventListener(\n\t\t\tev,\n\t\t\tnode.__events[ev].listener,\n\t\t\t(ev == 'focus' || ev == 'blur' || ev == 'mouseenter' || ev == 'mouseleave'))\n\t\tdelete node.__events[ev]\n\t}\n}\n\nconst delegate = (node, selector, callback) => {\n\treturn function (e) {\n\n\t\tconst element = this\n\t\tconst detail = e.detail || {}\n\n\t\tlet parent = e.target\n\n\t\twhile (parent) {\n\t\t\tif (parent.matches(selector)) {\n\t\t\t\te.delegateTarget = parent\n\t\t\t\tcallback.apply(element, [e].concat(detail.args))\n\t\t\t}\n\t\t\tif (parent === node) break\n\t\t\tparent = parent.parentNode\n\t\t}\n\t}\n}\n\nexport const on = (node, ev, selectorOrCallback, callback) => {\n\n\tnode.__events = node.__events || {}\n\tnode.__events[ev] = (node.__events[ev] || [])\n\n\tif (!node.__events[ev].length) {\n\t\tconst fn = handler(node, ev)\n\t\tnode.addEventListener(\n\t\t\tev,\n\t\t\tfn,\n\t\t\t(ev == 'focus' || ev == 'blur' || ev == 'mouseenter' || ev == 'mouseleave'))\n\t\tnode.__events[ev].listener = fn\n\t}\n\n\tif (selectorOrCallback.call) {\n\t\tnode.__events[ev].push({ handler: selectorOrCallback, callback: selectorOrCallback })\n\t} else {\n\t\tnode.__events[ev].push({ handler: delegate(node, selectorOrCallback, callback), callback })\n\t}\n}\n\nexport const off = (node, ev, fn) => {\n\n\tif (fn && node.__events[ev] && node.__events[ev].length) {\n\t\tvar old = node.__events[ev]\n\t\tnode.__events[ev] = node.__events[ev].filter(function (o) { return o.callback != fn; })\n\t\tnode.__events[ev].listener = old.listener\n\t\tif (!node.__events[ev].length)\n\t\t\tremoveListener(node, ev)\n\t} else {\n\t\tremoveListener(node, ev)\n\t}\n}\n\nexport const trigger = (node, name, args) => {\n\tnode.dispatchEvent(customEvent(name, { bubbles: true, detail: args }))\n}\n","import { type Component } from '..'\nimport { Idiomorph } from './utils/idiomorph'\nimport { rAF, dup, safe } from './utils'\nimport { buildtemplates } from './template-system'\nimport { on, off, trigger } from './utils/events'\nimport { publish, subscribe } from './utils/pubsub'\n\nexport default function Component( elm, { module, dependencies, templates, components }) {\n\n\tconst options = getOptions( module )\n\tconst initialState = (new Function( `return ${elm.getAttribute('html-model') || '{}'}`))()\n\tconst selector = Object.keys(components).toString()\n\n\tbuildtemplates( elm, selector, templates, components )\n\n\tconst tplid = elm.getAttribute('tplid')\n\tconst template = tplid ? templates[tplid] : null\n\tconst state = { data: module.model ? dup(module.model) : {} }\n\tstate.data = Object.assign( state.data, initialState)\n\n\tconst base: Component = {\n\t\ttemplate,\n\t\telm,\n\t\tdependencies,\n\t\tpublish,\n\t\tsubscribe,\n\n\t\tmain(fn) {\n\t\t\toptions.main = fn\n\t\t},\n\n\t\tunmount(fn) {\n\t\t\toptions.unmount = fn\n\t\t},\n\n\t\tonupdate(fn) {\n\t\t\toptions.onupdate = fn\n\t\t},\n\n\t\ton(eventName, selectorOrCallback, callback) {\n\t\t\ton(elm, eventName, selectorOrCallback, callback)\n\t\t},\n\n\t\toff(eventName, callback) {\n\t\t\toff(elm, eventName, callback)\n\t\t},\n\n\t\ttrigger(eventName, target, args) {\n\t\t\tif (target.constructor === String) {\n\t\t\t\tArray\n\t\t\t\t\t.from(elm.querySelectorAll(target))\n\t\t\t\t\t.forEach( children => trigger(children, eventName, { args: args }) )\n\t\t\t}\n\t\t\telse trigger(elm, eventName, { args: target })\n\t\t},\n\n\t\temit: ( ...args ) => {\n\t\t\ttrigger(elm, args.shift(), { args: args })\n\t\t},\n\n\t\tstate: {\n\t\t\tset( data ) {\n\t\t\t\tif (data.constructor === Function) {\n\t\t\t\t\tconst newstate = dup(state.data)\n\t\t\t\t\tdata(newstate)\n\t\t\t\t\tbase.render(newstate)\n\t\t\t\t} else {\n\t\t\t\t\tbase.render(data)\n\t\t\t\t}\n\t\t\t\treturn new Promise((resolve) => rAF(_ => rAF(() => resolve(state.data))))\n\t\t\t},\n\t\t\tget() {\n\t\t\t\treturn dup(state.data)\n\t\t\t},\n\n\t\t\tgetRaw(){\n\t\t\t\treturn state.data\n\t\t\t}\n\t\t},\n\n\t\trender(data = state.data) {\n\n\t\t\tif (!document.body.contains(elm)) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tstate.data = Object.assign(state.data, data)\n\n\t\t\tconst newdata = dup(state.data)\n\t\t\tconst newhtml = templates[tplid].call(Object.assign(options.view(newdata), elm.___scope___), elm, safe)\n\n\t\t\tIdiomorph.morph(elm, newhtml, IdiomorphOptions(elm))\n\t\t\tupdateScope( elm )\n\n\t\t\trAF(_ => {\n\t\t\t\tArray\n\t\t\t\t\t.from(elm.querySelectorAll('[tplid]'))\n\t\t\t\t\t.forEach((child: any) => {\n\t\t\t\t\t\tconst props = Object.assign( child.base.state.getRaw(), data )\n\t\t\t\t\t\tchild.options.onupdate(props)\n\t\t\t\t\t\tchild.base.render(props)\n\t\t\t\t\t})\n\t\t\t})\n\t\t},\n\n\t\tinnerHTML( target, html_ ) {\n\n\t\t\tconst element = html_? target : elm\n\t\t\tconst parser = new DOMParser()\n\t\t\tconst virtual = parser.parseFromString(element.outerHTML, 'text/html')\n\t\t\tconst html = html_? html_ : target\n\n\t\t\tvirtual.body.firstElementChild.innerHTML = html as string\n\t\t\trAF( _ => Idiomorph.morph(element, virtual.body.innerHTML, IdiomorphOptions) )\n\t\t}\n\t}\n\n\treturn { base, options }\n}\n\nconst getOptions = (module) => ({\n\tmain: (a) => a,\n\tunmount: (a) => a,\n\tonupdate: (a) => a,\n\tview: module.view ? module.view : (a) => a\n})\n\nconst updateScope = (node) => {\n\tnode.querySelectorAll('[scope]').forEach( scopeElement => {\n\t\tscopeElement.querySelectorAll('[tplid]').forEach( cp => {\n\t\t\tif( !cp.___scope___ ) {\n\t\t\t\tconst script = scopeElement.lastElementChild\n\t\t\t\tcp.___scope___ = 'scope' in script.dataset? (new Function(`return ${script.text}`))() : {}\n\t\t\t}\n\t\t})\n\t})\n}\n\n\nconst IdiomorphOptions = (parent) => ({\n\n\tcallbacks: {\n\n\t\tbeforeNodeMorphed( node ) {\n\t\t\tif( node.nodeType === 1 ) {\n\t\t\t\tif( 'html-static' in node.attributes ) {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\tif( node.base && node !== parent ) {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n})\n","import Component from './component'\nimport { purge, rAF } from './utils'\n\nexport default function Element(module, dependencies, templates, components) {\n\treturn class extends HTMLElement {\n\n\t\tbase: any\n\t\toptions: any\n\t\treturns : any\n\t\t__events: any\n\n\t\tconstructor() {\n\n\t\t\tsuper()\n\t\t\tconst { base, options } = Component(this, { module, dependencies, templates, components })\n\n\t\t\tthis.base = base\n\t\t\tthis.options = options\n\t\t\tthis.returns = module.default(base)\n\t\t}\n\n\t\tconnectedCallback() {\n\n\t\t\tthis.base.render()\n\n\t\t\tif( this.__template && this.__template.constructor === Promise ) {\n\t\t\t\tthis.__template.then( _ => {\n\t\t\t\t\tif( this.base && this.options.main) {\n\t\t\t\t\t\tconst array = this.options.main(this.base)\n\t\t\t\t\t\tif( array && array.length ){\n\t\t\t\t\t\t\tarray.forEach(f => f(this.base))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif( this.returns && this.returns.constructor === Promise ) {\n\t\t\t\tthis.returns.then( _ => {\n\t\t\t\t\tif( this.base && this.options.main) {\n\t\t\t\t\t\tconst array = this.options.main(this.base)\n\t\t\t\t\t\tif( array && array.length ){\n\t\t\t\t\t\t\tarray.forEach(f => f(this.base))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}else {\n\t\t\t\tif( this.base && this.options.main ){\n\t\t\t\t\tconst array = this.options.main(this.base)\n\t\t\t\t\tif( array && array.length ) {\n\t\t\t\t\t\tarray.forEach(f => f(this.base))\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdisconnectedCallback() {\n\t\t\tthis.options.unmount(this.base)\n\t\t\trAF(() => {\n\t\t\t\tif(!document.body.contains(this) ) {\n\t\t\t\t\tthis.__events? this.__events = null : null\n\t\t\t\t\tthis.base? this.base.elm = null : null\n\t\t\t\t\tthis.base? this.base = null : null\n\t\t\t\t\tpurge(this)\n\t\t\t\t}\n\t\t\t})\n\n\t\t}\n\n\t\tattributeChangedCallback() {\n\t\t\t//TODO\n\t\t}\n\t}\n}\n","import { templateConfig, buildtemplates } from './template-system'\nimport { publish, subscribe } from './utils/pubsub'\nimport { html } from './utils'\nimport Element from './element'\n\nconst templates = {}\nconst components = {}\n\nexport { html }\n\nexport default {\n\n\ttemplateConfig,\n\n\tpublish,\n\tsubscribe,\n\n\tregister( name, module, dependencies = {} ) {\n\t\tcomponents[name] = { name, module, dependencies }\n\t},\n\n\tstart( target = document.body ) {\n\t\tconst keys = Object.keys(components)\n\t\tconst selector = keys.toString()\n\t\tif( keys.length ) {\n\t\t\tbuildtemplates( target, selector, templates, components )\n\t\t\tregisterComponents()\n\t\t}\n\t}\n}\n\nconst registerComponents = () => {\n\tObject\n\t\t.values( components )\n\t\t.forEach( (component) => {\n\t\t\tconst { name, module, dependencies } = component as any\n\t\t\tif( !customElements.get(name) ){\n\t\t\t\tconst Base = Element(module, dependencies, templates, components)\n\t\t\t\tcustomElements.define(name, Base)\n\t\t\t}\n\t\t})\n}\n"],"names":["parser","DOMParser","wrap","open","node","close","_a","parentNode","insertBefore","_b","nextSibling","textarea","document","createElement","decodeHTML","text","innerHTML","value","rAF","fn","requestAnimationFrame","setTimeout","dup","o","JSON","parse","stringify","purge","d","i","l","n","a","attributes","length","name","childNodes","safe","execute","val","err","config","tags","Template","element","html","regexTags","RegExp","virtual","parseFromString","replace","querySelectorAll","forEach","htmlForeach","getAttribute","htmlFor","htmlIf","htmlInner","htmlClass","forEachInstruction","selector","split","match","varname","object","removeAttribute","setAttribute","script","dataset","scope","type","appendChild","createTextNode","className","trim","body","all","key","Transpile","outerHTML","decodedHTML","Function","_","variable","buildtemplates","target","templates","components","concat","matches","Array","from","reverse","template","content","createTemplateId","id","c","r","Math","random","toString","localName","module","constructor","Promise","__template","then","htmlstring","topics","_async","publish","params","Object","assign","topic","subscribe","method","push","filter","Idiomorph","EMPTY_SET","Set","defaults","morphStyle","callbacks","beforeNodeAdded","noOp","afterNodeAdded","beforeNodeMorphed","afterNodeMorphed","beforeNodeRemoved","afterNodeRemoved","beforeAttributeUpdated","head","style","shouldPreserve","elt","shouldReAppend","shouldRemove","afterHeadMorphed","morphNormalizedContent","oldNode","normalizedNewContent","ctx","block","oldHead","querySelector","newHead","promises","handleHeadElement","ignore","morphChildren","children","bestMatch","newContent","currentElement","firstChild","bestElement","score","newScore","scoreElement","findBestNodeMatch","previousSibling","morphedNode","morphOldNodeTo","stack","added","pop","parentElement","insertSiblings","ignoreValueOfActiveElement","possibleActiveElement","ignoreActiveValue","activeElement","ignoreActive","remove","isSoftMatch","HTMLHeadElement","to","nodeType","fromAttributes","toAttributes","fromAttribute","ignoreAttribute","toAttribute","hasAttribute","nodeValue","HTMLInputElement","fromValue","toValue","syncBooleanAttribute","HTMLOptionElement","HTMLTextAreaElement","syncInputValue","syncNodeFrom","replaceChild","newParent","oldParent","newChild","nextNewChild","insertionPoint","removeIdsFromConsideration","isIdSetMatch","idSetMatch","findIdSetMatch","removeNodesBetween","softMatch","findSoftMatch","tempNode","removeNode","attr","updateType","attributeName","ignoreUpdate","newHeadTag","currentHead","removed","preserved","nodesToAppend","headMergeStyle","srcToNewHeadNodes","Map","newHeadChild","set","currentHeadElt","inNewContent","has","isReAppended","isPreserved","delete","values","newNode","newElt","createRange","createContextualFragment","href","src","resolve","promise","_resolve","addEventListener","removedElement","removeChild","kept","node1","node2","tagName","getIdIntersectionCount","startInclusive","endExclusive","newChildPotentialIdCount","potentialMatch","otherMatchCount","potentialSoftMatch","siblingSoftMatchCount","isIdInConsideration","deadIds","idIsWithinNode","targetNode","idMap","get","idSet","add","sourceSet","matchCount","populateIdMapForNode","nodeParent","idElements","current","createIdMap","oldContent","morph","Document","documentElement","contentWithSvgsRemoved","generatedByIdiomorph","htmlElement","parseContent","normalizedContent","Node","dummyParent","append","normalizeContent","finalConfig","mergeDefaults","createMorphContext","customEvent","window","CustomEvent","data","newEvent","createEvent","initCustomEvent","handler","ev","e","this","detail","__events","apply","args","removeListener","listener","removeEventListener","delegate","callback","parent","delegateTarget","on","selectorOrCallback","call","off","old","trigger","dispatchEvent","bubbles","getOptions","main","unmount","onupdate","view","updateScope","scopeElement","cp","___scope___","lastElementChild","IdiomorphOptions","base","Element","dependencies","HTMLElement","options","elm","initialState","keys","tplid","state","model","eventName","String","emit","shift","newstate","render","getRaw","contains","newdata","newhtml","child","props","html_","firstElementChild","Component","returns","default","connectedCallback","array","f","disconnectedCallback","attributeChangedCallback","index","templateConfig","newconfig","register","start","registerComponents","component","customElements","Base","define","literalSections","substs","raw","result","subst","lit","isArray","join"],"mappings":"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"}