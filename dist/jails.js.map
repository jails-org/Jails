{"version":3,"file":"jails.js","sources":["../src/utils/index.ts","../node_modules/idiomorph/dist/idiomorph.esm.js","../src/utils/pubsub.ts","../src/component.ts","../src/element.ts","../src/template-system.ts","../src/index.ts"],"sourcesContent":["let textarea\n\nexport const g = {\n\tscope: {}\n}\n\nexport const decodeHTML = (text) => {\n\ttextarea = textarea || document.createElement('textarea')\n\ttextarea.innerHTML = text\n\treturn textarea.value\n}\n\nexport const rAF = (fn) => {\n\tif (requestAnimationFrame)\n\t\treturn requestAnimationFrame(fn)\n\telse\n\t\treturn setTimeout(fn, 1000 / 60)\n}\n\nexport const uuid = () => {\n\treturn Math.random().toString(36).substring(2, 9)\n}\n\nexport const dup = (o) => {\n\treturn JSON.parse(JSON.stringify(o))\n}\n\nexport const safe = (execute, val) => {\n\ttry{\n\t\tconst value = execute()\n\t\treturn value !== undefined && value !== null ? value : val || ''\n\t}catch(err){\n\t\treturn val || ''\n\t}\n}\n","/**\n * @typedef {object} ConfigHead\n *\n * @property {'merge' | 'append' | 'morph' | 'none'} [style]\n * @property {boolean} [block]\n * @property {boolean} [ignore]\n * @property {function(Element): boolean} [shouldPreserve]\n * @property {function(Element): boolean} [shouldReAppend]\n * @property {function(Element): boolean} [shouldRemove]\n * @property {function(Element, {added: Node[], kept: Element[], removed: Element[]}): void} [afterHeadMorphed]\n */\n\n/**\n * @typedef {object} ConfigCallbacks\n *\n * @property {function(Node): boolean} [beforeNodeAdded]\n * @property {function(Node): void} [afterNodeAdded]\n * @property {function(Element, Node): boolean} [beforeNodeMorphed]\n * @property {function(Element, Node): void} [afterNodeMorphed]\n * @property {function(Element): boolean} [beforeNodeRemoved]\n * @property {function(Element): void} [afterNodeRemoved]\n * @property {function(string, Element, \"update\" | \"remove\"): boolean} [beforeAttributeUpdated]\n */\n\n/**\n * @typedef {object} Config\n *\n * @property {'outerHTML' | 'innerHTML'} [morphStyle]\n * @property {boolean} [ignoreActive]\n * @property {boolean} [ignoreActiveValue]\n * @property {boolean} [restoreFocus]\n * @property {ConfigCallbacks} [callbacks]\n * @property {ConfigHead} [head]\n */\n\n/**\n * @typedef {function} NoOp\n *\n * @returns {void}\n */\n\n/**\n * @typedef {object} ConfigHeadInternal\n *\n * @property {'merge' | 'append' | 'morph' | 'none'} style\n * @property {boolean} [block]\n * @property {boolean} [ignore]\n * @property {(function(Element): boolean) | NoOp} shouldPreserve\n * @property {(function(Element): boolean) | NoOp} shouldReAppend\n * @property {(function(Element): boolean) | NoOp} shouldRemove\n * @property {(function(Element, {added: Node[], kept: Element[], removed: Element[]}): void) | NoOp} afterHeadMorphed\n */\n\n/**\n * @typedef {object} ConfigCallbacksInternal\n *\n * @property {(function(Node): boolean) | NoOp} beforeNodeAdded\n * @property {(function(Node): void) | NoOp} afterNodeAdded\n * @property {(function(Node, Node): boolean) | NoOp} beforeNodeMorphed\n * @property {(function(Node, Node): void) | NoOp} afterNodeMorphed\n * @property {(function(Node): boolean) | NoOp} beforeNodeRemoved\n * @property {(function(Node): void) | NoOp} afterNodeRemoved\n * @property {(function(string, Element, \"update\" | \"remove\"): boolean) | NoOp} beforeAttributeUpdated\n */\n\n/**\n * @typedef {object} ConfigInternal\n *\n * @property {'outerHTML' | 'innerHTML'} morphStyle\n * @property {boolean} [ignoreActive]\n * @property {boolean} [ignoreActiveValue]\n * @property {boolean} [restoreFocus]\n * @property {ConfigCallbacksInternal} callbacks\n * @property {ConfigHeadInternal} head\n */\n\n/**\n * @typedef {Object} IdSets\n * @property {Set<string>} persistentIds\n * @property {Map<Node, Set<string>>} idMap\n */\n\n/**\n * @typedef {Function} Morph\n *\n * @param {Element | Document} oldNode\n * @param {Element | Node | HTMLCollection | Node[] | string | null} newContent\n * @param {Config} [config]\n * @returns {undefined | Node[]}\n */\n\n// base IIFE to define idiomorph\n/**\n *\n * @type {{defaults: ConfigInternal, morph: Morph}}\n */\nvar Idiomorph = (function () {\n  \"use strict\";\n\n  /**\n   * @typedef {object} MorphContext\n   *\n   * @property {Element} target\n   * @property {Element} newContent\n   * @property {ConfigInternal} config\n   * @property {ConfigInternal['morphStyle']} morphStyle\n   * @property {ConfigInternal['ignoreActive']} ignoreActive\n   * @property {ConfigInternal['ignoreActiveValue']} ignoreActiveValue\n   * @property {ConfigInternal['restoreFocus']} restoreFocus\n   * @property {Map<Node, Set<string>>} idMap\n   * @property {Set<string>} persistentIds\n   * @property {ConfigInternal['callbacks']} callbacks\n   * @property {ConfigInternal['head']} head\n   * @property {HTMLDivElement} pantry\n   */\n\n  //=============================================================================\n  // AND NOW IT BEGINS...\n  //=============================================================================\n\n  const noOp = () => {};\n  /**\n   * Default configuration values, updatable by users now\n   * @type {ConfigInternal}\n   */\n  const defaults = {\n    morphStyle: \"outerHTML\",\n    callbacks: {\n      beforeNodeAdded: noOp,\n      afterNodeAdded: noOp,\n      beforeNodeMorphed: noOp,\n      afterNodeMorphed: noOp,\n      beforeNodeRemoved: noOp,\n      afterNodeRemoved: noOp,\n      beforeAttributeUpdated: noOp,\n    },\n    head: {\n      style: \"merge\",\n      shouldPreserve: (elt) => elt.getAttribute(\"im-preserve\") === \"true\",\n      shouldReAppend: (elt) => elt.getAttribute(\"im-re-append\") === \"true\",\n      shouldRemove: noOp,\n      afterHeadMorphed: noOp,\n    },\n    restoreFocus: true,\n  };\n\n  /**\n   * Core idiomorph function for morphing one DOM tree to another\n   *\n   * @param {Element | Document} oldNode\n   * @param {Element | Node | HTMLCollection | Node[] | string | null} newContent\n   * @param {Config} [config]\n   * @returns {Promise<Node[]> | Node[]}\n   */\n  function morph(oldNode, newContent, config = {}) {\n    oldNode = normalizeElement(oldNode);\n    const newNode = normalizeParent(newContent);\n    const ctx = createMorphContext(oldNode, newNode, config);\n\n    const morphedNodes = saveAndRestoreFocus(ctx, () => {\n      return withHeadBlocking(\n        ctx,\n        oldNode,\n        newNode,\n        /** @param {MorphContext} ctx */ (ctx) => {\n          if (ctx.morphStyle === \"innerHTML\") {\n            morphChildren(ctx, oldNode, newNode);\n            return Array.from(oldNode.childNodes);\n          } else {\n            return morphOuterHTML(ctx, oldNode, newNode);\n          }\n        },\n      );\n    });\n\n    ctx.pantry.remove();\n    return morphedNodes;\n  }\n\n  /**\n   * Morph just the outerHTML of the oldNode to the newContent\n   * We have to be careful because the oldNode could have siblings which need to be untouched\n   * @param {MorphContext} ctx\n   * @param {Element} oldNode\n   * @param {Element} newNode\n   * @returns {Node[]}\n   */\n  function morphOuterHTML(ctx, oldNode, newNode) {\n    const oldParent = normalizeParent(oldNode);\n    morphChildren(\n      ctx,\n      oldParent,\n      newNode,\n      // these two optional params are the secret sauce\n      oldNode, // start point for iteration\n      oldNode.nextSibling, // end point for iteration\n    );\n    // this is safe even with siblings, because normalizeParent returns a SlicedParentNode if needed.\n    return Array.from(oldParent.childNodes);\n  }\n\n  /**\n   * @param {MorphContext} ctx\n   * @param {Function} fn\n   * @returns {Promise<Node[]> | Node[]}\n   */\n  function saveAndRestoreFocus(ctx, fn) {\n    if (!ctx.config.restoreFocus) return fn();\n    let activeElement =\n      /** @type {HTMLInputElement|HTMLTextAreaElement|null} */ (\n        document.activeElement\n      );\n\n    // don't bother if the active element is not an input or textarea\n    if (\n      !(\n        activeElement instanceof HTMLInputElement ||\n        activeElement instanceof HTMLTextAreaElement\n      )\n    ) {\n      return fn();\n    }\n\n    const { id: activeElementId, selectionStart, selectionEnd } = activeElement;\n\n    const results = fn();\n\n    if (activeElementId && activeElementId !== document.activeElement?.id) {\n      activeElement = ctx.target.querySelector(`[id=\"${activeElementId}\"]`);\n      activeElement?.focus();\n    }\n    if (activeElement && !activeElement.selectionEnd && selectionEnd) {\n      activeElement.setSelectionRange(selectionStart, selectionEnd);\n    }\n\n    return results;\n  }\n\n  const morphChildren = (function () {\n    /**\n     * This is the core algorithm for matching up children.  The idea is to use id sets to try to match up\n     * nodes as faithfully as possible.  We greedily match, which allows us to keep the algorithm fast, but\n     * by using id sets, we are able to better match up with content deeper in the DOM.\n     *\n     * Basic algorithm:\n     * - for each node in the new content:\n     *   - search self and siblings for an id set match, falling back to a soft match\n     *   - if match found\n     *     - remove any nodes up to the match:\n     *       - pantry persistent nodes\n     *       - delete the rest\n     *     - morph the match\n     *   - elsif no match found, and node is persistent\n     *     - find its match by querying the old root (future) and pantry (past)\n     *     - move it and its children here\n     *     - morph it\n     *   - else\n     *     - create a new node from scratch as a last result\n     *\n     * @param {MorphContext} ctx the merge context\n     * @param {Element} oldParent the old content that we are merging the new content into\n     * @param {Element} newParent the parent element of the new content\n     * @param {Node|null} [insertionPoint] the point in the DOM we start morphing at (defaults to first child)\n     * @param {Node|null} [endPoint] the point in the DOM we stop morphing at (defaults to after last child)\n     */\n    function morphChildren(\n      ctx,\n      oldParent,\n      newParent,\n      insertionPoint = null,\n      endPoint = null,\n    ) {\n      // normalize\n      if (\n        oldParent instanceof HTMLTemplateElement &&\n        newParent instanceof HTMLTemplateElement\n      ) {\n        // @ts-ignore we can pretend the DocumentFragment is an Element\n        oldParent = oldParent.content;\n        // @ts-ignore ditto\n        newParent = newParent.content;\n      }\n      insertionPoint ||= oldParent.firstChild;\n\n      // run through all the new content\n      for (const newChild of newParent.childNodes) {\n        // once we reach the end of the old parent content skip to the end and insert the rest\n        if (insertionPoint && insertionPoint != endPoint) {\n          const bestMatch = findBestMatch(\n            ctx,\n            newChild,\n            insertionPoint,\n            endPoint,\n          );\n          if (bestMatch) {\n            // if the node to morph is not at the insertion point then remove/move up to it\n            if (bestMatch !== insertionPoint) {\n              removeNodesBetween(ctx, insertionPoint, bestMatch);\n            }\n            morphNode(bestMatch, newChild, ctx);\n            insertionPoint = bestMatch.nextSibling;\n            continue;\n          }\n        }\n\n        // if the matching node is elsewhere in the original content\n        if (newChild instanceof Element && ctx.persistentIds.has(newChild.id)) {\n          // move it and all its children here and morph\n          const movedChild = moveBeforeById(\n            oldParent,\n            newChild.id,\n            insertionPoint,\n            ctx,\n          );\n          morphNode(movedChild, newChild, ctx);\n          insertionPoint = movedChild.nextSibling;\n          continue;\n        }\n\n        // last resort: insert the new node from scratch\n        const insertedNode = createNode(\n          oldParent,\n          newChild,\n          insertionPoint,\n          ctx,\n        );\n        // could be null if beforeNodeAdded prevented insertion\n        if (insertedNode) {\n          insertionPoint = insertedNode.nextSibling;\n        }\n      }\n\n      // remove any remaining old nodes that didn't match up with new content\n      while (insertionPoint && insertionPoint != endPoint) {\n        const tempNode = insertionPoint;\n        insertionPoint = insertionPoint.nextSibling;\n        removeNode(ctx, tempNode);\n      }\n    }\n\n    /**\n     * This performs the action of inserting a new node while handling situations where the node contains\n     * elements with persistent ids and possible state info we can still preserve by moving in and then morphing\n     *\n     * @param {Element} oldParent\n     * @param {Node} newChild\n     * @param {Node|null} insertionPoint\n     * @param {MorphContext} ctx\n     * @returns {Node|null}\n     */\n    function createNode(oldParent, newChild, insertionPoint, ctx) {\n      if (ctx.callbacks.beforeNodeAdded(newChild) === false) return null;\n      if (ctx.idMap.has(newChild)) {\n        // node has children with ids with possible state so create a dummy elt of same type and apply full morph algorithm\n        const newEmptyChild = document.createElement(\n          /** @type {Element} */ (newChild).tagName,\n        );\n        oldParent.insertBefore(newEmptyChild, insertionPoint);\n        morphNode(newEmptyChild, newChild, ctx);\n        ctx.callbacks.afterNodeAdded(newEmptyChild);\n        return newEmptyChild;\n      } else {\n        // optimisation: no id state to preserve so we can just insert a clone of the newChild and its descendants\n        const newClonedChild = document.importNode(newChild, true); // importNode to not mutate newParent\n        oldParent.insertBefore(newClonedChild, insertionPoint);\n        ctx.callbacks.afterNodeAdded(newClonedChild);\n        return newClonedChild;\n      }\n    }\n\n    //=============================================================================\n    // Matching Functions\n    //=============================================================================\n    const findBestMatch = (function () {\n      /**\n       * Scans forward from the startPoint to the endPoint looking for a match\n       * for the node. It looks for an id set match first, then a soft match.\n       * We abort softmatching if we find two future soft matches, to reduce churn.\n       * @param {Node} node\n       * @param {MorphContext} ctx\n       * @param {Node | null} startPoint\n       * @param {Node | null} endPoint\n       * @returns {Node | null}\n       */\n      function findBestMatch(ctx, node, startPoint, endPoint) {\n        let softMatch = null;\n        let nextSibling = node.nextSibling;\n        let siblingSoftMatchCount = 0;\n\n        let cursor = startPoint;\n        while (cursor && cursor != endPoint) {\n          // soft matching is a prerequisite for id set matching\n          if (isSoftMatch(cursor, node)) {\n            if (isIdSetMatch(ctx, cursor, node)) {\n              return cursor; // found an id set match, we're done!\n            }\n\n            // we haven't yet saved a soft match fallback\n            if (softMatch === null) {\n              // the current soft match will hard match something else in the future, leave it\n              if (!ctx.idMap.has(cursor)) {\n                // save this as the fallback if we get through the loop without finding a hard match\n                softMatch = cursor;\n              }\n            }\n          }\n          if (\n            softMatch === null &&\n            nextSibling &&\n            isSoftMatch(cursor, nextSibling)\n          ) {\n            // The next new node has a soft match with this node, so\n            // increment the count of future soft matches\n            siblingSoftMatchCount++;\n            nextSibling = nextSibling.nextSibling;\n\n            // If there are two future soft matches, block soft matching for this node to allow\n            // future siblings to soft match. This is to reduce churn in the DOM when an element\n            // is prepended.\n            if (siblingSoftMatchCount >= 2) {\n              softMatch = undefined;\n            }\n          }\n\n          // if the current node contains active element, stop looking for better future matches,\n          // because if one is found, this node will be moved to the pantry, reparenting it and thus losing focus\n          if (cursor.contains(document.activeElement)) break;\n\n          cursor = cursor.nextSibling;\n        }\n\n        return softMatch || null;\n      }\n\n      /**\n       *\n       * @param {MorphContext} ctx\n       * @param {Node} oldNode\n       * @param {Node} newNode\n       * @returns {boolean}\n       */\n      function isIdSetMatch(ctx, oldNode, newNode) {\n        let oldSet = ctx.idMap.get(oldNode);\n        let newSet = ctx.idMap.get(newNode);\n\n        if (!newSet || !oldSet) return false;\n\n        for (const id of oldSet) {\n          // a potential match is an id in the new and old nodes that\n          // has not already been merged into the DOM\n          // But the newNode content we call this on has not been\n          // merged yet and we don't allow duplicate IDs so it is simple\n          if (newSet.has(id)) {\n            return true;\n          }\n        }\n        return false;\n      }\n\n      /**\n       *\n       * @param {Node} oldNode\n       * @param {Node} newNode\n       * @returns {boolean}\n       */\n      function isSoftMatch(oldNode, newNode) {\n        // ok to cast: if one is not element, `id` and `tagName` will be undefined and we'll just compare that.\n        const oldElt = /** @type {Element} */ (oldNode);\n        const newElt = /** @type {Element} */ (newNode);\n\n        return (\n          oldElt.nodeType === newElt.nodeType &&\n          oldElt.tagName === newElt.tagName &&\n          // If oldElt has an `id` with possible state and it doesn't match newElt.id then avoid morphing.\n          // We'll still match an anonymous node with an IDed newElt, though, because if it got this far,\n          // its not persistent, and new nodes can't have any hidden state.\n          (!oldElt.id || oldElt.id === newElt.id)\n        );\n      }\n\n      return findBestMatch;\n    })();\n\n    //=============================================================================\n    // DOM Manipulation Functions\n    //=============================================================================\n\n    /**\n     * Gets rid of an unwanted DOM node; strategy depends on nature of its reuse:\n     * - Persistent nodes will be moved to the pantry for later reuse\n     * - Other nodes will have their hooks called, and then are removed\n     * @param {MorphContext} ctx\n     * @param {Node} node\n     */\n    function removeNode(ctx, node) {\n      // are we going to id set match this later?\n      if (ctx.idMap.has(node)) {\n        // skip callbacks and move to pantry\n        moveBefore(ctx.pantry, node, null);\n      } else {\n        // remove for realsies\n        if (ctx.callbacks.beforeNodeRemoved(node) === false) return;\n        node.parentNode?.removeChild(node);\n        ctx.callbacks.afterNodeRemoved(node);\n      }\n    }\n\n    /**\n     * Remove nodes between the start and end nodes\n     * @param {MorphContext} ctx\n     * @param {Node} startInclusive\n     * @param {Node} endExclusive\n     * @returns {Node|null}\n     */\n    function removeNodesBetween(ctx, startInclusive, endExclusive) {\n      /** @type {Node | null} */\n      let cursor = startInclusive;\n      // remove nodes until the endExclusive node\n      while (cursor && cursor !== endExclusive) {\n        let tempNode = /** @type {Node} */ (cursor);\n        cursor = cursor.nextSibling;\n        removeNode(ctx, tempNode);\n      }\n      return cursor;\n    }\n\n    /**\n     * Search for an element by id within the document and pantry, and move it using moveBefore.\n     *\n     * @param {Element} parentNode - The parent node to which the element will be moved.\n     * @param {string} id - The ID of the element to be moved.\n     * @param {Node | null} after - The reference node to insert the element before.\n     *                              If `null`, the element is appended as the last child.\n     * @param {MorphContext} ctx\n     * @returns {Element} The found element\n     */\n    function moveBeforeById(parentNode, id, after, ctx) {\n      const target =\n        /** @type {Element} - will always be found */\n        (\n          (ctx.target.id === id && ctx.target) ||\n            ctx.target.querySelector(`[id=\"${id}\"]`) ||\n            ctx.pantry.querySelector(`[id=\"${id}\"]`)\n        );\n      removeElementFromAncestorsIdMaps(target, ctx);\n      moveBefore(parentNode, target, after);\n      return target;\n    }\n\n    /**\n     * Removes an element from its ancestors' id maps. This is needed when an element is moved from the\n     * \"future\" via `moveBeforeId`. Otherwise, its erstwhile ancestors could be mistakenly moved to the\n     * pantry rather than being deleted, preventing their removal hooks from being called.\n     *\n     * @param {Element} element - element to remove from its ancestors' id maps\n     * @param {MorphContext} ctx\n     */\n    function removeElementFromAncestorsIdMaps(element, ctx) {\n      const id = element.id;\n      /** @ts-ignore - safe to loop in this way **/\n      while ((element = element.parentNode)) {\n        let idSet = ctx.idMap.get(element);\n        if (idSet) {\n          idSet.delete(id);\n          if (!idSet.size) {\n            ctx.idMap.delete(element);\n          }\n        }\n      }\n    }\n\n    /**\n     * Moves an element before another element within the same parent.\n     * Uses the proposed `moveBefore` API if available (and working), otherwise falls back to `insertBefore`.\n     * This is essentialy a forward-compat wrapper.\n     *\n     * @param {Element} parentNode - The parent node containing the after element.\n     * @param {Node} element - The element to be moved.\n     * @param {Node | null} after - The reference node to insert `element` before.\n     *                              If `null`, `element` is appended as the last child.\n     */\n    function moveBefore(parentNode, element, after) {\n      // @ts-ignore - use proposed moveBefore feature\n      if (parentNode.moveBefore) {\n        try {\n          // @ts-ignore - use proposed moveBefore feature\n          parentNode.moveBefore(element, after);\n        } catch (e) {\n          // fall back to insertBefore as some browsers may fail on moveBefore when trying to move Dom disconnected nodes to pantry\n          parentNode.insertBefore(element, after);\n        }\n      } else {\n        parentNode.insertBefore(element, after);\n      }\n    }\n\n    return morphChildren;\n  })();\n\n  //=============================================================================\n  // Single Node Morphing Code\n  //=============================================================================\n  const morphNode = (function () {\n    /**\n     * @param {Node} oldNode root node to merge content into\n     * @param {Node} newContent new content to merge\n     * @param {MorphContext} ctx the merge context\n     * @returns {Node | null} the element that ended up in the DOM\n     */\n    function morphNode(oldNode, newContent, ctx) {\n      if (ctx.ignoreActive && oldNode === document.activeElement) {\n        // don't morph focused element\n        return null;\n      }\n\n      if (ctx.callbacks.beforeNodeMorphed(oldNode, newContent) === false) {\n        return oldNode;\n      }\n\n      if (oldNode instanceof HTMLHeadElement && ctx.head.ignore) {\n        // ignore the head element\n      } else if (\n        oldNode instanceof HTMLHeadElement &&\n        ctx.head.style !== \"morph\"\n      ) {\n        // ok to cast: if newContent wasn't also a <head>, it would've got caught in the `!isSoftMatch` branch above\n        handleHeadElement(\n          oldNode,\n          /** @type {HTMLHeadElement} */ (newContent),\n          ctx,\n        );\n      } else {\n        morphAttributes(oldNode, newContent, ctx);\n        if (!ignoreValueOfActiveElement(oldNode, ctx)) {\n          // @ts-ignore newContent can be a node here because .firstChild will be null\n          morphChildren(ctx, oldNode, newContent);\n        }\n      }\n      ctx.callbacks.afterNodeMorphed(oldNode, newContent);\n      return oldNode;\n    }\n\n    /**\n     * syncs the oldNode to the newNode, copying over all attributes and\n     * inner element state from the newNode to the oldNode\n     *\n     * @param {Node} oldNode the node to copy attributes & state to\n     * @param {Node} newNode the node to copy attributes & state from\n     * @param {MorphContext} ctx the merge context\n     */\n    function morphAttributes(oldNode, newNode, ctx) {\n      let type = newNode.nodeType;\n\n      // if is an element type, sync the attributes from the\n      // new node into the new node\n      if (type === 1 /* element type */) {\n        const oldElt = /** @type {Element} */ (oldNode);\n        const newElt = /** @type {Element} */ (newNode);\n\n        const oldAttributes = oldElt.attributes;\n        const newAttributes = newElt.attributes;\n        for (const newAttribute of newAttributes) {\n          if (ignoreAttribute(newAttribute.name, oldElt, \"update\", ctx)) {\n            continue;\n          }\n          if (oldElt.getAttribute(newAttribute.name) !== newAttribute.value) {\n            oldElt.setAttribute(newAttribute.name, newAttribute.value);\n          }\n        }\n        // iterate backwards to avoid skipping over items when a delete occurs\n        for (let i = oldAttributes.length - 1; 0 <= i; i--) {\n          const oldAttribute = oldAttributes[i];\n\n          // toAttributes is a live NamedNodeMap, so iteration+mutation is unsafe\n          // e.g. custom element attribute callbacks can remove other attributes\n          if (!oldAttribute) continue;\n\n          if (!newElt.hasAttribute(oldAttribute.name)) {\n            if (ignoreAttribute(oldAttribute.name, oldElt, \"remove\", ctx)) {\n              continue;\n            }\n            oldElt.removeAttribute(oldAttribute.name);\n          }\n        }\n\n        if (!ignoreValueOfActiveElement(oldElt, ctx)) {\n          syncInputValue(oldElt, newElt, ctx);\n        }\n      }\n\n      // sync text nodes\n      if (type === 8 /* comment */ || type === 3 /* text */) {\n        if (oldNode.nodeValue !== newNode.nodeValue) {\n          oldNode.nodeValue = newNode.nodeValue;\n        }\n      }\n    }\n\n    /**\n     * NB: many bothans died to bring us information:\n     *\n     *  https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n     *  https://github.com/choojs/nanomorph/blob/master/lib/morph.jsL113\n     *\n     * @param {Element} oldElement the element to sync the input value to\n     * @param {Element} newElement the element to sync the input value from\n     * @param {MorphContext} ctx the merge context\n     */\n    function syncInputValue(oldElement, newElement, ctx) {\n      if (\n        oldElement instanceof HTMLInputElement &&\n        newElement instanceof HTMLInputElement &&\n        newElement.type !== \"file\"\n      ) {\n        let newValue = newElement.value;\n        let oldValue = oldElement.value;\n\n        // sync boolean attributes\n        syncBooleanAttribute(oldElement, newElement, \"checked\", ctx);\n        syncBooleanAttribute(oldElement, newElement, \"disabled\", ctx);\n\n        if (!newElement.hasAttribute(\"value\")) {\n          if (!ignoreAttribute(\"value\", oldElement, \"remove\", ctx)) {\n            oldElement.value = \"\";\n            oldElement.removeAttribute(\"value\");\n          }\n        } else if (oldValue !== newValue) {\n          if (!ignoreAttribute(\"value\", oldElement, \"update\", ctx)) {\n            oldElement.setAttribute(\"value\", newValue);\n            oldElement.value = newValue;\n          }\n        }\n        // TODO: QUESTION(1cg): this used to only check `newElement` unlike the other branches -- why?\n        // did I break something?\n      } else if (\n        oldElement instanceof HTMLOptionElement &&\n        newElement instanceof HTMLOptionElement\n      ) {\n        syncBooleanAttribute(oldElement, newElement, \"selected\", ctx);\n      } else if (\n        oldElement instanceof HTMLTextAreaElement &&\n        newElement instanceof HTMLTextAreaElement\n      ) {\n        let newValue = newElement.value;\n        let oldValue = oldElement.value;\n        if (ignoreAttribute(\"value\", oldElement, \"update\", ctx)) {\n          return;\n        }\n        if (newValue !== oldValue) {\n          oldElement.value = newValue;\n        }\n        if (\n          oldElement.firstChild &&\n          oldElement.firstChild.nodeValue !== newValue\n        ) {\n          oldElement.firstChild.nodeValue = newValue;\n        }\n      }\n    }\n\n    /**\n     * @param {Element} oldElement element to write the value to\n     * @param {Element} newElement element to read the value from\n     * @param {string} attributeName the attribute name\n     * @param {MorphContext} ctx the merge context\n     */\n    function syncBooleanAttribute(oldElement, newElement, attributeName, ctx) {\n      // @ts-ignore this function is only used on boolean attrs that are reflected as dom properties\n      const newLiveValue = newElement[attributeName],\n        // @ts-ignore ditto\n        oldLiveValue = oldElement[attributeName];\n      if (newLiveValue !== oldLiveValue) {\n        const ignoreUpdate = ignoreAttribute(\n          attributeName,\n          oldElement,\n          \"update\",\n          ctx,\n        );\n        if (!ignoreUpdate) {\n          // update attribute's associated DOM property\n          // @ts-ignore this function is only used on boolean attrs that are reflected as dom properties\n          oldElement[attributeName] = newElement[attributeName];\n        }\n        if (newLiveValue) {\n          if (!ignoreUpdate) {\n            // https://developer.mozilla.org/en-US/docs/Glossary/Boolean/HTML\n            // this is the correct way to set a boolean attribute to \"true\"\n            oldElement.setAttribute(attributeName, \"\");\n          }\n        } else {\n          if (!ignoreAttribute(attributeName, oldElement, \"remove\", ctx)) {\n            oldElement.removeAttribute(attributeName);\n          }\n        }\n      }\n    }\n\n    /**\n     * @param {string} attr the attribute to be mutated\n     * @param {Element} element the element that is going to be updated\n     * @param {\"update\" | \"remove\"} updateType\n     * @param {MorphContext} ctx the merge context\n     * @returns {boolean} true if the attribute should be ignored, false otherwise\n     */\n    function ignoreAttribute(attr, element, updateType, ctx) {\n      if (\n        attr === \"value\" &&\n        ctx.ignoreActiveValue &&\n        element === document.activeElement\n      ) {\n        return true;\n      }\n      return (\n        ctx.callbacks.beforeAttributeUpdated(attr, element, updateType) ===\n        false\n      );\n    }\n\n    /**\n     * @param {Node} possibleActiveElement\n     * @param {MorphContext} ctx\n     * @returns {boolean}\n     */\n    function ignoreValueOfActiveElement(possibleActiveElement, ctx) {\n      return (\n        !!ctx.ignoreActiveValue &&\n        possibleActiveElement === document.activeElement &&\n        possibleActiveElement !== document.body\n      );\n    }\n\n    return morphNode;\n  })();\n\n  //=============================================================================\n  // Head Management Functions\n  //=============================================================================\n  /**\n   * @param {MorphContext} ctx\n   * @param {Element} oldNode\n   * @param {Element} newNode\n   * @param {function} callback\n   * @returns {Node[] | Promise<Node[]>}\n   */\n  function withHeadBlocking(ctx, oldNode, newNode, callback) {\n    if (ctx.head.block) {\n      const oldHead = oldNode.querySelector(\"head\");\n      const newHead = newNode.querySelector(\"head\");\n      if (oldHead && newHead) {\n        const promises = handleHeadElement(oldHead, newHead, ctx);\n        // when head promises resolve, proceed ignoring the head tag\n        return Promise.all(promises).then(() => {\n          const newCtx = Object.assign(ctx, {\n            head: {\n              block: false,\n              ignore: true,\n            },\n          });\n          return callback(newCtx);\n        });\n      }\n    }\n    // just proceed if we not head blocking\n    return callback(ctx);\n  }\n\n  /**\n   *  The HEAD tag can be handled specially, either w/ a 'merge' or 'append' style\n   *\n   * @param {Element} oldHead\n   * @param {Element} newHead\n   * @param {MorphContext} ctx\n   * @returns {Promise<void>[]}\n   */\n  function handleHeadElement(oldHead, newHead, ctx) {\n    let added = [];\n    let removed = [];\n    let preserved = [];\n    let nodesToAppend = [];\n\n    // put all new head elements into a Map, by their outerHTML\n    let srcToNewHeadNodes = new Map();\n    for (const newHeadChild of newHead.children) {\n      srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild);\n    }\n\n    // for each elt in the current head\n    for (const currentHeadElt of oldHead.children) {\n      // If the current head element is in the map\n      let inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML);\n      let isReAppended = ctx.head.shouldReAppend(currentHeadElt);\n      let isPreserved = ctx.head.shouldPreserve(currentHeadElt);\n      if (inNewContent || isPreserved) {\n        if (isReAppended) {\n          // remove the current version and let the new version replace it and re-execute\n          removed.push(currentHeadElt);\n        } else {\n          // this element already exists and should not be re-appended, so remove it from\n          // the new content map, preserving it in the DOM\n          srcToNewHeadNodes.delete(currentHeadElt.outerHTML);\n          preserved.push(currentHeadElt);\n        }\n      } else {\n        if (ctx.head.style === \"append\") {\n          // we are appending and this existing element is not new content\n          // so if and only if it is marked for re-append do we do anything\n          if (isReAppended) {\n            removed.push(currentHeadElt);\n            nodesToAppend.push(currentHeadElt);\n          }\n        } else {\n          // if this is a merge, we remove this content since it is not in the new head\n          if (ctx.head.shouldRemove(currentHeadElt) !== false) {\n            removed.push(currentHeadElt);\n          }\n        }\n      }\n    }\n\n    // Push the remaining new head elements in the Map into the\n    // nodes to append to the head tag\n    nodesToAppend.push(...srcToNewHeadNodes.values());\n\n    let promises = [];\n    for (const newNode of nodesToAppend) {\n      // TODO: This could theoretically be null, based on type\n      let newElt = /** @type {ChildNode} */ (\n        document.createRange().createContextualFragment(newNode.outerHTML)\n          .firstChild\n      );\n      if (ctx.callbacks.beforeNodeAdded(newElt) !== false) {\n        if (\n          (\"href\" in newElt && newElt.href) ||\n          (\"src\" in newElt && newElt.src)\n        ) {\n          /** @type {(result?: any) => void} */ let resolve;\n          let promise = new Promise(function (_resolve) {\n            resolve = _resolve;\n          });\n          newElt.addEventListener(\"load\", function () {\n            resolve();\n          });\n          promises.push(promise);\n        }\n        oldHead.appendChild(newElt);\n        ctx.callbacks.afterNodeAdded(newElt);\n        added.push(newElt);\n      }\n    }\n\n    // remove all removed elements, after we have appended the new elements to avoid\n    // additional network requests for things like style sheets\n    for (const removedElement of removed) {\n      if (ctx.callbacks.beforeNodeRemoved(removedElement) !== false) {\n        oldHead.removeChild(removedElement);\n        ctx.callbacks.afterNodeRemoved(removedElement);\n      }\n    }\n\n    ctx.head.afterHeadMorphed(oldHead, {\n      added: added,\n      kept: preserved,\n      removed: removed,\n    });\n    return promises;\n  }\n\n  //=============================================================================\n  // Create Morph Context Functions\n  //=============================================================================\n  const createMorphContext = (function () {\n    /**\n     *\n     * @param {Element} oldNode\n     * @param {Element} newContent\n     * @param {Config} config\n     * @returns {MorphContext}\n     */\n    function createMorphContext(oldNode, newContent, config) {\n      const { persistentIds, idMap } = createIdMaps(oldNode, newContent);\n\n      const mergedConfig = mergeDefaults(config);\n      const morphStyle = mergedConfig.morphStyle || \"outerHTML\";\n      if (![\"innerHTML\", \"outerHTML\"].includes(morphStyle)) {\n        throw `Do not understand how to morph style ${morphStyle}`;\n      }\n\n      return {\n        target: oldNode,\n        newContent: newContent,\n        config: mergedConfig,\n        morphStyle: morphStyle,\n        ignoreActive: mergedConfig.ignoreActive,\n        ignoreActiveValue: mergedConfig.ignoreActiveValue,\n        restoreFocus: mergedConfig.restoreFocus,\n        idMap: idMap,\n        persistentIds: persistentIds,\n        pantry: createPantry(),\n        callbacks: mergedConfig.callbacks,\n        head: mergedConfig.head,\n      };\n    }\n\n    /**\n     * Deep merges the config object and the Idiomorph.defaults object to\n     * produce a final configuration object\n     * @param {Config} config\n     * @returns {ConfigInternal}\n     */\n    function mergeDefaults(config) {\n      let finalConfig = Object.assign({}, defaults);\n\n      // copy top level stuff into final config\n      Object.assign(finalConfig, config);\n\n      // copy callbacks into final config (do this to deep merge the callbacks)\n      finalConfig.callbacks = Object.assign(\n        {},\n        defaults.callbacks,\n        config.callbacks,\n      );\n\n      // copy head config into final config  (do this to deep merge the head)\n      finalConfig.head = Object.assign({}, defaults.head, config.head);\n\n      return finalConfig;\n    }\n\n    /**\n     * @returns {HTMLDivElement}\n     */\n    function createPantry() {\n      const pantry = document.createElement(\"div\");\n      pantry.hidden = true;\n      document.body.insertAdjacentElement(\"afterend\", pantry);\n      return pantry;\n    }\n\n    /**\n     * Returns all elements with an ID contained within the root element and its descendants\n     *\n     * @param {Element} root\n     * @returns {Element[]}\n     */\n    function findIdElements(root) {\n      let elements = Array.from(root.querySelectorAll(\"[id]\"));\n      if (root.id) {\n        elements.push(root);\n      }\n      return elements;\n    }\n\n    /**\n     * A bottom-up algorithm that populates a map of Element -> IdSet.\n     * The idSet for a given element is the set of all IDs contained within its subtree.\n     * As an optimzation, we filter these IDs through the given list of persistent IDs,\n     * because we don't need to bother considering IDed elements that won't be in the new content.\n     *\n     * @param {Map<Node, Set<string>>} idMap\n     * @param {Set<string>} persistentIds\n     * @param {Element} root\n     * @param {Element[]} elements\n     */\n    function populateIdMapWithTree(idMap, persistentIds, root, elements) {\n      for (const elt of elements) {\n        if (persistentIds.has(elt.id)) {\n          /** @type {Element|null} */\n          let current = elt;\n          // walk up the parent hierarchy of that element, adding the id\n          // of element to the parent's id set\n          while (current) {\n            let idSet = idMap.get(current);\n            // if the id set doesn't exist, create it and insert it in the map\n            if (idSet == null) {\n              idSet = new Set();\n              idMap.set(current, idSet);\n            }\n            idSet.add(elt.id);\n\n            if (current === root) break;\n            current = current.parentElement;\n          }\n        }\n      }\n    }\n\n    /**\n     * This function computes a map of nodes to all ids contained within that node (inclusive of the\n     * node).  This map can be used to ask if two nodes have intersecting sets of ids, which allows\n     * for a looser definition of \"matching\" than tradition id matching, and allows child nodes\n     * to contribute to a parent nodes matching.\n     *\n     * @param {Element} oldContent  the old content that will be morphed\n     * @param {Element} newContent  the new content to morph to\n     * @returns {IdSets}\n     */\n    function createIdMaps(oldContent, newContent) {\n      const oldIdElements = findIdElements(oldContent);\n      const newIdElements = findIdElements(newContent);\n\n      const persistentIds = createPersistentIds(oldIdElements, newIdElements);\n\n      /** @type {Map<Node, Set<string>>} */\n      let idMap = new Map();\n      populateIdMapWithTree(idMap, persistentIds, oldContent, oldIdElements);\n\n      /** @ts-ignore - if newContent is a duck-typed parent, pass its single child node as the root to halt upwards iteration */\n      const newRoot = newContent.__idiomorphRoot || newContent;\n      populateIdMapWithTree(idMap, persistentIds, newRoot, newIdElements);\n\n      return { persistentIds, idMap };\n    }\n\n    /**\n     * This function computes the set of ids that persist between the two contents excluding duplicates\n     *\n     * @param {Element[]} oldIdElements\n     * @param {Element[]} newIdElements\n     * @returns {Set<string>}\n     */\n    function createPersistentIds(oldIdElements, newIdElements) {\n      let duplicateIds = new Set();\n\n      /** @type {Map<string, string>} */\n      let oldIdTagNameMap = new Map();\n      for (const { id, tagName } of oldIdElements) {\n        if (oldIdTagNameMap.has(id)) {\n          duplicateIds.add(id);\n        } else {\n          oldIdTagNameMap.set(id, tagName);\n        }\n      }\n\n      let persistentIds = new Set();\n      for (const { id, tagName } of newIdElements) {\n        if (persistentIds.has(id)) {\n          duplicateIds.add(id);\n        } else if (oldIdTagNameMap.get(id) === tagName) {\n          persistentIds.add(id);\n        }\n        // skip if tag types mismatch because its not possible to morph one tag into another\n      }\n\n      for (const id of duplicateIds) {\n        persistentIds.delete(id);\n      }\n      return persistentIds;\n    }\n\n    return createMorphContext;\n  })();\n\n  //=============================================================================\n  // HTML Normalization Functions\n  //=============================================================================\n  const { normalizeElement, normalizeParent } = (function () {\n    /** @type {WeakSet<Node>} */\n    const generatedByIdiomorph = new WeakSet();\n\n    /**\n     *\n     * @param {Element | Document} content\n     * @returns {Element}\n     */\n    function normalizeElement(content) {\n      if (content instanceof Document) {\n        return content.documentElement;\n      } else {\n        return content;\n      }\n    }\n\n    /**\n     *\n     * @param {null | string | Node | HTMLCollection | Node[] | Document & {generatedByIdiomorph:boolean}} newContent\n     * @returns {Element}\n     */\n    function normalizeParent(newContent) {\n      if (newContent == null) {\n        return document.createElement(\"div\"); // dummy parent element\n      } else if (typeof newContent === \"string\") {\n        return normalizeParent(parseContent(newContent));\n      } else if (\n        generatedByIdiomorph.has(/** @type {Element} */ (newContent))\n      ) {\n        // the template tag created by idiomorph parsing can serve as a dummy parent\n        return /** @type {Element} */ (newContent);\n      } else if (newContent instanceof Node) {\n        if (newContent.parentNode) {\n          // we can't use the parent directly because newContent may have siblings\n          // that we don't want in the morph, and reparenting might be expensive (TODO is it?),\n          // so instead we create a fake parent node that only sees a slice of its children.\n          /** @type {Element} */\n          return /** @type {any} */ (new SlicedParentNode(newContent));\n        } else {\n          // a single node is added as a child to a dummy parent\n          const dummyParent = document.createElement(\"div\");\n          dummyParent.append(newContent);\n          return dummyParent;\n        }\n      } else {\n        // all nodes in the array or HTMLElement collection are consolidated under\n        // a single dummy parent element\n        const dummyParent = document.createElement(\"div\");\n        for (const elt of [...newContent]) {\n          dummyParent.append(elt);\n        }\n        return dummyParent;\n      }\n    }\n\n    /**\n     * A fake duck-typed parent element to wrap a single node, without actually reparenting it.\n     * This is useful because the node may have siblings that we don't want in the morph, and it may also be moved\n     * or replaced with one or more elements during the morph. This class effectively allows us a window into\n     * a slice of a node's children.\n     * \"If it walks like a duck, and quacks like a duck, then it must be a duck!\" -- James Whitcomb Riley (1849â€“1916)\n     */\n    class SlicedParentNode {\n      /** @param {Node} node */\n      constructor(node) {\n        this.originalNode = node;\n        this.realParentNode = /** @type {Element} */ (node.parentNode);\n        this.previousSibling = node.previousSibling;\n        this.nextSibling = node.nextSibling;\n      }\n\n      /** @returns {Node[]} */\n      get childNodes() {\n        // return slice of realParent's current childNodes, based on previousSibling and nextSibling\n        const nodes = [];\n        let cursor = this.previousSibling\n          ? this.previousSibling.nextSibling\n          : this.realParentNode.firstChild;\n        while (cursor && cursor != this.nextSibling) {\n          nodes.push(cursor);\n          cursor = cursor.nextSibling;\n        }\n        return nodes;\n      }\n\n      /**\n       * @param {string} selector\n       * @returns {Element[]}\n       */\n      querySelectorAll(selector) {\n        return this.childNodes.reduce((results, node) => {\n          if (node instanceof Element) {\n            if (node.matches(selector)) results.push(node);\n            const nodeList = node.querySelectorAll(selector);\n            for (let i = 0; i < nodeList.length; i++) {\n              results.push(nodeList[i]);\n            }\n          }\n          return results;\n        }, /** @type {Element[]} */ ([]));\n      }\n\n      /**\n       * @param {Node} node\n       * @param {Node} referenceNode\n       * @returns {Node}\n       */\n      insertBefore(node, referenceNode) {\n        return this.realParentNode.insertBefore(node, referenceNode);\n      }\n\n      /**\n       * @param {Node} node\n       * @param {Node} referenceNode\n       * @returns {Node}\n       */\n      moveBefore(node, referenceNode) {\n        // @ts-ignore - use new moveBefore feature\n        return this.realParentNode.moveBefore(node, referenceNode);\n      }\n\n      /**\n       * for later use with populateIdMapWithTree to halt upwards iteration\n       * @returns {Node}\n       */\n      get __idiomorphRoot() {\n        return this.originalNode;\n      }\n    }\n\n    /**\n     *\n     * @param {string} newContent\n     * @returns {Node | null | DocumentFragment}\n     */\n    function parseContent(newContent) {\n      let parser = new DOMParser();\n\n      // remove svgs to avoid false-positive matches on head, etc.\n      let contentWithSvgsRemoved = newContent.replace(\n        /<svg(\\s[^>]*>|>)([\\s\\S]*?)<\\/svg>/gim,\n        \"\",\n      );\n\n      // if the newContent contains a html, head or body tag, we can simply parse it w/o wrapping\n      if (\n        contentWithSvgsRemoved.match(/<\\/html>/) ||\n        contentWithSvgsRemoved.match(/<\\/head>/) ||\n        contentWithSvgsRemoved.match(/<\\/body>/)\n      ) {\n        let content = parser.parseFromString(newContent, \"text/html\");\n        // if it is a full HTML document, return the document itself as the parent container\n        if (contentWithSvgsRemoved.match(/<\\/html>/)) {\n          generatedByIdiomorph.add(content);\n          return content;\n        } else {\n          // otherwise return the html element as the parent container\n          let htmlElement = content.firstChild;\n          if (htmlElement) {\n            generatedByIdiomorph.add(htmlElement);\n          }\n          return htmlElement;\n        }\n      } else {\n        // if it is partial HTML, wrap it in a template tag to provide a parent element and also to help\n        // deal with touchy tags like tr, tbody, etc.\n        let responseDoc = parser.parseFromString(\n          \"<body><template>\" + newContent + \"</template></body>\",\n          \"text/html\",\n        );\n        let content = /** @type {HTMLTemplateElement} */ (\n          responseDoc.body.querySelector(\"template\")\n        ).content;\n        generatedByIdiomorph.add(content);\n        return content;\n      }\n    }\n\n    return { normalizeElement, normalizeParent };\n  })();\n\n  //=============================================================================\n  // This is what ends up becoming the Idiomorph global object\n  //=============================================================================\n  return {\n    morph,\n    defaults,\n  };\n})();\n\nexport {Idiomorph};\n","\nconst topics: any = {}\nconst _async: any = {}\n\nexport const publish = (name, params) => {\n\n\t_async[name] = isObject(params)? Object.assign({}, _async[name], params): params\n\n\tif (topics[name]) {\n\t\ttopics[name].forEach(topic => topic(params))\n\t}\n}\n\nexport const subscribe = (name, method) => {\n\ttopics[name] = topics[name] || []\n\ttopics[name].push(method)\n\tif (name in _async) {\n\t\tmethod(_async[name])\n\t}\n\treturn () => {\n\t\ttopics[name] = topics[name].filter( fn => fn != method )\n\t}\n}\n\nconst isObject = (value) => {\n\treturn (typeof value === 'object' && value !== null && !Array.isArray(value))\n}\n","import { safe, g, dup } from './utils'\nimport { Idiomorph } from 'idiomorph/dist/idiomorph.esm'\nimport { publish, subscribe } from './utils/pubsub'\n\nexport const Component = ({ name, module, dependencies, node, templates, signal, register }) => {\n\n\tlet tick\n\tlet preserve\t\t= []\n\tlet observer \t\t= null\n\tlet observables \t= []\n\tlet effect \t\t\t= null\n\n\tconst _model \t\t= module.model || {}\n\tconst initialState \t= (new Function( `return ${node.getAttribute('html-model') || '{}'}`))()\n\tconst tplid \t\t= node.getAttribute('tplid')\n\tconst scopeid \t\t= node.getAttribute('html-scopeid')\n\tconst tpl \t\t\t= templates[ tplid ]\n\tconst scope \t\t= g.scope[ scopeid ]\n\tconst model  \t\t= dup(module?.model?.apply ? _model({ elm:node, initialState, dependencies }) : _model)\n\tconst state \t\t= Object.assign({}, scope, model, initialState)\n\tconst view \t\t\t= module.view? module.view : (data) => data\n\n\tconst base = {\n\t\tname,\n\t\tmodel,\n\t\telm: node,\n\t\ttemplate: tpl.template,\n\t\tdependencies,\n\t\tpublish,\n\t\tsubscribe,\n\n\t\tmain(fn) {\n\t\t\tnode.addEventListener(':mount', fn)\n\t\t},\n\n\t\teffect(fn) {\n\t\t\tif( fn ) {\n\t\t\t\teffect = fn\n\t\t\t} else {\n\t\t\t\treturn effect\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @State\n\t\t */\n\t\tstate : {\n\n\t\t\tprotected( list ) {\n\t\t\t\tif( list ) {\n\t\t\t\t\tpreserve = list\n\t\t\t\t} else {\n\t\t\t\t\treturn preserve\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tsave(data) {\n\t\t\t\tif( data.constructor === Function ) {\n\t\t\t\t\tdata( state )\n\t\t\t\t} else {\n\t\t\t\t\tObject.assign(state, data)\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tset( data ) {\n\n\t\t\t\tif (!document.body.contains(node)) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif( data.constructor === Function ) {\n\t\t\t\t\tdata(state)\n\t\t\t\t} else {\n\t\t\t\t\tObject.assign(state, data)\n\t\t\t\t}\n\n\t\t\t\tconst newstate = Object.assign({}, state, scope)\n\n\t\t\t\treturn new Promise((resolve) => {\n\t\t\t\t\trender(newstate, () => resolve(newstate))\n\t\t\t\t})\n\t\t\t},\n\n\t\t\tget() {\n\t\t\t\treturn Object.assign({}, state)\n\t\t\t}\n\t\t},\n\n\t\tdataset( target, name ) {\n\n\t\t\tconst el = name? target : node\n\t\t\tconst key = name? name : target\n\t\t\tconst value = el.dataset[key]\n\n\t\t\tif (value === 'true') return true\n\t\t\tif (value === 'false') return false\n\t\t\tif (!isNaN(value) && value.trim() !== '') return Number(value)\n\n\t\t\ttry {\n\t\t\t\treturn new Function('return (' + value + ')')()\n\t\t\t} catch {}\n\n\t\t\ttry {\n\t\t\t\treturn JSON.parse(value)\n\t\t\t} catch {}\n\n\t\t\treturn value\n\t\t},\n\n\t\t/**\n\t\t * @Events\n\t\t */\n\t\ton( ev, selectorOrCallback, callback ) {\n\n\t\t\tconst attribute = ev.match(/\\[(.*)\\]/)\n\n\t\t\tif( attribute ) {\n\t\t\t\tobservables.push({\n\t\t\t\t\ttarget: callback? selectorOrCallback : null,\n\t\t\t\t\tcallback: callback || selectorOrCallback\n\t\t\t\t})\n\n\t\t\t\tif( !observer ) {\n\t\t\t\t\tobserver = new MutationObserver((mutationsList) => {\n\t\t\t\t\t\tfor (const mutation of mutationsList) {\n\t\t\t\t\t\t\tif (mutation.type === 'attributes') {\n\t\t\t\t\t\t\t\tconst attrname = mutation.attributeName\n\t\t\t\t\t\t\t\tif( attrname === attribute[1] ) {\n\t\t\t\t\t\t\t\t\tobservables.forEach( item => {\n\t\t\t\t\t\t\t\t\t\tconst target = item.target? node.querySelectorAll(item.target): [node]\n\t\t\t\t\t\t\t\t\t\ttarget.forEach( target => {\n\t\t\t\t\t\t\t\t\t\t\tif( target == mutation.target ) {\n\t\t\t\t\t\t\t\t\t\t\t\titem.callback({\n\t\t\t\t\t\t\t\t\t\t\t\t\ttarget: mutation.target,\n\t\t\t\t\t\t\t\t\t\t\t\t\tattribute: attrname,\n\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: mutation.target.getAttribute(attrname)\n\t\t\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\n\t\t\t\t\tobserver.observe(node, {\n\t\t\t\t\t\tattributes: true,\n\t\t\t\t\t\tsubtree: true\n\t\t\t\t\t})\n\n\t\t\t\t\tnode.addEventListener(':unmount', () => {\n\t\t\t\t\t\tobservables = []\n\t\t\t\t\t\tobserver.disconnect()\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif( callback ) {\n\t\t\t\tcallback.handler = (e) => {\n\t\t\t\t\tconst detail = e.detail || {}\n\t\t\t\t\tlet parent = e.target\n\t\t\t\t\twhile (parent) {\n\t\t\t\t\t\tif (parent.matches(selectorOrCallback)) {\n\t\t\t\t\t\t\te.delegateTarget = parent\n\t\t\t\t\t\t\tcallback.apply(node, [e].concat(detail.args))\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (parent === node) break\n\t\t\t\t\t\tparent = parent.parentNode\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnode.addEventListener(ev, callback.handler, {\n\t\t\t\t\tsignal,\n\t\t\t\t\tcapture: (ev == 'focus' || ev == 'blur' || ev == 'mouseenter' || ev == 'mouseleave')\n\t\t\t\t})\n\n\t\t\t} else {\n\t\t\t\tselectorOrCallback.handler = (e) => {\n\t\t\t\t\te.delegateTarget = node\n\t\t\t\t\tselectorOrCallback.apply(node, [e].concat(e.detail.args))\n\t\t\t\t}\n\t\t\t\tnode.addEventListener(ev, selectorOrCallback.handler, { signal })\n\t\t\t}\n\n\t\t},\n\n\t\toff( ev, callback ) {\n\t\t\tif( callback.handler ) {\n\t\t\t\tnode.removeEventListener(ev, callback.handler)\n\t\t\t}\n\t\t},\n\n\t\ttrigger(ev, selectorOrCallback, data) {\n\t\t\tif( selectorOrCallback.constructor === String ) {\n\t\t\t\tArray\n\t\t\t\t\t.from(node.querySelectorAll(selectorOrCallback))\n\t\t\t\t\t.forEach( children => {\n\t\t\t\t\t\tchildren.dispatchEvent(new CustomEvent(ev, { bubbles: true, detail: { args: data } }) )\n\t\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tnode.dispatchEvent(new CustomEvent(ev, { bubbles: true, detail:{ args: data } }))\n\t\t\t}\n\t\t},\n\n\t\temit(ev, data) {\n\t\t\tnode.dispatchEvent(new CustomEvent(ev, { bubbles: true, detail: { args: data } }))\n\t\t},\n\n\t\tunmount( fn ) {\n\t\t\tnode.addEventListener(':unmount', fn)\n\t\t},\n\n\t\tinnerHTML ( target, html_ ) {\n\t\t\tconst element = html_? target : node\n\t\t\tconst clone = element.cloneNode()\n\t\t\tconst html = html_? html_ : target\n\t\t\tclone.innerHTML = html\n\t\t\tIdiomorph.morph(element, clone)\n\t\t}\n\t}\n\n\tconst render = ( data, callback = (() => {}) ) => {\n\t\tclearTimeout( tick )\n\t\ttick = setTimeout(() => {\n\t\t\tconst html = tpl.render.call({...data, ...view(data)}, node, safe, g )\n\t\t\tIdiomorph.morph( node, html, IdiomorphOptions(node, register) )\n\t\t\tPromise.resolve().then(() => {\n\t\t\t\tnode.querySelectorAll('[tplid]')\n\t\t\t\t\t.forEach((element) => {\n\t\t\t\t\t\tconst child = register.get(element)\n\t\t\t\t\t\tif(!child) return\n\t\t\t\t\t\tchild.state.protected().forEach( key => delete data[key] )\n\t\t\t\t\t\tconst useEffect = child.effect()\n\t\t\t\t\t\tif( useEffect ) {\n\t\t\t\t\t\t\tconst promise = useEffect(data)\n\t\t\t\t\t\t\tif( promise && promise.then ) {\n\t\t\t\t\t\t\t\tpromise.then(() => child.state.set(data))\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tchild.state.set(data)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tchild.state.set(data)\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\tPromise.resolve().then(() => {\n\t\t\t\t\tg.scope = {}\n\t\t\t\t\tcallback()\n\t\t\t\t})\n\t\t\t})\n\t\t})\n\t}\n\n\trender( state )\n\tregister.set( node, base )\n\treturn module.default( base )\n}\n\nconst IdiomorphOptions = ( parent, register ) => ({\n\tcallbacks: {\n\t\tbeforeNodeMorphed( node ) {\n\t\t\tif( node.nodeType === 1 ) {\n\t\t\t\tif( 'html-static' in node.attributes ) {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\tif( register.get(node) && node !== parent ) {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n})\n","import { Component } from './component'\n\nconst register = new WeakMap()\n\nexport const Element = ({ component, templates, start }) => {\n\n\tconst { name, module, dependencies } = component\n\n\treturn class extends HTMLElement {\n\n\t\tconstructor() {\n\t\t\tsuper()\n\t\t}\n\n\t\tconnectedCallback() {\n\n\t\t\tthis.abortController = new AbortController()\n\n\t\t\tif( !this.getAttribute('tplid') ) {\n\t\t\t\tstart( this.parentNode )\n\t\t\t}\n\n\t\t\tconst rtrn = Component({\n\t\t\t\tnode:this,\n\t\t\t\tname,\n\t\t\t\tmodule,\n\t\t\t\tdependencies,\n\t\t\t\ttemplates,\n\t\t\t\tsignal: this.abortController.signal,\n\t\t\t\tregister\n\t\t\t})\n\n\t\t\tif ( rtrn && rtrn.constructor === Promise ) {\n\t\t\t\trtrn.then(() => {\n\t\t\t\t\tthis.dispatchEvent( new CustomEvent(':mount') )\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tthis.dispatchEvent( new CustomEvent(':mount') )\n\t\t\t}\n\t\t}\n\n\t\tdisconnectedCallback() {\n\t\t\tthis.dispatchEvent( new CustomEvent(':unmount') )\n\t\t\tthis.abortController.abort()\n\t\t}\n\t}\n}\n","import { uuid, decodeHTML } from './utils'\n\nconst config = {\n\ttags: ['{{', '}}']\n}\n\nconst templates  = {}\nconst booleanAttrs = /html-(allowfullscreen|async|autofocus|autoplay|checked|controls|default|defer|disabled|formnovalidate|inert|ismap|itemscope|loop|multiple|muted|nomodule|novalidate|open|playsinline|readonly|required|reversed|selected)=\"(.*?)\"/g\nconst htmlAttr = /html-([^\\s]*?)=\"(.*?)\"/g\nconst tagExpr = () => new RegExp(`\\\\${config.tags[0]}(.+?)\\\\${config.tags[1]}`, 'g')\n\nexport const templateConfig = (newconfig) => {\n\tObject.assign( config, newconfig )\n}\n\nexport const template = ( target, { components }) => {\n\n\ttagElements( target, [...Object.keys( components ), '[html-if]', 'template'], components )\n\tconst clone = target.cloneNode( true )\n\n\ttransformTemplate( clone )\n\tremoveTemplateTagsRecursively( clone )\n\tsetTemplates( clone, components )\n\n\treturn templates\n}\n\nexport const compile = ( html ) => {\n\n\tconst parsedHtml = JSON.stringify( html )\n\n\treturn new Function('$element', 'safe', '$g',`\n\t\tvar $data = this;\n\t\twith( $data ){\n\t\t\tvar output=${parsedHtml\n\t\t\t\t.replace(/%%_=(.+?)_%%/g, function(_, variable){\n\t\t\t\t\treturn '\"+safe(function(){return '+ decodeHTML(variable) +';})+\"'\n\t\t\t\t})\n\t\t\t\t.replace(/%%_(.+?)_%%/g, function(_, variable){\n\t\t\t\t\treturn '\";' + decodeHTML(variable) +'\\noutput+=\"'\n\t\t\t\t})};return output;\n\t\t}\n\t`)\n}\n\nconst tagElements = (target, keys, components) => {\n\tconst isComponent = key => key in components\n\tconst selector = keys.join(',')\n\n\ttarget.querySelectorAll(selector).forEach(node => {\n\t\tif (node.localName === 'template') {\n\t\t\ttagElements(node.content, keys, components)\n\t\t\treturn\n\t\t}\n\t\tif (node.hasAttribute('html-if') && !node.id) {\n\t\t\tnode.id = uuid()\n\t\t}\n\t\tif (isComponent(node.localName)) {\n\t\t\tnode.setAttribute('tplid', uuid())\n\t\t}\n\t})\n}\n\nconst transformAttributes = (html) => {\n\treturn html\n\t\t.replace(/jails___scope-id/g, '%%_=$scopeid_%%')\n\t\t.replace(tagExpr(), '%%_=$1_%%')\n\t\t.replace(booleanAttrs, `%%_if(safe(function(){ return $2 })){_%%$1%%_}_%%`)\n\t\t.replace(htmlAttr, (all, key, value) => {\n\t\t\tif (['key', 'model', 'scopeid'].includes(key)) return all\n\t\t\tif (value) {\n\t\t\t\tvalue = value.replace(/^{|}$/g, '')\n\t\t\t\treturn `${key}=\"%%_=safe(function(){ return ${value} })_%%\"`\n\t\t\t}\n\t\t\treturn all\n\t\t})\n}\n\nconst transformTemplate = ( clone ) => {\n\n\tclone.querySelectorAll('template, [html-for], [html-if], [html-inner], [html-class]')\n\t\t.forEach(( element ) => {\n\n\t\t\tconst htmlFor \t= element.getAttribute('html-for')\n\t\t\tconst htmlIf \t= element.getAttribute('html-if')\n\t\t\tconst htmlInner = element.getAttribute('html-inner')\n\t\t\tconst htmlClass = element.getAttribute('html-class')\n\n\t\t\tif ( htmlFor ) {\n\n\t\t\t\telement.removeAttribute('html-for')\n\n\t\t\t\tconst split \t = htmlFor.match(/(.*)\\sin\\s(.*)/) || ''\n\t\t\t\tconst varname \t = split[1]\n\t\t\t\tconst object \t = split[2]\n\t\t\t\tconst objectname = object.split(/\\./).shift()\n\t\t\t\tconst open \t\t = document.createTextNode(`%%_ ;(function(){ var $index = 0; for(var $key in safe(function(){ return ${object} }) ){ var $scopeid = Math.random().toString(36).substring(2, 9); var ${varname} = ${object}[$key]; $g.scope[$scopeid] = Object.assign({}, { ${objectname}: ${objectname} }, { ${varname} :${varname}, $index: $index, $key: $key }); _%%`)\n\t\t\t\tconst close \t = document.createTextNode(`%%_ $index++; } })() _%%`)\n\n\t\t\t\twrap(open, element, close)\n\t\t\t}\n\n\t\t\tif (htmlIf) {\n\t\t\t\telement.removeAttribute('html-if')\n\t\t\t\tconst open = document.createTextNode(`%%_ if ( safe(function(){ return ${htmlIf} }) ){ _%%`)\n\t\t\t\tconst close = document.createTextNode(`%%_ }  _%%`)\n\t\t\t\twrap(open, element, close)\n\t\t\t}\n\n\t\t\tif (htmlInner) {\n\t\t\t\telement.removeAttribute('html-inner')\n\t\t\t\telement.innerHTML = `%%_=${htmlInner}_%%`\n\t\t\t}\n\n\t\t\tif (htmlClass) {\n\t\t\t\telement.removeAttribute('html-class')\n\t\t\t\telement.className = (element.className + ` %%_=${htmlClass}_%%`).trim()\n\t\t\t}\n\n\t\t\tif( element.localName === 'template' ) {\n\t\t\t\ttransformTemplate(element.content)\n\t\t\t}\n\t\t})\n}\n\nconst setTemplates = ( clone, components ) => {\n\n\tArray.from(clone.querySelectorAll('[tplid]'))\n\t\t.reverse()\n\t\t.forEach((node) => {\n\n\t\t\tconst tplid = node.getAttribute('tplid')\n\t\t\tconst name  = node.localName\n\t\t\tnode.setAttribute('html-scopeid', 'jails___scope-id')\n\n\t\t\tif( name in components && components[name].module.template ) {\n\t\t\t\tconst children = node.innerHTML\n\t\t\t\tconst html = components[name].module.template({ elm:node, children })\n\t\t\t\tnode.innerHTML = html\n\t\t\t\ttransformTemplate(node)\n\t\t\t\tremoveTemplateTagsRecursively(node)\n\t\t\t}\n\n\t\t\tconst html = transformAttributes(node.outerHTML)\n\n\t\t\ttemplates[ tplid ] = {\n\t\t\t\ttemplate: html,\n\t\t\t\trender\t: compile(html)\n\t\t\t}\n\t\t})\n}\n\nconst removeTemplateTagsRecursively = (node) => {\n\n\t// Get all <template> elements within the node\n\tconst templates = node.querySelectorAll('template')\n\n\ttemplates.forEach((template) => {\n\n\t\tif( template.getAttribute('html-if') || template.getAttribute('html-inner') ) {\n\t\t\treturn\n\t\t}\n\n\t\t// Process any nested <template> tags within this <template> first\n\t\tremoveTemplateTagsRecursively(template.content)\n\n\t\t// Get the parent of the <template> tag\n\t\tconst parent = template.parentNode\n\n\t\tif (parent) {\n\t\t\t// Move all child nodes from the <template>'s content to its parent\n\t\t\tconst content = template.content\n\t\t\twhile (content.firstChild) {\n\t\t\t\tparent.insertBefore(content.firstChild, template)\n\t\t\t}\n\t\t\t// Remove the <template> tag itself\n\t\t\tparent.removeChild(template)\n\t\t}\n\t})\n}\n\n\nconst wrap = (open, node, close) => {\n\tnode.parentNode?.insertBefore(open, node)\n\tnode.parentNode?.insertBefore(close, node.nextSibling)\n}\n","\nimport { Element } from './element'\nimport { template, templateConfig as config } from './template-system'\n\nexport { publish, subscribe } from './utils/pubsub'\n\nexport const templateConfig = (options) => {\n\tconfig( options )\n}\n\nglobalThis.__jails__ = globalThis.__jails__ || { components: {} }\n\nexport const register = ( name, module, dependencies ) => {\n\tconst { components } = globalThis.__jails__\n\tcomponents[ name ] = { name, module, dependencies }\n}\n\nexport const start = ( target ) => {\n\n\t// If the code is running in a Node.js environment, do nothing\n\tif( typeof window === 'undefined' ) {\n\t\treturn;\n\t}\n\n\ttarget = target || document.body\n\tconst { components } = globalThis.__jails__\n\tconst templates = template( target, { components } )\n\n\tObject\n\t\t.values( components )\n\t\t.forEach(({ name, module, dependencies }) => {\n\t\t\tif( !customElements.get(name) ) {\n\t\t\t\tcustomElements.define( name, Element({ component: { name, module, dependencies }, templates, start }))\n\t\t\t}\n\t})\n}\n"],"names":["textarea","g","scope","decodeHTML","text","document","createElement","innerHTML","value","uuid","Math","random","toString","substring","safe","execute","val","err","Idiomorph","noOp","defaults","morphStyle","callbacks","beforeNodeAdded","afterNodeAdded","beforeNodeMorphed","afterNodeMorphed","beforeNodeRemoved","afterNodeRemoved","beforeAttributeUpdated","head","style","shouldPreserve","elt","getAttribute","shouldReAppend","shouldRemove","afterHeadMorphed","restoreFocus","morphChildren","createNode","oldParent","newChild","insertionPoint","ctx","idMap","has","newEmptyChild","tagName","insertBefore","morphNode","newClonedChild","importNode","findBestMatch","isIdSetMatch","oldNode","newNode","oldSet","get","newSet","id","isSoftMatch","oldElt","newElt","nodeType","node","startPoint","endPoint","softMatch","nextSibling","siblingSoftMatchCount","cursor","contains","activeElement","removeNode","moveBefore","pantry","_a","parentNode","removeChild","removeNodesBetween","startInclusive","endExclusive","tempNode","moveBeforeById","after","target","querySelector","element","idSet","delete","size","removeElementFromAncestorsIdMaps","e","newParent","HTMLTemplateElement","content","firstChild","childNodes","bestMatch","Element","persistentIds","movedChild","insertedNode","syncBooleanAttribute","oldElement","newElement","attributeName","newLiveValue","ignoreUpdate","ignoreAttribute","setAttribute","removeAttribute","attr","updateType","ignoreActiveValue","ignoreValueOfActiveElement","possibleActiveElement","body","newContent","ignoreActive","HTMLHeadElement","ignore","handleHeadElement","type","oldAttributes","attributes","newAttributes","newAttribute","name","i","length","oldAttribute","hasAttribute","HTMLInputElement","newValue","oldValue","HTMLOptionElement","HTMLTextAreaElement","nodeValue","syncInputValue","morphAttributes","oldHead","newHead","added","removed","preserved","nodesToAppend","srcToNewHeadNodes","Map","newHeadChild","children","set","outerHTML","currentHeadElt","inNewContent","isReAppended","isPreserved","push","values","promises","createRange","createContextualFragment","href","src","resolve","promise","Promise","_resolve","addEventListener","appendChild","removedElement","kept","createMorphContext","createPantry","hidden","insertAdjacentElement","findIdElements","root","elements","Array","from","querySelectorAll","populateIdMapWithTree","current","Set","add","parentElement","config","oldContent","oldIdElements","newIdElements","duplicateIds","oldIdTagNameMap","createPersistentIds","newRoot","__idiomorphRoot","createIdMaps","mergedConfig","finalConfig","Object","assign","mergeDefaults","includes","normalizeElement","normalizeParent","generatedByIdiomorph","WeakSet","SlicedParentNode","constructor","this","originalNode","realParentNode","previousSibling","nodes","selector","reduce","results","matches","nodeList","referenceNode","Document","documentElement","parser","DOMParser","contentWithSvgsRemoved","replace","match","parseFromString","htmlElement","parseContent","Node","dummyParent","append","morph","morphedNodes","fn","activeElementId","selectionStart","selectionEnd","focus","setSelectionRange","saveAndRestoreFocus","callback","block","all","then","newCtx","withHeadBlocking","morphOuterHTML","remove","topics","_async","publish","params","isObject","forEach","topic","subscribe","method","filter","isArray","Component","module","dependencies","templates","signal","register","tick","preserve","observer","observables","effect","_model","model","initialState","Function","tplid","scopeid","tpl","o","apply","elm","JSON","parse","stringify","state","view","data","base","template","main","protected","list","save","newstate","render","dataset","key","isNaN","trim","Number","on","ev","selectorOrCallback","attribute","MutationObserver","mutationsList","mutation","attrname","item","observe","subtree","disconnect","handler","detail","parent","delegateTarget","concat","args","capture","off","removeEventListener","trigger","String","dispatchEvent","CustomEvent","bubbles","emit","unmount","html_","clone","cloneNode","html","clearTimeout","setTimeout","call","__spreadValues","IdiomorphOptions","child","useEffect","default","WeakMap","component","start","HTMLElement","super","connectedCallback","abortController","AbortController","rtrn","disconnectedCallback","abort","tags","booleanAttrs","htmlAttr","compile","parsedHtml","_","variable","tagElements","keys","components","join","localName","transformAttributes","RegExp","transformTemplate","htmlFor","htmlIf","htmlInner","htmlClass","split","varname","object","objectname","shift","open","createTextNode","close","wrap","className","setTemplates","reverse","removeTemplateTagsRecursively","_b","globalThis","__jails__","window","customElements","define","options","newconfig"],"mappings":"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","x_google_ignoreList":[1]}