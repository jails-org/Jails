{"version":3,"file":"jails.js","sources":["../node_modules/idiomorph/dist/idiomorph.esm.js","../src/utils/index.ts","../src/utils/pubsub.ts","../src/component.ts","../src/element.ts","../src/template-system.ts","../src/index.ts"],"sourcesContent":["/**\n * @typedef {object} ConfigHead\n *\n * @property {'merge' | 'append' | 'morph' | 'none'} [style]\n * @property {boolean} [block]\n * @property {boolean} [ignore]\n * @property {function(Element): boolean} [shouldPreserve]\n * @property {function(Element): boolean} [shouldReAppend]\n * @property {function(Element): boolean} [shouldRemove]\n * @property {function(Element, {added: Node[], kept: Element[], removed: Element[]}): void} [afterHeadMorphed]\n */\n\n/**\n * @typedef {object} ConfigCallbacks\n *\n * @property {function(Node): boolean} [beforeNodeAdded]\n * @property {function(Node): void} [afterNodeAdded]\n * @property {function(Element, Node): boolean} [beforeNodeMorphed]\n * @property {function(Element, Node): void} [afterNodeMorphed]\n * @property {function(Element): boolean} [beforeNodeRemoved]\n * @property {function(Element): void} [afterNodeRemoved]\n * @property {function(string, Element, \"update\" | \"remove\"): boolean} [beforeAttributeUpdated]\n */\n\n/**\n * @typedef {object} Config\n *\n * @property {'outerHTML' | 'innerHTML'} [morphStyle]\n * @property {boolean} [ignoreActive]\n * @property {boolean} [ignoreActiveValue]\n * @property {boolean} [restoreFocus]\n * @property {ConfigCallbacks} [callbacks]\n * @property {ConfigHead} [head]\n */\n\n/**\n * @typedef {function} NoOp\n *\n * @returns {void}\n */\n\n/**\n * @typedef {object} ConfigHeadInternal\n *\n * @property {'merge' | 'append' | 'morph' | 'none'} style\n * @property {boolean} [block]\n * @property {boolean} [ignore]\n * @property {(function(Element): boolean) | NoOp} shouldPreserve\n * @property {(function(Element): boolean) | NoOp} shouldReAppend\n * @property {(function(Element): boolean) | NoOp} shouldRemove\n * @property {(function(Element, {added: Node[], kept: Element[], removed: Element[]}): void) | NoOp} afterHeadMorphed\n */\n\n/**\n * @typedef {object} ConfigCallbacksInternal\n *\n * @property {(function(Node): boolean) | NoOp} beforeNodeAdded\n * @property {(function(Node): void) | NoOp} afterNodeAdded\n * @property {(function(Node, Node): boolean) | NoOp} beforeNodeMorphed\n * @property {(function(Node, Node): void) | NoOp} afterNodeMorphed\n * @property {(function(Node): boolean) | NoOp} beforeNodeRemoved\n * @property {(function(Node): void) | NoOp} afterNodeRemoved\n * @property {(function(string, Element, \"update\" | \"remove\"): boolean) | NoOp} beforeAttributeUpdated\n */\n\n/**\n * @typedef {object} ConfigInternal\n *\n * @property {'outerHTML' | 'innerHTML'} morphStyle\n * @property {boolean} [ignoreActive]\n * @property {boolean} [ignoreActiveValue]\n * @property {boolean} [restoreFocus]\n * @property {ConfigCallbacksInternal} callbacks\n * @property {ConfigHeadInternal} head\n */\n\n/**\n * @typedef {Object} IdSets\n * @property {Set<string>} persistentIds\n * @property {Map<Node, Set<string>>} idMap\n */\n\n/**\n * @typedef {Function} Morph\n *\n * @param {Element | Document} oldNode\n * @param {Element | Node | HTMLCollection | Node[] | string | null} newContent\n * @param {Config} [config]\n * @returns {undefined | Node[]}\n */\n\n// base IIFE to define idiomorph\n/**\n *\n * @type {{defaults: ConfigInternal, morph: Morph}}\n */\nvar Idiomorph = (function () {\n  \"use strict\";\n\n  /**\n   * @typedef {object} MorphContext\n   *\n   * @property {Element} target\n   * @property {Element} newContent\n   * @property {ConfigInternal} config\n   * @property {ConfigInternal['morphStyle']} morphStyle\n   * @property {ConfigInternal['ignoreActive']} ignoreActive\n   * @property {ConfigInternal['ignoreActiveValue']} ignoreActiveValue\n   * @property {ConfigInternal['restoreFocus']} restoreFocus\n   * @property {Map<Node, Set<string>>} idMap\n   * @property {Set<string>} persistentIds\n   * @property {ConfigInternal['callbacks']} callbacks\n   * @property {ConfigInternal['head']} head\n   * @property {HTMLDivElement} pantry\n   * @property {Element[]} activeElementAndParents\n   */\n\n  //=============================================================================\n  // AND NOW IT BEGINS...\n  //=============================================================================\n\n  const noOp = () => {};\n  /**\n   * Default configuration values, updatable by users now\n   * @type {ConfigInternal}\n   */\n  const defaults = {\n    morphStyle: \"outerHTML\",\n    callbacks: {\n      beforeNodeAdded: noOp,\n      afterNodeAdded: noOp,\n      beforeNodeMorphed: noOp,\n      afterNodeMorphed: noOp,\n      beforeNodeRemoved: noOp,\n      afterNodeRemoved: noOp,\n      beforeAttributeUpdated: noOp,\n    },\n    head: {\n      style: \"merge\",\n      shouldPreserve: (elt) => elt.getAttribute(\"im-preserve\") === \"true\",\n      shouldReAppend: (elt) => elt.getAttribute(\"im-re-append\") === \"true\",\n      shouldRemove: noOp,\n      afterHeadMorphed: noOp,\n    },\n    restoreFocus: true,\n  };\n\n  /**\n   * Core idiomorph function for morphing one DOM tree to another\n   *\n   * @param {Element | Document} oldNode\n   * @param {Element | Node | HTMLCollection | Node[] | string | null} newContent\n   * @param {Config} [config]\n   * @returns {Promise<Node[]> | Node[]}\n   */\n  function morph(oldNode, newContent, config = {}) {\n    oldNode = normalizeElement(oldNode);\n    const newNode = normalizeParent(newContent);\n    const ctx = createMorphContext(oldNode, newNode, config);\n\n    const morphedNodes = saveAndRestoreFocus(ctx, () => {\n      return withHeadBlocking(\n        ctx,\n        oldNode,\n        newNode,\n        /** @param {MorphContext} ctx */ (ctx) => {\n          if (ctx.morphStyle === \"innerHTML\") {\n            morphChildren(ctx, oldNode, newNode);\n            return Array.from(oldNode.childNodes);\n          } else {\n            return morphOuterHTML(ctx, oldNode, newNode);\n          }\n        },\n      );\n    });\n\n    ctx.pantry.remove();\n    return morphedNodes;\n  }\n\n  /**\n   * Morph just the outerHTML of the oldNode to the newContent\n   * We have to be careful because the oldNode could have siblings which need to be untouched\n   * @param {MorphContext} ctx\n   * @param {Element} oldNode\n   * @param {Element} newNode\n   * @returns {Node[]}\n   */\n  function morphOuterHTML(ctx, oldNode, newNode) {\n    const oldParent = normalizeParent(oldNode);\n    morphChildren(\n      ctx,\n      oldParent,\n      newNode,\n      // these two optional params are the secret sauce\n      oldNode, // start point for iteration\n      oldNode.nextSibling, // end point for iteration\n    );\n    // this is safe even with siblings, because normalizeParent returns a SlicedParentNode if needed.\n    return Array.from(oldParent.childNodes);\n  }\n\n  /**\n   * @param {MorphContext} ctx\n   * @param {Function} fn\n   * @returns {Promise<Node[]> | Node[]}\n   */\n  function saveAndRestoreFocus(ctx, fn) {\n    if (!ctx.config.restoreFocus) return fn();\n    let activeElement =\n      /** @type {HTMLInputElement|HTMLTextAreaElement|null} */ (\n        document.activeElement\n      );\n\n    // don't bother if the active element is not an input or textarea\n    if (\n      !(\n        activeElement instanceof HTMLInputElement ||\n        activeElement instanceof HTMLTextAreaElement\n      )\n    ) {\n      return fn();\n    }\n\n    const { id: activeElementId, selectionStart, selectionEnd } = activeElement;\n\n    const results = fn();\n\n    if (\n      activeElementId &&\n      activeElementId !== document.activeElement?.getAttribute(\"id\")\n    ) {\n      activeElement = ctx.target.querySelector(`[id=\"${activeElementId}\"]`);\n      activeElement?.focus();\n    }\n    if (activeElement && !activeElement.selectionEnd && selectionEnd) {\n      activeElement.setSelectionRange(selectionStart, selectionEnd);\n    }\n\n    return results;\n  }\n\n  const morphChildren = (function () {\n    /**\n     * This is the core algorithm for matching up children.  The idea is to use id sets to try to match up\n     * nodes as faithfully as possible.  We greedily match, which allows us to keep the algorithm fast, but\n     * by using id sets, we are able to better match up with content deeper in the DOM.\n     *\n     * Basic algorithm:\n     * - for each node in the new content:\n     *   - search self and siblings for an id set match, falling back to a soft match\n     *   - if match found\n     *     - remove any nodes up to the match:\n     *       - pantry persistent nodes\n     *       - delete the rest\n     *     - morph the match\n     *   - elsif no match found, and node is persistent\n     *     - find its match by querying the old root (future) and pantry (past)\n     *     - move it and its children here\n     *     - morph it\n     *   - else\n     *     - create a new node from scratch as a last result\n     *\n     * @param {MorphContext} ctx the merge context\n     * @param {Element} oldParent the old content that we are merging the new content into\n     * @param {Element} newParent the parent element of the new content\n     * @param {Node|null} [insertionPoint] the point in the DOM we start morphing at (defaults to first child)\n     * @param {Node|null} [endPoint] the point in the DOM we stop morphing at (defaults to after last child)\n     */\n    function morphChildren(\n      ctx,\n      oldParent,\n      newParent,\n      insertionPoint = null,\n      endPoint = null,\n    ) {\n      // normalize\n      if (\n        oldParent instanceof HTMLTemplateElement &&\n        newParent instanceof HTMLTemplateElement\n      ) {\n        // @ts-ignore we can pretend the DocumentFragment is an Element\n        oldParent = oldParent.content;\n        // @ts-ignore ditto\n        newParent = newParent.content;\n      }\n      insertionPoint ||= oldParent.firstChild;\n\n      // run through all the new content\n      for (const newChild of newParent.childNodes) {\n        // once we reach the end of the old parent content skip to the end and insert the rest\n        if (insertionPoint && insertionPoint != endPoint) {\n          const bestMatch = findBestMatch(\n            ctx,\n            newChild,\n            insertionPoint,\n            endPoint,\n          );\n          if (bestMatch) {\n            // if the node to morph is not at the insertion point then remove/move up to it\n            if (bestMatch !== insertionPoint) {\n              removeNodesBetween(ctx, insertionPoint, bestMatch);\n            }\n            morphNode(bestMatch, newChild, ctx);\n            insertionPoint = bestMatch.nextSibling;\n            continue;\n          }\n        }\n\n        // if the matching node is elsewhere in the original content\n        if (newChild instanceof Element) {\n          // we can pretend the id is non-null because the next `.has` line will reject it if not\n          const newChildId = /** @type {String} */ (\n            newChild.getAttribute(\"id\")\n          );\n          if (ctx.persistentIds.has(newChildId)) {\n            // move it and all its children here and morph\n            const movedChild = moveBeforeById(\n              oldParent,\n              newChildId,\n              insertionPoint,\n              ctx,\n            );\n            morphNode(movedChild, newChild, ctx);\n            insertionPoint = movedChild.nextSibling;\n            continue;\n          }\n        }\n\n        // last resort: insert the new node from scratch\n        const insertedNode = createNode(\n          oldParent,\n          newChild,\n          insertionPoint,\n          ctx,\n        );\n        // could be null if beforeNodeAdded prevented insertion\n        if (insertedNode) {\n          insertionPoint = insertedNode.nextSibling;\n        }\n      }\n\n      // remove any remaining old nodes that didn't match up with new content\n      while (insertionPoint && insertionPoint != endPoint) {\n        const tempNode = insertionPoint;\n        insertionPoint = insertionPoint.nextSibling;\n        removeNode(ctx, tempNode);\n      }\n    }\n\n    /**\n     * This performs the action of inserting a new node while handling situations where the node contains\n     * elements with persistent ids and possible state info we can still preserve by moving in and then morphing\n     *\n     * @param {Element} oldParent\n     * @param {Node} newChild\n     * @param {Node|null} insertionPoint\n     * @param {MorphContext} ctx\n     * @returns {Node|null}\n     */\n    function createNode(oldParent, newChild, insertionPoint, ctx) {\n      if (ctx.callbacks.beforeNodeAdded(newChild) === false) return null;\n      if (ctx.idMap.has(newChild)) {\n        // node has children with ids with possible state so create a dummy elt of same type and apply full morph algorithm\n        const newEmptyChild = document.createElement(\n          /** @type {Element} */ (newChild).tagName,\n        );\n        oldParent.insertBefore(newEmptyChild, insertionPoint);\n        morphNode(newEmptyChild, newChild, ctx);\n        ctx.callbacks.afterNodeAdded(newEmptyChild);\n        return newEmptyChild;\n      } else {\n        // optimisation: no id state to preserve so we can just insert a clone of the newChild and its descendants\n        const newClonedChild = document.importNode(newChild, true); // importNode to not mutate newParent\n        oldParent.insertBefore(newClonedChild, insertionPoint);\n        ctx.callbacks.afterNodeAdded(newClonedChild);\n        return newClonedChild;\n      }\n    }\n\n    //=============================================================================\n    // Matching Functions\n    //=============================================================================\n    const findBestMatch = (function () {\n      /**\n       * Scans forward from the startPoint to the endPoint looking for a match\n       * for the node. It looks for an id set match first, then a soft match.\n       * We abort softmatching if we find two future soft matches, to reduce churn.\n       * @param {Node} node\n       * @param {MorphContext} ctx\n       * @param {Node | null} startPoint\n       * @param {Node | null} endPoint\n       * @returns {Node | null}\n       */\n      function findBestMatch(ctx, node, startPoint, endPoint) {\n        let softMatch = null;\n        let nextSibling = node.nextSibling;\n        let siblingSoftMatchCount = 0;\n\n        let cursor = startPoint;\n        while (cursor && cursor != endPoint) {\n          // soft matching is a prerequisite for id set matching\n          if (isSoftMatch(cursor, node)) {\n            if (isIdSetMatch(ctx, cursor, node)) {\n              return cursor; // found an id set match, we're done!\n            }\n\n            // we haven't yet saved a soft match fallback\n            if (softMatch === null) {\n              // the current soft match will hard match something else in the future, leave it\n              if (!ctx.idMap.has(cursor)) {\n                // save this as the fallback if we get through the loop without finding a hard match\n                softMatch = cursor;\n              }\n            }\n          }\n          if (\n            softMatch === null &&\n            nextSibling &&\n            isSoftMatch(cursor, nextSibling)\n          ) {\n            // The next new node has a soft match with this node, so\n            // increment the count of future soft matches\n            siblingSoftMatchCount++;\n            nextSibling = nextSibling.nextSibling;\n\n            // If there are two future soft matches, block soft matching for this node to allow\n            // future siblings to soft match. This is to reduce churn in the DOM when an element\n            // is prepended.\n            if (siblingSoftMatchCount >= 2) {\n              softMatch = undefined;\n            }\n          }\n\n          // if the current node contains active element, stop looking for better future matches,\n          // because if one is found, this node will be moved to the pantry, reparenting it and thus losing focus\n          // @ts-ignore pretend cursor is Element rather than Node, we're just testing for array inclusion\n          if (ctx.activeElementAndParents.includes(cursor)) break;\n\n          cursor = cursor.nextSibling;\n        }\n\n        return softMatch || null;\n      }\n\n      /**\n       *\n       * @param {MorphContext} ctx\n       * @param {Node} oldNode\n       * @param {Node} newNode\n       * @returns {boolean}\n       */\n      function isIdSetMatch(ctx, oldNode, newNode) {\n        let oldSet = ctx.idMap.get(oldNode);\n        let newSet = ctx.idMap.get(newNode);\n\n        if (!newSet || !oldSet) return false;\n\n        for (const id of oldSet) {\n          // a potential match is an id in the new and old nodes that\n          // has not already been merged into the DOM\n          // But the newNode content we call this on has not been\n          // merged yet and we don't allow duplicate IDs so it is simple\n          if (newSet.has(id)) {\n            return true;\n          }\n        }\n        return false;\n      }\n\n      /**\n       *\n       * @param {Node} oldNode\n       * @param {Node} newNode\n       * @returns {boolean}\n       */\n      function isSoftMatch(oldNode, newNode) {\n        // ok to cast: if one is not element, `id` and `tagName` will be undefined and we'll just compare that.\n        const oldElt = /** @type {Element} */ (oldNode);\n        const newElt = /** @type {Element} */ (newNode);\n\n        return (\n          oldElt.nodeType === newElt.nodeType &&\n          oldElt.tagName === newElt.tagName &&\n          // If oldElt has an `id` with possible state and it doesn't match newElt.id then avoid morphing.\n          // We'll still match an anonymous node with an IDed newElt, though, because if it got this far,\n          // its not persistent, and new nodes can't have any hidden state.\n          // We can't use .id because of form input shadowing, and we can't count on .getAttribute's presence because it could be a document-fragment\n          (!oldElt.getAttribute?.(\"id\") ||\n            oldElt.getAttribute?.(\"id\") === newElt.getAttribute?.(\"id\"))\n        );\n      }\n\n      return findBestMatch;\n    })();\n\n    //=============================================================================\n    // DOM Manipulation Functions\n    //=============================================================================\n\n    /**\n     * Gets rid of an unwanted DOM node; strategy depends on nature of its reuse:\n     * - Persistent nodes will be moved to the pantry for later reuse\n     * - Other nodes will have their hooks called, and then are removed\n     * @param {MorphContext} ctx\n     * @param {Node} node\n     */\n    function removeNode(ctx, node) {\n      // are we going to id set match this later?\n      if (ctx.idMap.has(node)) {\n        // skip callbacks and move to pantry\n        moveBefore(ctx.pantry, node, null);\n      } else {\n        // remove for realsies\n        if (ctx.callbacks.beforeNodeRemoved(node) === false) return;\n        node.parentNode?.removeChild(node);\n        ctx.callbacks.afterNodeRemoved(node);\n      }\n    }\n\n    /**\n     * Remove nodes between the start and end nodes\n     * @param {MorphContext} ctx\n     * @param {Node} startInclusive\n     * @param {Node} endExclusive\n     * @returns {Node|null}\n     */\n    function removeNodesBetween(ctx, startInclusive, endExclusive) {\n      /** @type {Node | null} */\n      let cursor = startInclusive;\n      // remove nodes until the endExclusive node\n      while (cursor && cursor !== endExclusive) {\n        let tempNode = /** @type {Node} */ (cursor);\n        cursor = cursor.nextSibling;\n        removeNode(ctx, tempNode);\n      }\n      return cursor;\n    }\n\n    /**\n     * Search for an element by id within the document and pantry, and move it using moveBefore.\n     *\n     * @param {Element} parentNode - The parent node to which the element will be moved.\n     * @param {string} id - The ID of the element to be moved.\n     * @param {Node | null} after - The reference node to insert the element before.\n     *                              If `null`, the element is appended as the last child.\n     * @param {MorphContext} ctx\n     * @returns {Element} The found element\n     */\n    function moveBeforeById(parentNode, id, after, ctx) {\n      const target =\n        /** @type {Element} - will always be found */\n        (\n          // ctx.target.id unsafe because of form input shadowing\n          // ctx.target could be a document fragment which doesn't have `getAttribute`\n          (ctx.target.getAttribute?.(\"id\") === id && ctx.target) ||\n            ctx.target.querySelector(`[id=\"${id}\"]`) ||\n            ctx.pantry.querySelector(`[id=\"${id}\"]`)\n        );\n      removeElementFromAncestorsIdMaps(target, ctx);\n      moveBefore(parentNode, target, after);\n      return target;\n    }\n\n    /**\n     * Removes an element from its ancestors' id maps. This is needed when an element is moved from the\n     * \"future\" via `moveBeforeId`. Otherwise, its erstwhile ancestors could be mistakenly moved to the\n     * pantry rather than being deleted, preventing their removal hooks from being called.\n     *\n     * @param {Element} element - element to remove from its ancestors' id maps\n     * @param {MorphContext} ctx\n     */\n    function removeElementFromAncestorsIdMaps(element, ctx) {\n      // we know id is non-null String, because this function is only called on elements with ids\n      const id = /** @type {String} */ (element.getAttribute(\"id\"));\n      /** @ts-ignore - safe to loop in this way **/\n      while ((element = element.parentNode)) {\n        let idSet = ctx.idMap.get(element);\n        if (idSet) {\n          idSet.delete(id);\n          if (!idSet.size) {\n            ctx.idMap.delete(element);\n          }\n        }\n      }\n    }\n\n    /**\n     * Moves an element before another element within the same parent.\n     * Uses the proposed `moveBefore` API if available (and working), otherwise falls back to `insertBefore`.\n     * This is essentialy a forward-compat wrapper.\n     *\n     * @param {Element} parentNode - The parent node containing the after element.\n     * @param {Node} element - The element to be moved.\n     * @param {Node | null} after - The reference node to insert `element` before.\n     *                              If `null`, `element` is appended as the last child.\n     */\n    function moveBefore(parentNode, element, after) {\n      // @ts-ignore - use proposed moveBefore feature\n      if (parentNode.moveBefore) {\n        try {\n          // @ts-ignore - use proposed moveBefore feature\n          parentNode.moveBefore(element, after);\n        } catch (e) {\n          // fall back to insertBefore as some browsers may fail on moveBefore when trying to move Dom disconnected nodes to pantry\n          parentNode.insertBefore(element, after);\n        }\n      } else {\n        parentNode.insertBefore(element, after);\n      }\n    }\n\n    return morphChildren;\n  })();\n\n  //=============================================================================\n  // Single Node Morphing Code\n  //=============================================================================\n  const morphNode = (function () {\n    /**\n     * @param {Node} oldNode root node to merge content into\n     * @param {Node} newContent new content to merge\n     * @param {MorphContext} ctx the merge context\n     * @returns {Node | null} the element that ended up in the DOM\n     */\n    function morphNode(oldNode, newContent, ctx) {\n      if (ctx.ignoreActive && oldNode === document.activeElement) {\n        // don't morph focused element\n        return null;\n      }\n\n      if (ctx.callbacks.beforeNodeMorphed(oldNode, newContent) === false) {\n        return oldNode;\n      }\n\n      if (oldNode instanceof HTMLHeadElement && ctx.head.ignore) {\n        // ignore the head element\n      } else if (\n        oldNode instanceof HTMLHeadElement &&\n        ctx.head.style !== \"morph\"\n      ) {\n        // ok to cast: if newContent wasn't also a <head>, it would've got caught in the `!isSoftMatch` branch above\n        handleHeadElement(\n          oldNode,\n          /** @type {HTMLHeadElement} */ (newContent),\n          ctx,\n        );\n      } else {\n        morphAttributes(oldNode, newContent, ctx);\n        if (!ignoreValueOfActiveElement(oldNode, ctx)) {\n          // @ts-ignore newContent can be a node here because .firstChild will be null\n          morphChildren(ctx, oldNode, newContent);\n        }\n      }\n      ctx.callbacks.afterNodeMorphed(oldNode, newContent);\n      return oldNode;\n    }\n\n    /**\n     * syncs the oldNode to the newNode, copying over all attributes and\n     * inner element state from the newNode to the oldNode\n     *\n     * @param {Node} oldNode the node to copy attributes & state to\n     * @param {Node} newNode the node to copy attributes & state from\n     * @param {MorphContext} ctx the merge context\n     */\n    function morphAttributes(oldNode, newNode, ctx) {\n      let type = newNode.nodeType;\n\n      // if is an element type, sync the attributes from the\n      // new node into the new node\n      if (type === 1 /* element type */) {\n        const oldElt = /** @type {Element} */ (oldNode);\n        const newElt = /** @type {Element} */ (newNode);\n\n        const oldAttributes = oldElt.attributes;\n        const newAttributes = newElt.attributes;\n        for (const newAttribute of newAttributes) {\n          if (ignoreAttribute(newAttribute.name, oldElt, \"update\", ctx)) {\n            continue;\n          }\n          if (oldElt.getAttribute(newAttribute.name) !== newAttribute.value) {\n            oldElt.setAttribute(newAttribute.name, newAttribute.value);\n          }\n        }\n        // iterate backwards to avoid skipping over items when a delete occurs\n        for (let i = oldAttributes.length - 1; 0 <= i; i--) {\n          const oldAttribute = oldAttributes[i];\n\n          // toAttributes is a live NamedNodeMap, so iteration+mutation is unsafe\n          // e.g. custom element attribute callbacks can remove other attributes\n          if (!oldAttribute) continue;\n\n          if (!newElt.hasAttribute(oldAttribute.name)) {\n            if (ignoreAttribute(oldAttribute.name, oldElt, \"remove\", ctx)) {\n              continue;\n            }\n            oldElt.removeAttribute(oldAttribute.name);\n          }\n        }\n\n        if (!ignoreValueOfActiveElement(oldElt, ctx)) {\n          syncInputValue(oldElt, newElt, ctx);\n        }\n      }\n\n      // sync text nodes\n      if (type === 8 /* comment */ || type === 3 /* text */) {\n        if (oldNode.nodeValue !== newNode.nodeValue) {\n          oldNode.nodeValue = newNode.nodeValue;\n        }\n      }\n    }\n\n    /**\n     * NB: many bothans died to bring us information:\n     *\n     *  https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n     *  https://github.com/choojs/nanomorph/blob/master/lib/morph.jsL113\n     *\n     * @param {Element} oldElement the element to sync the input value to\n     * @param {Element} newElement the element to sync the input value from\n     * @param {MorphContext} ctx the merge context\n     */\n    function syncInputValue(oldElement, newElement, ctx) {\n      if (\n        oldElement instanceof HTMLInputElement &&\n        newElement instanceof HTMLInputElement &&\n        newElement.type !== \"file\"\n      ) {\n        let newValue = newElement.value;\n        let oldValue = oldElement.value;\n\n        // sync boolean attributes\n        syncBooleanAttribute(oldElement, newElement, \"checked\", ctx);\n        syncBooleanAttribute(oldElement, newElement, \"disabled\", ctx);\n\n        if (!newElement.hasAttribute(\"value\")) {\n          if (!ignoreAttribute(\"value\", oldElement, \"remove\", ctx)) {\n            oldElement.value = \"\";\n            oldElement.removeAttribute(\"value\");\n          }\n        } else if (oldValue !== newValue) {\n          if (!ignoreAttribute(\"value\", oldElement, \"update\", ctx)) {\n            oldElement.setAttribute(\"value\", newValue);\n            oldElement.value = newValue;\n          }\n        }\n        // TODO: QUESTION(1cg): this used to only check `newElement` unlike the other branches -- why?\n        // did I break something?\n      } else if (\n        oldElement instanceof HTMLOptionElement &&\n        newElement instanceof HTMLOptionElement\n      ) {\n        syncBooleanAttribute(oldElement, newElement, \"selected\", ctx);\n      } else if (\n        oldElement instanceof HTMLTextAreaElement &&\n        newElement instanceof HTMLTextAreaElement\n      ) {\n        let newValue = newElement.value;\n        let oldValue = oldElement.value;\n        if (ignoreAttribute(\"value\", oldElement, \"update\", ctx)) {\n          return;\n        }\n        if (newValue !== oldValue) {\n          oldElement.value = newValue;\n        }\n        if (\n          oldElement.firstChild &&\n          oldElement.firstChild.nodeValue !== newValue\n        ) {\n          oldElement.firstChild.nodeValue = newValue;\n        }\n      }\n    }\n\n    /**\n     * @param {Element} oldElement element to write the value to\n     * @param {Element} newElement element to read the value from\n     * @param {string} attributeName the attribute name\n     * @param {MorphContext} ctx the merge context\n     */\n    function syncBooleanAttribute(oldElement, newElement, attributeName, ctx) {\n      // @ts-ignore this function is only used on boolean attrs that are reflected as dom properties\n      const newLiveValue = newElement[attributeName],\n        // @ts-ignore ditto\n        oldLiveValue = oldElement[attributeName];\n      if (newLiveValue !== oldLiveValue) {\n        const ignoreUpdate = ignoreAttribute(\n          attributeName,\n          oldElement,\n          \"update\",\n          ctx,\n        );\n        if (!ignoreUpdate) {\n          // update attribute's associated DOM property\n          // @ts-ignore this function is only used on boolean attrs that are reflected as dom properties\n          oldElement[attributeName] = newElement[attributeName];\n        }\n        if (newLiveValue) {\n          if (!ignoreUpdate) {\n            // https://developer.mozilla.org/en-US/docs/Glossary/Boolean/HTML\n            // this is the correct way to set a boolean attribute to \"true\"\n            oldElement.setAttribute(attributeName, \"\");\n          }\n        } else {\n          if (!ignoreAttribute(attributeName, oldElement, \"remove\", ctx)) {\n            oldElement.removeAttribute(attributeName);\n          }\n        }\n      }\n    }\n\n    /**\n     * @param {string} attr the attribute to be mutated\n     * @param {Element} element the element that is going to be updated\n     * @param {\"update\" | \"remove\"} updateType\n     * @param {MorphContext} ctx the merge context\n     * @returns {boolean} true if the attribute should be ignored, false otherwise\n     */\n    function ignoreAttribute(attr, element, updateType, ctx) {\n      if (\n        attr === \"value\" &&\n        ctx.ignoreActiveValue &&\n        element === document.activeElement\n      ) {\n        return true;\n      }\n      return (\n        ctx.callbacks.beforeAttributeUpdated(attr, element, updateType) ===\n        false\n      );\n    }\n\n    /**\n     * @param {Node} possibleActiveElement\n     * @param {MorphContext} ctx\n     * @returns {boolean}\n     */\n    function ignoreValueOfActiveElement(possibleActiveElement, ctx) {\n      return (\n        !!ctx.ignoreActiveValue &&\n        possibleActiveElement === document.activeElement &&\n        possibleActiveElement !== document.body\n      );\n    }\n\n    return morphNode;\n  })();\n\n  //=============================================================================\n  // Head Management Functions\n  //=============================================================================\n  /**\n   * @param {MorphContext} ctx\n   * @param {Element} oldNode\n   * @param {Element} newNode\n   * @param {function} callback\n   * @returns {Node[] | Promise<Node[]>}\n   */\n  function withHeadBlocking(ctx, oldNode, newNode, callback) {\n    if (ctx.head.block) {\n      const oldHead = oldNode.querySelector(\"head\");\n      const newHead = newNode.querySelector(\"head\");\n      if (oldHead && newHead) {\n        const promises = handleHeadElement(oldHead, newHead, ctx);\n        // when head promises resolve, proceed ignoring the head tag\n        return Promise.all(promises).then(() => {\n          const newCtx = Object.assign(ctx, {\n            head: {\n              block: false,\n              ignore: true,\n            },\n          });\n          return callback(newCtx);\n        });\n      }\n    }\n    // just proceed if we not head blocking\n    return callback(ctx);\n  }\n\n  /**\n   *  The HEAD tag can be handled specially, either w/ a 'merge' or 'append' style\n   *\n   * @param {Element} oldHead\n   * @param {Element} newHead\n   * @param {MorphContext} ctx\n   * @returns {Promise<void>[]}\n   */\n  function handleHeadElement(oldHead, newHead, ctx) {\n    let added = [];\n    let removed = [];\n    let preserved = [];\n    let nodesToAppend = [];\n\n    // put all new head elements into a Map, by their outerHTML\n    let srcToNewHeadNodes = new Map();\n    for (const newHeadChild of newHead.children) {\n      srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild);\n    }\n\n    // for each elt in the current head\n    for (const currentHeadElt of oldHead.children) {\n      // If the current head element is in the map\n      let inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML);\n      let isReAppended = ctx.head.shouldReAppend(currentHeadElt);\n      let isPreserved = ctx.head.shouldPreserve(currentHeadElt);\n      if (inNewContent || isPreserved) {\n        if (isReAppended) {\n          // remove the current version and let the new version replace it and re-execute\n          removed.push(currentHeadElt);\n        } else {\n          // this element already exists and should not be re-appended, so remove it from\n          // the new content map, preserving it in the DOM\n          srcToNewHeadNodes.delete(currentHeadElt.outerHTML);\n          preserved.push(currentHeadElt);\n        }\n      } else {\n        if (ctx.head.style === \"append\") {\n          // we are appending and this existing element is not new content\n          // so if and only if it is marked for re-append do we do anything\n          if (isReAppended) {\n            removed.push(currentHeadElt);\n            nodesToAppend.push(currentHeadElt);\n          }\n        } else {\n          // if this is a merge, we remove this content since it is not in the new head\n          if (ctx.head.shouldRemove(currentHeadElt) !== false) {\n            removed.push(currentHeadElt);\n          }\n        }\n      }\n    }\n\n    // Push the remaining new head elements in the Map into the\n    // nodes to append to the head tag\n    nodesToAppend.push(...srcToNewHeadNodes.values());\n\n    let promises = [];\n    for (const newNode of nodesToAppend) {\n      // TODO: This could theoretically be null, based on type\n      let newElt = /** @type {ChildNode} */ (\n        document.createRange().createContextualFragment(newNode.outerHTML)\n          .firstChild\n      );\n      if (ctx.callbacks.beforeNodeAdded(newElt) !== false) {\n        if (\n          (\"href\" in newElt && newElt.href) ||\n          (\"src\" in newElt && newElt.src)\n        ) {\n          /** @type {(result?: any) => void} */ let resolve;\n          let promise = new Promise(function (_resolve) {\n            resolve = _resolve;\n          });\n          newElt.addEventListener(\"load\", function () {\n            resolve();\n          });\n          promises.push(promise);\n        }\n        oldHead.appendChild(newElt);\n        ctx.callbacks.afterNodeAdded(newElt);\n        added.push(newElt);\n      }\n    }\n\n    // remove all removed elements, after we have appended the new elements to avoid\n    // additional network requests for things like style sheets\n    for (const removedElement of removed) {\n      if (ctx.callbacks.beforeNodeRemoved(removedElement) !== false) {\n        oldHead.removeChild(removedElement);\n        ctx.callbacks.afterNodeRemoved(removedElement);\n      }\n    }\n\n    ctx.head.afterHeadMorphed(oldHead, {\n      added: added,\n      kept: preserved,\n      removed: removed,\n    });\n    return promises;\n  }\n\n  //=============================================================================\n  // Create Morph Context Functions\n  //=============================================================================\n  const createMorphContext = (function () {\n    /**\n     *\n     * @param {Element} oldNode\n     * @param {Element} newContent\n     * @param {Config} config\n     * @returns {MorphContext}\n     */\n    function createMorphContext(oldNode, newContent, config) {\n      const { persistentIds, idMap } = createIdMaps(oldNode, newContent);\n\n      const mergedConfig = mergeDefaults(config);\n      const morphStyle = mergedConfig.morphStyle || \"outerHTML\";\n      if (![\"innerHTML\", \"outerHTML\"].includes(morphStyle)) {\n        throw `Do not understand how to morph style ${morphStyle}`;\n      }\n\n      return {\n        target: oldNode,\n        newContent: newContent,\n        config: mergedConfig,\n        morphStyle: morphStyle,\n        ignoreActive: mergedConfig.ignoreActive,\n        ignoreActiveValue: mergedConfig.ignoreActiveValue,\n        restoreFocus: mergedConfig.restoreFocus,\n        idMap: idMap,\n        persistentIds: persistentIds,\n        pantry: createPantry(),\n        activeElementAndParents: createActiveElementAndParents(oldNode),\n        callbacks: mergedConfig.callbacks,\n        head: mergedConfig.head,\n      };\n    }\n\n    /**\n     * Deep merges the config object and the Idiomorph.defaults object to\n     * produce a final configuration object\n     * @param {Config} config\n     * @returns {ConfigInternal}\n     */\n    function mergeDefaults(config) {\n      let finalConfig = Object.assign({}, defaults);\n\n      // copy top level stuff into final config\n      Object.assign(finalConfig, config);\n\n      // copy callbacks into final config (do this to deep merge the callbacks)\n      finalConfig.callbacks = Object.assign(\n        {},\n        defaults.callbacks,\n        config.callbacks,\n      );\n\n      // copy head config into final config  (do this to deep merge the head)\n      finalConfig.head = Object.assign({}, defaults.head, config.head);\n\n      return finalConfig;\n    }\n\n    /**\n     * @returns {HTMLDivElement}\n     */\n    function createPantry() {\n      const pantry = document.createElement(\"div\");\n      pantry.hidden = true;\n      document.body.insertAdjacentElement(\"afterend\", pantry);\n      return pantry;\n    }\n\n    /**\n     * @param {Element} oldNode\n     * @returns {Element[]}\n     */\n    function createActiveElementAndParents(oldNode) {\n      /** @type {Element[]} */\n      let activeElementAndParents = [];\n      let elt = document.activeElement;\n      if (elt?.tagName !== \"BODY\" && oldNode.contains(elt)) {\n        while (elt) {\n          activeElementAndParents.push(elt);\n          if (elt === oldNode) break;\n          elt = elt.parentElement;\n        }\n      }\n      return activeElementAndParents;\n    }\n\n    /**\n     * Returns all elements with an ID contained within the root element and its descendants\n     *\n     * @param {Element} root\n     * @returns {Element[]}\n     */\n    function findIdElements(root) {\n      let elements = Array.from(root.querySelectorAll(\"[id]\"));\n      // root could be a document fragment which doesn't have `getAttribute`\n      if (root.getAttribute?.(\"id\")) {\n        elements.push(root);\n      }\n      return elements;\n    }\n\n    /**\n     * A bottom-up algorithm that populates a map of Element -> IdSet.\n     * The idSet for a given element is the set of all IDs contained within its subtree.\n     * As an optimzation, we filter these IDs through the given list of persistent IDs,\n     * because we don't need to bother considering IDed elements that won't be in the new content.\n     *\n     * @param {Map<Node, Set<string>>} idMap\n     * @param {Set<string>} persistentIds\n     * @param {Element} root\n     * @param {Element[]} elements\n     */\n    function populateIdMapWithTree(idMap, persistentIds, root, elements) {\n      for (const elt of elements) {\n        // we can pretend id is non-null String, because the .has line will reject it immediately if not\n        const id = /** @type {String} */ (elt.getAttribute(\"id\"));\n        if (persistentIds.has(id)) {\n          /** @type {Element|null} */\n          let current = elt;\n          // walk up the parent hierarchy of that element, adding the id\n          // of element to the parent's id set\n          while (current) {\n            let idSet = idMap.get(current);\n            // if the id set doesn't exist, create it and insert it in the map\n            if (idSet == null) {\n              idSet = new Set();\n              idMap.set(current, idSet);\n            }\n            idSet.add(id);\n\n            if (current === root) break;\n            current = current.parentElement;\n          }\n        }\n      }\n    }\n\n    /**\n     * This function computes a map of nodes to all ids contained within that node (inclusive of the\n     * node).  This map can be used to ask if two nodes have intersecting sets of ids, which allows\n     * for a looser definition of \"matching\" than tradition id matching, and allows child nodes\n     * to contribute to a parent nodes matching.\n     *\n     * @param {Element} oldContent  the old content that will be morphed\n     * @param {Element} newContent  the new content to morph to\n     * @returns {IdSets}\n     */\n    function createIdMaps(oldContent, newContent) {\n      const oldIdElements = findIdElements(oldContent);\n      const newIdElements = findIdElements(newContent);\n\n      const persistentIds = createPersistentIds(oldIdElements, newIdElements);\n\n      /** @type {Map<Node, Set<string>>} */\n      let idMap = new Map();\n      populateIdMapWithTree(idMap, persistentIds, oldContent, oldIdElements);\n\n      /** @ts-ignore - if newContent is a duck-typed parent, pass its single child node as the root to halt upwards iteration */\n      const newRoot = newContent.__idiomorphRoot || newContent;\n      populateIdMapWithTree(idMap, persistentIds, newRoot, newIdElements);\n\n      return { persistentIds, idMap };\n    }\n\n    /**\n     * This function computes the set of ids that persist between the two contents excluding duplicates\n     *\n     * @param {Element[]} oldIdElements\n     * @param {Element[]} newIdElements\n     * @returns {Set<string>}\n     */\n    function createPersistentIds(oldIdElements, newIdElements) {\n      let duplicateIds = new Set();\n\n      /** @type {Map<string, string>} */\n      let oldIdTagNameMap = new Map();\n      for (const { id, tagName } of oldIdElements) {\n        if (oldIdTagNameMap.has(id)) {\n          duplicateIds.add(id);\n        } else {\n          oldIdTagNameMap.set(id, tagName);\n        }\n      }\n\n      let persistentIds = new Set();\n      for (const { id, tagName } of newIdElements) {\n        if (persistentIds.has(id)) {\n          duplicateIds.add(id);\n        } else if (oldIdTagNameMap.get(id) === tagName) {\n          persistentIds.add(id);\n        }\n        // skip if tag types mismatch because its not possible to morph one tag into another\n      }\n\n      for (const id of duplicateIds) {\n        persistentIds.delete(id);\n      }\n      return persistentIds;\n    }\n\n    return createMorphContext;\n  })();\n\n  //=============================================================================\n  // HTML Normalization Functions\n  //=============================================================================\n  const { normalizeElement, normalizeParent } = (function () {\n    /** @type {WeakSet<Node>} */\n    const generatedByIdiomorph = new WeakSet();\n\n    /**\n     *\n     * @param {Element | Document} content\n     * @returns {Element}\n     */\n    function normalizeElement(content) {\n      if (content instanceof Document) {\n        return content.documentElement;\n      } else {\n        return content;\n      }\n    }\n\n    /**\n     *\n     * @param {null | string | Node | HTMLCollection | Node[] | Document & {generatedByIdiomorph:boolean}} newContent\n     * @returns {Element}\n     */\n    function normalizeParent(newContent) {\n      if (newContent == null) {\n        return document.createElement(\"div\"); // dummy parent element\n      } else if (typeof newContent === \"string\") {\n        return normalizeParent(parseContent(newContent));\n      } else if (\n        generatedByIdiomorph.has(/** @type {Element} */ (newContent))\n      ) {\n        // the template tag created by idiomorph parsing can serve as a dummy parent\n        return /** @type {Element} */ (newContent);\n      } else if (newContent instanceof Node) {\n        if (newContent.parentNode) {\n          // we can't use the parent directly because newContent may have siblings\n          // that we don't want in the morph, and reparenting might be expensive (TODO is it?),\n          // so instead we create a fake parent node that only sees a slice of its children.\n          /** @type {Element} */\n          return /** @type {any} */ (new SlicedParentNode(newContent));\n        } else {\n          // a single node is added as a child to a dummy parent\n          const dummyParent = document.createElement(\"div\");\n          dummyParent.append(newContent);\n          return dummyParent;\n        }\n      } else {\n        // all nodes in the array or HTMLElement collection are consolidated under\n        // a single dummy parent element\n        const dummyParent = document.createElement(\"div\");\n        for (const elt of [...newContent]) {\n          dummyParent.append(elt);\n        }\n        return dummyParent;\n      }\n    }\n\n    /**\n     * A fake duck-typed parent element to wrap a single node, without actually reparenting it.\n     * This is useful because the node may have siblings that we don't want in the morph, and it may also be moved\n     * or replaced with one or more elements during the morph. This class effectively allows us a window into\n     * a slice of a node's children.\n     * \"If it walks like a duck, and quacks like a duck, then it must be a duck!\" -- James Whitcomb Riley (1849â€“1916)\n     */\n    class SlicedParentNode {\n      /** @param {Node} node */\n      constructor(node) {\n        this.originalNode = node;\n        this.realParentNode = /** @type {Element} */ (node.parentNode);\n        this.previousSibling = node.previousSibling;\n        this.nextSibling = node.nextSibling;\n      }\n\n      /** @returns {Node[]} */\n      get childNodes() {\n        // return slice of realParent's current childNodes, based on previousSibling and nextSibling\n        const nodes = [];\n        let cursor = this.previousSibling\n          ? this.previousSibling.nextSibling\n          : this.realParentNode.firstChild;\n        while (cursor && cursor != this.nextSibling) {\n          nodes.push(cursor);\n          cursor = cursor.nextSibling;\n        }\n        return nodes;\n      }\n\n      /**\n       * @param {string} selector\n       * @returns {Element[]}\n       */\n      querySelectorAll(selector) {\n        return this.childNodes.reduce((results, node) => {\n          if (node instanceof Element) {\n            if (node.matches(selector)) results.push(node);\n            const nodeList = node.querySelectorAll(selector);\n            for (let i = 0; i < nodeList.length; i++) {\n              results.push(nodeList[i]);\n            }\n          }\n          return results;\n        }, /** @type {Element[]} */ ([]));\n      }\n\n      /**\n       * @param {Node} node\n       * @param {Node} referenceNode\n       * @returns {Node}\n       */\n      insertBefore(node, referenceNode) {\n        return this.realParentNode.insertBefore(node, referenceNode);\n      }\n\n      /**\n       * @param {Node} node\n       * @param {Node} referenceNode\n       * @returns {Node}\n       */\n      moveBefore(node, referenceNode) {\n        // @ts-ignore - use new moveBefore feature\n        return this.realParentNode.moveBefore(node, referenceNode);\n      }\n\n      /**\n       * for later use with populateIdMapWithTree to halt upwards iteration\n       * @returns {Node}\n       */\n      get __idiomorphRoot() {\n        return this.originalNode;\n      }\n    }\n\n    /**\n     *\n     * @param {string} newContent\n     * @returns {Node | null | DocumentFragment}\n     */\n    function parseContent(newContent) {\n      let parser = new DOMParser();\n\n      // remove svgs to avoid false-positive matches on head, etc.\n      let contentWithSvgsRemoved = newContent.replace(\n        /<svg(\\s[^>]*>|>)([\\s\\S]*?)<\\/svg>/gim,\n        \"\",\n      );\n\n      // if the newContent contains a html, head or body tag, we can simply parse it w/o wrapping\n      if (\n        contentWithSvgsRemoved.match(/<\\/html>/) ||\n        contentWithSvgsRemoved.match(/<\\/head>/) ||\n        contentWithSvgsRemoved.match(/<\\/body>/)\n      ) {\n        let content = parser.parseFromString(newContent, \"text/html\");\n        // if it is a full HTML document, return the document itself as the parent container\n        if (contentWithSvgsRemoved.match(/<\\/html>/)) {\n          generatedByIdiomorph.add(content);\n          return content;\n        } else {\n          // otherwise return the html element as the parent container\n          let htmlElement = content.firstChild;\n          if (htmlElement) {\n            generatedByIdiomorph.add(htmlElement);\n          }\n          return htmlElement;\n        }\n      } else {\n        // if it is partial HTML, wrap it in a template tag to provide a parent element and also to help\n        // deal with touchy tags like tr, tbody, etc.\n        let responseDoc = parser.parseFromString(\n          \"<body><template>\" + newContent + \"</template></body>\",\n          \"text/html\",\n        );\n        let content = /** @type {HTMLTemplateElement} */ (\n          responseDoc.body.querySelector(\"template\")\n        ).content;\n        generatedByIdiomorph.add(content);\n        return content;\n      }\n    }\n\n    return { normalizeElement, normalizeParent };\n  })();\n\n  //=============================================================================\n  // This is what ends up becoming the Idiomorph global object\n  //=============================================================================\n  return {\n    morph,\n    defaults,\n  };\n})();\n\nexport {Idiomorph};\n","let textarea\n\nexport const g = {\n\tscope: {}\n}\n\nexport const decodeHTML = (text) => {\n\ttextarea = textarea || document.createElement('textarea')\n\ttextarea.innerHTML = text\n\treturn textarea.value\n}\n\nexport const rAF = (fn) => {\n\tif (requestAnimationFrame)\n\t\treturn requestAnimationFrame(fn)\n\telse\n\t\treturn setTimeout(fn, 1000 / 60)\n}\n\nexport const uuid = () => {\n\treturn Math.random().toString(36).substring(2, 9)\n}\n\nexport const dup = (o) => {\n\treturn JSON.parse(JSON.stringify(o))\n}\n\nexport const safe = (execute, val) => {\n\ttry{\n\t\tconst value = execute()\n\t\treturn value !== undefined && value !== null ? value : val || ''\n\t}catch(err){\n\t\treturn val || ''\n\t}\n}\n","\nconst topics: any = {}\nconst _async: any = {}\n\nexport const publish = (name, params) => {\n\n\t_async[name] = isObject(params)? Object.assign({}, _async[name], params): params\n\n\tif (topics[name]) {\n\t\ttopics[name].forEach(topic => topic(params))\n\t}\n}\n\nexport const subscribe = (name, method) => {\n\ttopics[name] = topics[name] || []\n\ttopics[name].push(method)\n\tif (name in _async) {\n\t\tmethod(_async[name])\n\t}\n\treturn () => {\n\t\ttopics[name] = topics[name].filter( fn => fn != method )\n\t}\n}\n\nconst isObject = (value) => {\n\treturn (typeof value === 'object' && value !== null && !Array.isArray(value))\n}\n","import { Idiomorph } from 'idiomorph/dist/idiomorph.esm'\nimport { safe, g, dup } from './utils'\nimport { publish, subscribe } from './utils/pubsub'\n\nexport const Component = ({ name, module, dependencies, node, templates, signal, register }) => {\n\n\tlet tick\n\tlet preserve\t\t= []\n\tlet observer \t\t= null\n\tlet observables \t= []\n\tlet effect \t\t\t= null\n\n\tconst _model \t\t= module.model || {}\n\tconst initialState \t= (new Function( `return ${node.getAttribute('html-model') || '{}'}`))()\n\tconst tplid \t\t= node.getAttribute('tplid')\n\tconst scopeid \t\t= node.getAttribute('html-scopeid')\n\tconst tpl \t\t\t= templates[ tplid ]\n\tconst scope \t\t= g.scope[ scopeid ]\n\tconst model  \t\t= dup(module?.model?.apply ? _model({ elm:node, initialState, dependencies }) : _model)\n\tconst state \t\t= Object.assign({}, scope, model, initialState)\n\tconst view \t\t\t= module.view? module.view : (data) => data\n\n\tconst base = {\n\t\tname,\n\t\tmodel,\n\t\telm: node,\n\t\ttemplate: tpl.template,\n\t\tdependencies,\n\t\tpublish,\n\t\tsubscribe,\n\n\t\tmain(fn) {\n\t\t\tnode.addEventListener(':mount', fn)\n\t\t},\n\n\t\teffect(fn) {\n\t\t\tif( fn ) {\n\t\t\t\teffect = fn\n\t\t\t} else {\n\t\t\t\treturn effect\n\t\t\t}\n\t\t},\n\n\t\tquery( selector) {\n\t\t\tconst elements = Array.from(node.querySelectorAll(selector))\n\t\t\treturn elements.map( (element: HTMLElement) => {\n\t\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\t\tif (document.body.contains(element)) {\n\t\t\t\t\t\telement.addEventListener(':mount', () => resolve(element))\n\t\t\t\t\t} else {\n\t\t\t\t\t\treject(element)\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t})\n\t\t},\n\n\t\t/**\n\t\t * @State\n\t\t */\n\t\tstate : {\n\n\t\t\tprotected( list ) {\n\t\t\t\tif( list ) {\n\t\t\t\t\tpreserve = list\n\t\t\t\t} else {\n\t\t\t\t\treturn preserve\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tsave(data) {\n\t\t\t\tif( data.constructor === Function ) {\n\t\t\t\t\tdata( state )\n\t\t\t\t} else {\n\t\t\t\t\tObject.assign(state, data)\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tset( data ) {\n\n\t\t\t\tif (!document.body.contains(node)) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif( data.constructor === Function ) {\n\t\t\t\t\tdata(state)\n\t\t\t\t} else {\n\t\t\t\t\tObject.assign(state, data)\n\t\t\t\t}\n\n\t\t\t\tconst newstate = Object.assign({}, state)\n\n\t\t\t\treturn new Promise((resolve) => {\n\t\t\t\t\trender(newstate, () => resolve(newstate))\n\t\t\t\t})\n\t\t\t},\n\n\t\t\tget() {\n\t\t\t\treturn Object.assign({}, state)\n\t\t\t}\n\t\t},\n\n\t\tdataset( target, name ) {\n\n\t\t\tconst el = name? target : node\n\t\t\tconst key = name? name : target\n\t\t\tconst value = el.dataset[key]\n\n\t\t\tif (value === 'true') return true\n\t\t\tif (value === 'false') return false\n\t\t\tif (!isNaN(value) && value.trim() !== '') return Number(value)\n\n\t\t\ttry {\n\t\t\t\treturn new Function('return (' + value + ')')()\n\t\t\t} catch {}\n\n\t\t\ttry {\n\t\t\t\treturn JSON.parse(value)\n\t\t\t} catch {}\n\n\t\t\treturn value\n\t\t},\n\n\t\t/**\n\t\t * @Events\n\t\t */\n\t\ton( ev, selectorOrCallback, callback ) {\n\n\t\t\tconst attribute = ev.match(/\\[(.*)\\]/)\n\n\t\t\tif( attribute ) {\n\t\t\t\tobservables.push({\n\t\t\t\t\ttarget: callback? selectorOrCallback : null,\n\t\t\t\t\tcallback: callback || selectorOrCallback\n\t\t\t\t})\n\n\t\t\t\tif( !observer ) {\n\t\t\t\t\tobserver = new MutationObserver((mutationsList) => {\n\t\t\t\t\t\tfor (const mutation of mutationsList) {\n\t\t\t\t\t\t\tif (mutation.type === 'attributes') {\n\t\t\t\t\t\t\t\tconst attrname = mutation.attributeName\n\t\t\t\t\t\t\t\tif( attrname === attribute[1] ) {\n\t\t\t\t\t\t\t\t\tobservables.forEach( item => {\n\t\t\t\t\t\t\t\t\t\tconst target = item.target? node.querySelectorAll(item.target): [node]\n\t\t\t\t\t\t\t\t\t\ttarget.forEach( target => {\n\t\t\t\t\t\t\t\t\t\t\tif( target == mutation.target ) {\n\t\t\t\t\t\t\t\t\t\t\t\titem.callback({\n\t\t\t\t\t\t\t\t\t\t\t\t\ttarget: mutation.target,\n\t\t\t\t\t\t\t\t\t\t\t\t\tattribute: attrname,\n\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: mutation.target.getAttribute(attrname)\n\t\t\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\n\t\t\t\t\tobserver.observe(node, {\n\t\t\t\t\t\tattributes: true,\n\t\t\t\t\t\tsubtree: true\n\t\t\t\t\t})\n\n\t\t\t\t\tnode.addEventListener(':unmount', () => {\n\t\t\t\t\t\tobservables = []\n\t\t\t\t\t\tobserver.disconnect()\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif( callback ) {\n\t\t\t\tcallback.handler = (e) => {\n\t\t\t\t\tconst detail = e.detail || {}\n\t\t\t\t\tlet parent = e.target\n\t\t\t\t\twhile (parent) {\n\t\t\t\t\t\tif (parent.matches(selectorOrCallback)) {\n\t\t\t\t\t\t\te.delegateTarget = parent\n\t\t\t\t\t\t\tcallback.apply(node, [e].concat(detail.args))\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (parent === node) break\n\t\t\t\t\t\tparent = parent.parentNode\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnode.addEventListener(ev, callback.handler, {\n\t\t\t\t\tsignal,\n\t\t\t\t\tcapture: (ev == 'focus' || ev == 'blur' || ev == 'mouseenter' || ev == 'mouseleave')\n\t\t\t\t})\n\n\t\t\t} else {\n\t\t\t\tselectorOrCallback.handler = (e) => {\n\t\t\t\t\te.delegateTarget = node\n\t\t\t\t\tselectorOrCallback.apply(node, [e].concat(e.detail.args))\n\t\t\t\t}\n\t\t\t\tnode.addEventListener(ev, selectorOrCallback.handler, { signal })\n\t\t\t}\n\n\t\t},\n\n\t\toff( ev, callback ) {\n\t\t\tif( callback.handler ) {\n\t\t\t\tnode.removeEventListener(ev, callback.handler)\n\t\t\t}\n\t\t},\n\n\t\ttrigger(ev, selectorOrCallback, data = {}) {\n\t\t\tif( selectorOrCallback.constructor === String ) {\n\t\t\t\tArray\n\t\t\t\t\t.from(node.querySelectorAll(selectorOrCallback))\n\t\t\t\t\t.forEach( children => {\n\t\t\t\t\t\tchildren.dispatchEvent(new CustomEvent(ev, { bubbles: true, detail: { args: data } }) )\n\t\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tnode.dispatchEvent(new CustomEvent(ev, { bubbles: true, detail:{ args: data } }))\n\t\t\t}\n\t\t},\n\n\t\temit(ev, data) {\n\t\t\tnode.dispatchEvent(new CustomEvent(ev, { bubbles: true, detail: { args: data } }))\n\t\t},\n\n\t\tunmount( fn ) {\n\t\t\tnode.addEventListener(':unmount', fn)\n\t\t},\n\n\t\tinnerHTML ( target, html_ ) {\n\t\t\tconst element = html_? target : node\n\t\t\tconst clone = element.cloneNode()\n\t\t\tconst html = html_? html_ : target\n\t\t\tclone.innerHTML = html\n\t\t\tIdiomorph.morph(element, clone)\n\t\t}\n\t}\n\n\tconst render = ( data, callback = (() => {}) ) => {\n\t\tclearTimeout( tick )\n\t\ttick = setTimeout(() => {\n\t\t\tconst html = tpl.render.call({...data, ...view(data)}, node, safe, g )\n\t\t\tIdiomorph.morph(node, html, morphOptions(node, register, data) )\n\t\t\tPromise.resolve().then(() => {\n\t\t\t\tnode.querySelectorAll('[tplid]')\n\t\t\t\t\t.forEach((element) => {\n\t\t\t\t\t\tconst child = register.get(element)\n\t\t\t\t\t\tconst scope = { ...child.__scope__ }\n\t\t\t\t\t\tif(!child) return\n\t\t\t\t\t\tchild.state.protected().forEach( key => delete data[key] )\n\t\t\t\t\t\tconst useEffect = child.effect()\n\t\t\t\t\t\tif( useEffect ) {\n\t\t\t\t\t\t\tconst promise = useEffect({ ...data, ...scope})\n\t\t\t\t\t\t\tif( promise && promise.then ) {\n\t\t\t\t\t\t\t\tpromise.then(() => child.state.set({...data, ...scope }))\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tchild.state.set({...data, ...scope })\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tchild.state.set({...data, ...scope })\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\tPromise.resolve().then(() => {\n\t\t\t\t\tg.scope = {}\n\t\t\t\t\tcallback()\n\t\t\t\t})\n\t\t\t})\n\t\t})\n\t}\n\n\trender( state )\n\tregister.set( node, base )\n\treturn module.default( base )\n}\n\nconst morphOptions = ( parent, register, data ) => {\n\treturn {\n\t\tcallbacks: {\n\t\t\tbeforeNodeMorphed: update(parent, register, data)\n\t\t}\n\t}\n}\n\nconst update = (parent, register, data) => (node, newnode) => {\n\tif( node.nodeType === 1 ) {\n\t\tif( 'html-static' in node.attributes ) {\n\t\t\treturn false\n\t\t}\n\t\tif( register.get(node) && node !== parent ) {\n\t\t\tconst scopeid \t\t= newnode.getAttribute('html-scopeid')\n\t\t\tconst scope \t\t= g.scope[ scopeid ]\n\t\t\tconst base = register.get(node)\n\t\t\tbase.__scope__ = scope\n\t\t\treturn false\n\t\t}\n\t}\n}\n","import { Component } from './component'\n\nconst register = new WeakMap()\n\nexport const Element = ({ component, templates, start }) => {\n\n\tconst { name, module, dependencies } = component\n\n\treturn class extends HTMLElement {\n\n\t\tconstructor() {\n\t\t\tsuper()\n\t\t}\n\n\t\tconnectedCallback() {\n\n\t\t\tthis.abortController = new AbortController()\n\n\t\t\tif( !this.getAttribute('tplid') ) {\n\t\t\t\tstart( this.parentNode )\n\t\t\t}\n\n\t\t\tconst rtrn = Component({\n\t\t\t\tnode:this,\n\t\t\t\tname,\n\t\t\t\tmodule,\n\t\t\t\tdependencies,\n\t\t\t\ttemplates,\n\t\t\t\tsignal: this.abortController.signal,\n\t\t\t\tregister\n\t\t\t})\n\n\t\t\tif ( rtrn && rtrn.constructor === Promise ) {\n\t\t\t\trtrn.then(() => {\n\t\t\t\t\tthis.dispatchEvent( new CustomEvent(':mount') )\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tthis.dispatchEvent( new CustomEvent(':mount') )\n\t\t\t}\n\t\t}\n\n\t\tdisconnectedCallback() {\n\t\t\tthis.dispatchEvent( new CustomEvent(':unmount') )\n\t\t\tthis.abortController.abort()\n\t\t}\n\t}\n}\n","import { uuid, decodeHTML } from './utils'\n\nconst config = {\n\ttags: ['{{', '}}']\n}\n\nconst templates  = {}\nconst booleanAttrs = /html-(allowfullscreen|async|autofocus|autoplay|checked|controls|default|defer|disabled|formnovalidate|inert|ismap|itemscope|loop|multiple|muted|nomodule|novalidate|open|playsinline|readonly|required|reversed|selected)=\"(.*?)\"/g\nconst htmlAttr = /html-([^\\s]*?)=\"(.*?)\"/g\nconst tagExpr = () => new RegExp(`\\\\${config.tags[0]}(.+?)\\\\${config.tags[1]}`, 'g')\n\nexport const templateConfig = (newconfig) => {\n\tObject.assign( config, newconfig )\n}\n\nexport const template = ( target, { components }) => {\n\n\ttagElements( target, [...Object.keys( components ), 'template'], components )\n\tconst clone = target.cloneNode( true )\n\n\ttransformTemplate( clone )\n\tremoveTemplateTagsRecursively( clone )\n\tsetTemplates( clone, components )\n\n\treturn templates\n}\n\nexport const compile = ( html ) => {\n\n\tconst parsedHtml = JSON.stringify( html )\n\n\treturn new Function('$element', 'safe', '$g',`\n\t\tvar $data = this;\n\t\twith( $data ){\n\t\t\tvar output=${parsedHtml\n\t\t\t\t.replace(/%%_=(.+?)_%%/g, function(_, variable){\n\t\t\t\t\treturn '\"+safe(function(){return '+ decodeHTML(variable) +';})+\"'\n\t\t\t\t})\n\t\t\t\t.replace(/%%_(.+?)_%%/g, function(_, variable){\n\t\t\t\t\treturn '\";' + decodeHTML(variable) +'\\noutput+=\"'\n\t\t\t\t})};return output;\n\t\t}\n\t`)\n}\n\nconst tagElements = (target, keys, components) => {\n\tconst isComponent = key => key in components\n\tconst selector = keys.join(',')\n\n\ttarget.querySelectorAll(selector).forEach(node => {\n\t\tif (node.localName === 'template') {\n\t\t\ttagElements(node.content, keys, components)\n\t\t\treturn\n\t\t}\n\t\tif (isComponent(node.localName)) {\n\t\t\tnode.setAttribute('tplid', uuid())\n\t\t}\n\t})\n}\n\nconst transformAttributes = (html) => {\n\treturn html\n\t\t.replace(/jails___scope-id/g, '%%_=$scopeid_%%')\n\t\t.replace(tagExpr(), '%%_=$1_%%')\n\t\t.replace(booleanAttrs, `%%_if(safe(function(){ return $2 })){_%%$1%%_}_%%`)\n\t\t.replace(htmlAttr, (all, key, value) => {\n\t\t\tif (['model', 'scopeid'].includes(key)) return all\n\t\t\tif (value) {\n\t\t\t\tvalue = value.replace(/^{|}$/g, '')\n\t\t\t\treturn `${key}=\"%%_=safe(function(){ return ${value} })_%%\"`\n\t\t\t}\n\t\t\treturn all\n\t\t})\n}\n\nconst transformTemplate = ( clone ) => {\n\n\tclone.querySelectorAll('template, [html-for], [html-if], [html-inner], [html-class]')\n\t\t.forEach(( element ) => {\n\n\t\t\tconst htmlFor \t= element.getAttribute('html-for')\n\t\t\tconst htmlIf \t= element.getAttribute('html-if')\n\t\t\tconst htmlInner = element.getAttribute('html-inner')\n\t\t\tconst htmlClass = element.getAttribute('html-class')\n\n\t\t\tif ( htmlFor ) {\n\n\t\t\t\telement.removeAttribute('html-for')\n\n\t\t\t\tconst split \t = htmlFor.match(/(.*)\\sin\\s(.*)/) || ''\n\t\t\t\tconst varname \t = split[1]\n\t\t\t\tconst object \t = split[2]\n\t\t\t\tconst objectname = object.split(/\\./).shift()\n\t\t\t\tconst open \t\t = document.createTextNode(`%%_ ;(function(){ var $index = 0; for(var $key in safe(function(){ return ${object} }) ){ var $scopeid = Math.random().toString(36).substring(2, 9); var ${varname} = ${object}[$key]; $g.scope[$scopeid] = Object.assign({}, { ${objectname}: ${objectname} }, { ${varname} :${varname}, $index: $index, $key: $key }); _%%`)\n\t\t\t\tconst close \t = document.createTextNode(`%%_ $index++; } })() _%%`)\n\n\t\t\t\twrap(open, element, close)\n\t\t\t}\n\n\t\t\tif (htmlIf) {\n\t\t\t\telement.removeAttribute('html-if')\n\t\t\t\tconst open = document.createTextNode(`%%_ if ( safe(function(){ return ${htmlIf} }) ){ _%%`)\n\t\t\t\tconst close = document.createTextNode(`%%_ }  _%%`)\n\t\t\t\twrap(open, element, close)\n\t\t\t}\n\n\t\t\tif (htmlInner) {\n\t\t\t\telement.removeAttribute('html-inner')\n\t\t\t\telement.innerHTML = `%%_=${htmlInner}_%%`\n\t\t\t}\n\n\t\t\tif (htmlClass) {\n\t\t\t\telement.removeAttribute('html-class')\n\t\t\t\telement.className = (element.className + ` %%_=${htmlClass}_%%`).trim()\n\t\t\t}\n\n\t\t\tif( element.localName === 'template' ) {\n\t\t\t\ttransformTemplate(element.content)\n\t\t\t}\n\t\t})\n}\n\nconst setTemplates = ( clone, components ) => {\n\n\tArray.from(clone.querySelectorAll('[tplid]'))\n\t\t.reverse()\n\t\t.forEach((node) => {\n\n\t\t\tconst tplid = node.getAttribute('tplid')\n\t\t\tconst name  = node.localName\n\t\t\tnode.setAttribute('html-scopeid', 'jails___scope-id')\n\n\t\t\tif( name in components && components[name].module.template ) {\n\t\t\t\tconst children = node.innerHTML\n\t\t\t\tconst html = components[name].module.template({ elm:node, children })\n\t\t\t\tnode.innerHTML = html\n\t\t\t\ttemplate(node, { components })\n\t\t\t\ttransformTemplate(node)\n\t\t\t\tremoveTemplateTagsRecursively(node)\n\t\t\t}\n\n\t\t\tconst html = transformAttributes(node.outerHTML)\n\n\t\t\ttemplates[ tplid ] = {\n\t\t\t\ttemplate: html,\n\t\t\t\trender\t: compile(html)\n\t\t\t}\n\t\t})\n\n}\n\nconst removeTemplateTagsRecursively = (node) => {\n\n\t// Get all <template> elements within the node\n\tconst templates = node.querySelectorAll('template')\n\n\ttemplates.forEach((template) => {\n\n\t\tif( template.getAttribute('html-if') || template.getAttribute('html-inner') ) {\n\t\t\treturn\n\t\t}\n\n\t\t// Process any nested <template> tags within this <template> first\n\t\tremoveTemplateTagsRecursively(template.content)\n\n\t\t// Get the parent of the <template> tag\n\t\tconst parent = template.parentNode\n\n\t\tif (parent) {\n\t\t\t// Move all child nodes from the <template>'s content to its parent\n\t\t\tconst content = template.content\n\t\t\twhile (content.firstChild) {\n\t\t\t\tparent.insertBefore(content.firstChild, template)\n\t\t\t}\n\t\t\t// Remove the <template> tag itself\n\t\t\tparent.removeChild(template)\n\t\t}\n\t})\n}\n\n\nconst wrap = (open, node, close) => {\n\tnode.parentNode?.insertBefore(open, node)\n\tnode.parentNode?.insertBefore(close, node.nextSibling)\n}\n","import { Element } from './element'\nimport { template, templateConfig as config } from './template-system'\n\nexport { publish, subscribe } from './utils/pubsub'\n\nexport const templateConfig = (options) => {\n\tconfig( options )\n}\n\nglobalThis.__jails__ = globalThis.__jails__ || { components: {} }\n\nexport const register = ( name, module, dependencies ) => {\n\tconst { components } = globalThis.__jails__\n\tcomponents[ name ] = { name, module, dependencies }\n}\n\nexport const start = ( target ) => {\n\t// If the code is running in a Node.js environment, do nothing\n\tif( typeof window === 'undefined' ) {\n\t\treturn;\n\t}\n\n\ttarget = target || document.body\n\tconst { components } = globalThis.__jails__\n\tconst templates = template( target, { components } )\n\n\tObject\n\t\t.values( components )\n\t\t.forEach(({ name, module, dependencies }) => {\n\t\t\tif( !customElements.get(name) ) {\n\t\t\t\tcustomElements.define( name, Element({ component: { name, module, dependencies }, templates, start }))\n\t\t\t}\n\t})\n}\n"],"names":["Idiomorph","noOp","defaults","morphStyle","callbacks","beforeNodeAdded","afterNodeAdded","beforeNodeMorphed","afterNodeMorphed","beforeNodeRemoved","afterNodeRemoved","beforeAttributeUpdated","head","style","shouldPreserve","elt","getAttribute","shouldReAppend","shouldRemove","afterHeadMorphed","restoreFocus","morphChildren","createNode","oldParent","newChild","insertionPoint","ctx","idMap","has","newEmptyChild","document","createElement","tagName","insertBefore","morphNode","newClonedChild","importNode","findBestMatch","isIdSetMatch","oldNode","newNode","oldSet","get","newSet","id","isSoftMatch","oldElt","newElt","nodeType","_a","call","_b","_c","node","startPoint","endPoint","softMatch","nextSibling","siblingSoftMatchCount","cursor","activeElementAndParents","includes","removeNode","moveBefore","pantry","parentNode","removeChild","removeNodesBetween","startInclusive","endExclusive","tempNode","moveBeforeById","after","target","querySelector","element","idSet","delete","size","removeElementFromAncestorsIdMaps","e","newParent","HTMLTemplateElement","content","firstChild","childNodes","bestMatch","Element","newChildId","persistentIds","movedChild","insertedNode","syncBooleanAttribute","oldElement","newElement","attributeName","newLiveValue","ignoreUpdate","ignoreAttribute","setAttribute","removeAttribute","attr","updateType","ignoreActiveValue","activeElement","ignoreValueOfActiveElement","possibleActiveElement","body","newContent","ignoreActive","HTMLHeadElement","ignore","handleHeadElement","type","oldAttributes","attributes","newAttributes","newAttribute","name","value","i","length","oldAttribute","hasAttribute","HTMLInputElement","newValue","oldValue","HTMLOptionElement","HTMLTextAreaElement","nodeValue","syncInputValue","morphAttributes","oldHead","newHead","added","removed","preserved","nodesToAppend","srcToNewHeadNodes","Map","newHeadChild","children","set","outerHTML","currentHeadElt","inNewContent","isReAppended","isPreserved","push","values","promises","createRange","createContextualFragment","href","src","resolve","promise","Promise","_resolve","addEventListener","appendChild","removedElement","kept","createMorphContext","createPantry","hidden","insertAdjacentElement","createActiveElementAndParents","contains","parentElement","findIdElements","root","elements","Array","from","querySelectorAll","populateIdMapWithTree","current","Set","add","config","oldContent","oldIdElements","newIdElements","duplicateIds","oldIdTagNameMap","createPersistentIds","newRoot","__idiomorphRoot","createIdMaps","mergedConfig","finalConfig","Object","assign","mergeDefaults","normalizeElement","normalizeParent","generatedByIdiomorph","WeakSet","SlicedParentNode","constructor","this","originalNode","realParentNode","previousSibling","nodes","selector","reduce","results","matches","nodeList","referenceNode","Document","documentElement","parser","DOMParser","contentWithSvgsRemoved","replace","match","parseFromString","htmlElement","parseContent","Node","dummyParent","append","morph","morphedNodes","fn","activeElementId","selectionStart","selectionEnd","focus","setSelectionRange","saveAndRestoreFocus","callback","block","all","then","newCtx","withHeadBlocking","morphOuterHTML","remove","textarea","g","scope","decodeHTML","text","innerHTML","safe","execute","val","err","topics","_async","publish","params","isObject","forEach","topic","subscribe","method","filter","isArray","Component","module","dependencies","templates","signal","register","tick","preserve","observer","observables","effect","_model","model","initialState","Function","tplid","scopeid","tpl","o","apply","elm","JSON","parse","stringify","state","view","data","base","template","main","query","map","reject","protected","list","save","newstate","render","dataset","key","isNaN","trim","Number","on","ev","selectorOrCallback","attribute","MutationObserver","mutationsList","mutation","attrname","item","observe","subtree","disconnect","handler","detail","parent","delegateTarget","concat","args","capture","off","removeEventListener","trigger","String","dispatchEvent","CustomEvent","bubbles","emit","unmount","html_","clone","cloneNode","html","clearTimeout","setTimeout","__spreadValues","morphOptions","child","__scope__","useEffect","default","update","newnode","WeakMap","component","start","HTMLElement","super","connectedCallback","abortController","AbortController","rtrn","disconnectedCallback","abort","tags","booleanAttrs","htmlAttr","components","tagElements","keys","transformTemplate","removeTemplateTagsRecursively","setTemplates","compile","parsedHtml","_","variable","join","localName","Math","random","toString","substring","transformAttributes","RegExp","htmlFor","htmlIf","htmlInner","htmlClass","split","varname","object","objectname","shift","open","createTextNode","close","wrap","className","reverse","globalThis","__jails__","window","customElements","define","options","newconfig"],"mappings":"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","x_google_ignoreList":[0]}